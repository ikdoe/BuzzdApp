rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Read-only city cache for Places datasets populated by Cloud Functions
    match /cached_places/{id} {
      allow get, list: if true;      // Consider restricting to approved users
      allow create, update, delete: if false;
    }

    /* NEW: Public, read-only stats (server writes only via Cloud Functions) */
    match /public/stats {
      allow read: if true;
      allow write: if false;
    }

    // Leaderboards removed

    // ===== CHATS =====
    match /chats/{chatId} {
      // Per-doc read: only participants, and only verified users
      allow get: if hasValidEmail() && request.auth.uid in resource.data.participants;
      // Query/list allowed; per-doc get above filters results
      allow list: if hasValidEmail();

      // Create (only approved users)
      allow create: if isApprovedUser()
        && request.resource.data.type in ['direct','group']
        && request.resource.data.participants is list
        && request.resource.data.participants.size() >= 2
        && request.auth.uid in request.resource.data.participants
        && request.resource.data.createdAt is timestamp
        && (
          (request.resource.data.type == 'direct'
            && request.resource.data.keys().hasOnly([
              'name','type','participants','participantNames','createdBy','createdAt','pairKey',
              'lastMessage','lastMessageAt','lastMessageSenderId'
            ])
            && request.resource.data.pairKey is string
          ) ||
          (request.resource.data.type == 'group'
            && request.resource.data.keys().hasOnly([
              'name','type','participants','participantNames','createdBy','createdAt',
              'lastMessage','lastMessageAt','lastMessageSenderId'
            ])
            && !('pairKey' in request.resource.data)
          )
        )
        && (!('lastMessage' in request.resource.data) || request.resource.data.lastMessage is string || request.resource.data.lastMessage == null)
        && (!('lastMessageAt' in request.resource.data) || request.resource.data.lastMessageAt is timestamp || request.resource.data.lastMessageAt == null)
        && (!('lastMessageSenderId' in request.resource.data) || request.resource.data.lastMessageSenderId is string || request.resource.data.lastMessageSenderId == null)
        && request.resource.data.participantNames is map;

      // Update (immutable + safe fields) — approved users only
      allow update: if isApprovedUser()
        && request.auth.uid in resource.data.participants
        && request.resource.data.participants == resource.data.participants
        && request.resource.data.createdBy == resource.data.createdBy
        && request.resource.data.type == resource.data.type
        && request.resource.data.createdAt == resource.data.createdAt
        && (
          (resource.data.type == 'direct' && request.resource.data.pairKey == resource.data.pairKey)
          || (resource.data.type == 'group' && !('pairKey' in request.resource.data) && !('pairKey' in resource.data))
        )
        && (
          (resource.data.type == 'direct'
            && request.resource.data.keys().hasOnly([
              'name','type','participants','participantNames','createdBy','createdAt','pairKey',
              'lastMessage','lastMessageAt','lastMessageSenderId'
            ])
          ) ||
          (resource.data.type == 'group'
            && request.resource.data.keys().hasOnly([
              'name','type','participants','participantNames','createdBy','createdAt',
              'lastMessage','lastMessageAt','lastMessageSenderId'
            ])
          )
        )
        && (!('lastMessage' in request.resource.data) || request.resource.data.lastMessage is string || request.resource.data.lastMessage == null)
        && (!('lastMessageAt' in request.resource.data) || request.resource.data.lastMessageAt is timestamp || request.resource.data.lastMessageAt == null)
        && (!('lastMessageSenderId' in request.resource.data) || request.resource.data.lastMessageSenderId is string || request.resource.data.lastMessageSenderId == null)
        && request.resource.data.participantNames is map;

      match /messages/{msgId} {
        // Only verified participants may read messages
        allow get, list: if hasValidEmail()
          && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;

        // Only approved participants may create messages
        allow create: if isApprovedUser()
          && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants
          && request.resource.data.keys().hasOnly(['senderId','senderName','text','type','createdAt','venueSnapshot'])
          && request.resource.data.senderId == request.auth.uid
          && request.resource.data.createdAt is timestamp
          && (!('venueSnapshot' in request.resource.data) || isValidVenueSnapshot(request.resource.data.venueSnapshot));

        // Allow approved participants to mark messages as read. Only 'readBy' may change.
        allow update: if isApprovedUser()
          && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants
          && request.resource.data.keys().hasOnly(['senderId','senderName','text','type','createdAt','readBy','venueSnapshot'])
          && request.resource.data.senderId == resource.data.senderId
          && request.resource.data.senderName == resource.data.senderName
          && request.resource.data.text == resource.data.text
          && request.resource.data.type == resource.data.type
          && request.resource.data.createdAt == resource.data.createdAt
          && (!('venueSnapshot' in request.resource.data) || request.resource.data.venueSnapshot == resource.data.venueSnapshot)
          && ('readBy' in request.resource.data)
          && request.resource.data.readBy is list
          && request.auth.uid in request.resource.data.readBy;

        allow delete: if false;
      }

      // Allow a participant to delete the chat (leave) — approved only.
      allow delete: if isApprovedUser() && request.auth.uid in resource.data.participants;

      // Typing indicators (ephemeral, per-user docs)
      match /typing/{uid} {
        // Verified participants may read typing indicators
        allow get, list: if hasValidEmail()
          && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;

        // Approved participants may write typing indicators
        allow create, update: if isApprovedUser()
          && request.auth.uid == uid
          && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants
          && request.resource.data.keys().hasOnly(['uid','isTyping','updatedAt'])
          && request.resource.data.uid == uid
          && request.resource.data.isTyping is bool
          && request.resource.data.updatedAt is timestamp;

        allow delete: if isApprovedUser() && request.auth.uid == uid;
      }
    }

    // === Hosts: Subscriptions ===
    match /hostSubscriptions/{subId} {
      allow get: if hasValidEmail() && resource.data.subscriberId == request.auth.uid;
      allow list: if hasValidEmail();
      allow create: if isApprovedUser()
        && request.resource.data.keys().hasOnly(['subscriberId','hostId','hostName','hostAvatarURL','subscribedAt'])
        && request.resource.data.subscriberId == request.auth.uid
        && request.resource.data.hostId is string
        && request.resource.data.subscribedAt is timestamp
        && (!('hostName' in request.resource.data) || request.resource.data.hostName is string)
        && (!('hostAvatarURL' in request.resource.data) || request.resource.data.hostAvatarURL is string);
      allow update: if false;
      allow delete: if isApprovedUser() && resource.data.subscriberId == request.auth.uid;
    }
    // ===== Helper functions (unchanged) =====
    function isValidDukesEmail(email) {
      return email is string
        && email.matches('(?i)^[A-Z0-9._%+-]+@(dukes\\.)?jmu\\.edu$');
    }
    // Validate structure of embedded venue snapshot in chat messages
    function isValidVenueSnapshot(v) {
      return v is map
        && ('placeId' in v) && v.placeId is string
        && ('name' in v) && v.name is string
        && ('address' in v) && v.address is string
        && (!('photoURL' in v) || v.photoURL is string)
        && (!('coverCharge' in v) || v.coverCharge is int)
        && (!('peopleCount' in v) || v.peopleCount is int)
        && (!('rating' in v) || v.rating is float || v.rating is int)
        && ('sharedAt' in v) && v.sharedAt is timestamp;
    }
    function isAuthenticated() { return request.auth != null; }
    function isAdmin() { return isAuthenticated() && request.auth.token.admin == true; }
    function isOwner(uid) { return isAuthenticated() && request.auth.uid == uid; }
    // Email helpers
    // Domain check only (no verification requirement)
    function hasValidEmailDomain() {
      return isAuthenticated()
        && request.auth.token.email != null
        && isValidDukesEmail(request.auth.token.email);
    }
    // Verified JMU email (preferred for privileged access)
    function hasValidEmail() {
      return hasValidEmailDomain()
        && request.auth.token.email_verified == true;
    }
    function isApprovedUser() {
      return hasValidEmail()
        && exists(/databases/$(database)/documents/users/$(request.auth.uid))
        && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.approved == true;
    }

    // ===== META counter (for sequential ranks) =====
    // meta/waitlist => { nextRank: int }
    // meta/mobile-waitlist => { nextRank: int }
    match /meta/{metaId} {
      allow get: if metaId in ['waitlist', 'mobile-waitlist'];
      allow list: if false;
      allow create, update: if metaId in ['waitlist', 'mobile-waitlist']
        && request.resource.data.keys().hasOnly(['nextRank'])
        && request.resource.data.nextRank is int
        && (
          !exists(/databases/$(database)/documents/meta/$(metaId)) ||
          request.resource.data.nextRank ==
            get(/databases/$(database)/documents/meta/$(metaId)).data.nextRank + 1
        );
      allow delete: if false;
    }

    // ===== Referral code map (public; no PII) =====
    match /refcodes/{refCode} {
      allow create: if
        request.resource.data.keys().hasOnly(['ownerId','createdAt']) &&
        request.resource.data.ownerId is string &&
        !exists(/databases/$(database)/documents/refcodes/$(refCode));
      allow get: if true;
      allow list, update, delete: if false;
    }

    // ===== Main WAITLIST =====
    match /waitlist/{docId} {
      allow create: if
        request.resource.data.keys().hasOnly([
          'email','status','joinedAt','rank','position','refCode','referredBy','referrals','source'
        ]) &&
        request.resource.data.email is string &&
        request.resource.data.email.matches('(?i)^[A-Z0-9._%+-]+@dukes\\.jmu\\.edu$') &&
        request.resource.data.status in ['pending','approved'] &&
        request.resource.data.rank is int &&
        request.resource.data.position is int &&
        request.resource.data.refCode is string &&
        request.resource.data.referrals is int &&
        request.resource.data.source == 'website';

      // NOTE: still readable to avoid breaking current client flow.
      allow get: if true;
      allow list: if true;

      allow update: if
        request.resource.data.keys().hasOnly([
          'email','status','joinedAt','rank','position','refCode','referredBy','referrals','source'
        ]) &&
        request.resource.data.email == resource.data.email &&
        request.resource.data.refCode == resource.data.refCode &&
        request.resource.data.joinedAt == resource.data.joinedAt &&
        request.resource.data.source == resource.data.source &&
        request.resource.data.rank is int &&
        request.resource.data.position is int &&
        request.resource.data.referrals is int &&
        request.resource.data.status in ['pending','approved'];
      allow delete: if false;
    }

    // ===== Privacy-safe MOBILE waitlist (same shape) =====
    match /mobile-waitlist/{docId} {
      allow create: if
        request.resource.data.keys().hasOnly([
          'email','status','joinedAt','rank','position','refCode','referredBy','referrals','source'
        ]) &&
        request.resource.data.email is string &&
        request.resource.data.email.matches('(?i)^[A-Z0-9._%+-]+@dukes\\.jmu\\.edu$') &&
        request.resource.data.status in ['pending','approved'] &&
        request.resource.data.rank is int &&
        request.resource.data.position is int &&
        request.resource.data.refCode is string &&
        request.resource.data.referrals is int &&
        request.resource.data.source == 'mobile';

      allow get: if true;
      allow list: if true;

      allow update: if
        request.resource.data.keys().hasOnly([
          'email','status','joinedAt','rank','position','refCode','referredBy','referrals','source'
        ]) &&
        request.resource.data.email == resource.data.email &&
        request.resource.data.refCode == resource.data.refCode &&
        request.resource.data.joinedAt == resource.data.joinedAt &&
        request.resource.data.source == resource.data.source &&
        request.resource.data.rank is int &&
        request.resource.data.position is int &&
        request.resource.data.referrals is int &&
        request.resource.data.status in ['pending','approved'];
      allow delete: if false;
    }

    // ===== USERS =====
    match /users/{uid} {
      // Allow the signed-in owner to read their own profile even before verification
      // so the app can show the verification screen; everyone else requires verified email.
      allow read: if isOwner(uid) || hasValidEmail();
      // Allow collection queries for equality searches (rules still enforce per-doc read above).
      allow list: if hasValidEmail();

      // Allow profile doc creation post-auth with domain only; mark approved false at creation
      allow create: if isOwner(uid) && (
        (
          // JMU email account creation
          hasValidEmailDomain()
          && request.resource.data.keys().hasAll(['email', 'name', 'status', 'approved', 'createdAt', 'updatedAt'])
          && request.resource.data.email == request.auth.token.email
          && request.resource.data.status == 'active'
          && request.resource.data.approved == false
          && (!('username' in request.resource.data) || (
            request.resource.data.username is string
            && request.resource.data.username.size() >= 3
            && request.resource.data.username.size() <= 20
            && request.resource.data.username.matches('^[a-zA-Z0-9_.]+$')
            && !request.resource.data.username.matches('^[_.]')
            && !request.resource.data.username.matches('[_.]$')
            && !request.resource.data.username.matches('.*[_.]{2,}.*')
          ))
        ) || (
          // Anonymous user creation for ticket purchases (relaxed validation)
          request.auth.token.firebase.sign_in_provider == 'anonymous'
          && request.resource.data.email is string
          && request.resource.data.email.size() > 0
          && request.resource.data.isAnonymous == true
          && request.resource.data.createdAt is timestamp
          && request.resource.data.updatedAt is timestamp
        )
      );

      // Allow three safe paths for updates:
      // 1) Full-profile updates for approved JMU accounts (original behavior)
      // 2) Lightweight updates that only change fcmTokens/updatedAt (to enable push)
      // 3) Anonymous user profile updates for ticket purchases
      allow update: if isOwner(uid) && (
        (
          hasValidEmail()
          && (!('email' in resource.data) || request.resource.data.email == resource.data.email)
          // Permit flipping approved from false -> true ONLY after email verification
          && (
            (!('approved' in resource.data)) ||
            (request.resource.data.approved == resource.data.approved) ||
            (resource.data.approved == false && request.resource.data.approved == true && request.auth.token.email_verified == true)
          )
          && (!('createdAt' in resource.data) || request.resource.data.createdAt == resource.data.createdAt)
          && (!('username' in request.resource.data) || (
            request.resource.data.username is string
            && request.resource.data.username.size() >= 3
            && request.resource.data.username.size() <= 20
            && request.resource.data.username.matches('^[a-zA-Z0-9_.]+$')
            && !request.resource.data.username.matches('^[_.]')
            && !request.resource.data.username.matches('[_.]$')
            && !request.resource.data.username.matches('.*[_.]{2,}.*')
          ))
        )
        ||
        (
          // Only fcmTokens and/or updatedAt changed (permit regardless of email domain)
          request.resource.data.diff(resource.data).changedKeys().hasOnly(['fcmTokens', 'updatedAt'])
          // Ensure fcmTokens, when present, is a list
          && (!('fcmTokens' in request.resource.data) || request.resource.data.fcmTokens is list)
        )
        ||
        (
          // Anonymous user updates for ticket purchases (relaxed)
          request.auth.token.firebase.sign_in_provider == 'anonymous'
          && request.resource.data.isAnonymous == true
          && request.resource.data.email is string
          && request.resource.data.email.size() > 0
        )
      );

      allow delete: if false;

      // --- User-scoped notifications (secure queries)
      match /notifications/{notifId} {
        // Only the owner can query or read
        allow get: if isOwner(uid);
        allow list: if isOwner(uid);

        // Server (Cloud Functions/admin) should create; clients cannot
        allow create: if false;

        // Owner can mark as read/archived; immutable metadata
        allow update: if isOwner(uid)
          && request.resource.data.keys().hasOnly(['userId','type','title','body','isRead','archived','createdAt','readAt','actorId','actionId'])
          && request.resource.data.userId == resource.data.userId
          && request.resource.data.type == resource.data.type
          && request.resource.data.title == resource.data.title
          && request.resource.data.body == resource.data.body
          && request.resource.data.createdAt == resource.data.createdAt
          && request.resource.data.isRead is bool
          && (!('archived' in request.resource.data) || request.resource.data.archived is bool)
          && (!('readAt' in request.resource.data) || request.resource.data.readAt is timestamp);

        allow delete: if false;
      }

      // --- User-scoped FCM token subcollection: users/{uid}/fcmTokens/{tokenId}
      match /fcmTokens/{tokenId} {
        // Relaxed: allow the authenticated owner to read/write regardless of email verification
        // Rationale: devices must register tokens before verification/approval to receive push for flows like friend requests.
        allow read, write: if isAuthenticated() && request.auth.uid == uid;
      }

      // --- User-scoped tickets (owner read-only)
      match /tickets/{ticketId} {
        allow get: if isOwner(uid);
        allow list: if isOwner(uid);
        allow create, update, delete: if false;
      }

      // --- Friend links (symmetric markers used by rules)
      match /friends/{friendId} {
        // Owner can see their own friend links (only when verified)
        allow get, list: if hasValidEmail() && isOwner(uid);
        // Either participant may create the link (client-side on accept) — approved only
        allow create: if isApprovedUser()
          && (request.auth.uid == uid || request.auth.uid == friendId)
          && request.resource.data.keys().hasOnly(['uid','createdAt'])
          && request.resource.data.uid == friendId
          && request.resource.data.createdAt is timestamp;
        // Only allow delete by owner (or friend to remove themselves) — approved only
        allow delete: if isApprovedUser() && (request.auth.uid == uid || request.auth.uid == friendId);
        allow update: if false;
      }
    }

    // ===== USERNAME CLAIMS =====
    match /usernames/{usernameId} {
      allow get: if true;
      allow list: if false;

      allow create: if isApprovedUser()
        && !exists(/databases/$(database)/documents/usernames/$(usernameId))
        && request.resource.data.keys().hasOnly(['username','ownerId','email','createdAt'])
        && request.resource.data.username == usernameId
        && request.resource.data.ownerId == request.auth.uid
        && request.resource.data.email is string
        && request.resource.data.createdAt is timestamp;

      allow update: if isApprovedUser()
        && request.resource.data.keys().hasOnly(['username','ownerId','email','createdAt'])
        && resource.data.ownerId == request.auth.uid
        && request.resource.data.username == resource.data.username
        && request.resource.data.ownerId == request.auth.uid
        && request.resource.data.email is string
        && request.resource.data.createdAt == resource.data.createdAt;

      allow delete: if isApprovedUser() && resource.data.ownerId == request.auth.uid;
    }

    // ===== FRIEND REQUESTS =====
    match /friendRequests/{requestId} {
      allow get, list: if hasValidEmail()
        && (request.auth.uid == resource.data.senderId || request.auth.uid == resource.data.recipientId);

      allow create: if isApprovedUser()
        && request.resource.data.keys().hasOnly([
          'senderId','recipientId','senderName','senderEmail','senderAvatarURL',
          'recipientName','recipientEmail','recipientAvatarURL','status','createdAt'
        ])
        && request.resource.data.senderId == request.auth.uid
        && request.resource.data.senderId is string
        && request.resource.data.recipientId is string
        && request.resource.data.senderName is string
        && request.resource.data.senderEmail is string
        && (!('senderAvatarURL' in request.resource.data) || request.resource.data.senderAvatarURL is string)
        && (!('recipientName' in request.resource.data) || request.resource.data.recipientName is string)
        && (!('recipientEmail' in request.resource.data) || request.resource.data.recipientEmail is string)
        && (!('recipientAvatarURL' in request.resource.data) || request.resource.data.recipientAvatarURL is string)
        && request.resource.data.status == 'pending'
        && request.resource.data.senderId != request.resource.data.recipientId
        && request.resource.data.createdAt is timestamp;

      allow update: if isApprovedUser()
        && resource.data.recipientId == request.auth.uid
        && request.resource.data.keys().hasOnly([
          'senderId','recipientId','senderName','senderEmail','senderAvatarURL',
          'recipientName','recipientEmail','recipientAvatarURL','status','createdAt','updatedAt'
        ])
        && request.resource.data.senderId == resource.data.senderId
        && request.resource.data.recipientId == resource.data.recipientId
        && request.resource.data.senderName == resource.data.senderName
        && request.resource.data.senderEmail == resource.data.senderEmail
        && (!('senderAvatarURL' in request.resource.data) || request.resource.data.senderAvatarURL == resource.data.senderAvatarURL)
        && (!('recipientName' in request.resource.data) || request.resource.data.recipientName == resource.data.recipientName)
        && (!('recipientEmail' in request.resource.data) || request.resource.data.recipientEmail == resource.data.recipientEmail)
        && (!('recipientAvatarURL' in request.resource.data) || request.resource.data.recipientAvatarURL == resource.data.recipientAvatarURL)
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.status in ['accepted','declined']
        && request.resource.data.updatedAt is timestamp;

      allow delete: if isApprovedUser()
        && (resource.data.senderId == request.auth.uid || resource.data.recipientId == request.auth.uid);
    }

    // ===== FRIENDSHIPS =====
    match /friendships/{friendshipId} {
      allow get, list: if hasValidEmail() && request.auth.uid in resource.data.participants;

      allow create: if isApprovedUser()
        && request.resource.data.keys().hasOnly(['participants','status','createdAt','pairKey'])
        && request.resource.data.participants is list
        && request.resource.data.participants.size() == 2
        && request.resource.data.participants[0] is string
        && request.resource.data.participants[1] is string
        && request.resource.data.participants[0] != request.resource.data.participants[1]
        && request.auth.uid in request.resource.data.participants
        && request.resource.data.status in ['accepted','friends']
        && request.resource.data.createdAt is timestamp
        && request.resource.data.pairKey is string;

      allow update: if isApprovedUser()
        && request.auth.uid in resource.data.participants
        && request.resource.data.keys().hasOnly(['participants','status','createdAt','pairKey'])
        && request.resource.data.participants == resource.data.participants
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.pairKey == resource.data.pairKey
        && request.resource.data.status in ['accepted','friends'];

      allow delete: if isApprovedUser() && request.auth.uid in resource.data.participants;
    }

    // ===== VENUES =====
    match /venues/{venueId} {
      // Allow public read for venues (needed for unauthenticated map/discover views)
      allow read: if true;
      allow list: if true;
      allow create: if isApprovedUser()
        && request.resource.data.keys().hasAll([
          'placeId', 'name', 'address', 'latitude', 'longitude', 'venueType', 'createdAt', 'lastUpdated'
        ])
        && request.resource.data.placeId is string
        && request.resource.data.name is string
        && request.resource.data.address is string
        && request.resource.data.latitude is number
        && request.resource.data.longitude is number
        && request.resource.data.venueType is string;
      // Admin-only updates, constrained to specific fields
      allow update: if isAdmin()
        && request.resource.data.diff(resource.data).changedKeys().hasOnly([
          'coverCharge','venueType','averageRating','totalRatings','lastUpdated'
        ])
        && (!('coverCharge' in request.resource.data) || request.resource.data.coverCharge is int)
        && (!('venueType' in request.resource.data) || request.resource.data.venueType is string)
        && (!('averageRating' in request.resource.data) || request.resource.data.averageRating is number)
        && (!('totalRatings' in request.resource.data) || request.resource.data.totalRatings is int);
      allow delete: if false;

      match /meta/{docId} {
        // Allow public read for venue stats
        allow get: if docId == 'stats';
        allow list: if false;
        allow create, update, delete: if false;
      }

      // Crowdsourced line length reports
      match /line_reports/{reportId} {
        // Public read; any authenticated user may report (client throttles frequency)
        allow get: if true;
        allow list: if true;
        allow create: if isAuthenticated()
          && request.resource.data.keys().hasOnly(['user_id','line','timestamp'])
          && request.resource.data.user_id == request.auth.uid
          && request.resource.data.line in ['short','medium','long']
          && request.resource.data.timestamp is timestamp;
        allow update, delete: if false;
      }
    }

    // ===== CHECK-INS =====
    match /checkIns/{checkInId} {
      // Only allow verified users to read check-ins
      allow read: if hasValidEmail();
      allow list: if hasValidEmail();
      allow create: if isApprovedUser()
        && request.resource.data.keys().hasOnly([
          'userId', 'userName', 'venueId', 'venueName', 'checkedInAt',
          'latitude', 'longitude', 'isActive', 'isValid'
        ])
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.userId is string
        && request.resource.data.userName is string
        && request.resource.data.venueId is string
        && request.resource.data.venueName is string
        && request.resource.data.checkedInAt is timestamp
        && request.resource.data.latitude is number
        && request.resource.data.longitude is number
        && (!('isActive' in request.resource.data) || request.resource.data.isActive is bool)
        && (!('isValid' in request.resource.data) || request.resource.data.isValid is bool);
      // Only allow changing the active/valid/checkedOutAt fields; everything
      // else must remain identical to the existing document. We use diff() so
      // merges or full updates still satisfy the constraint.
      allow update: if isApprovedUser()
        && resource.data.userId == request.auth.uid
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(['isActive', 'isValid', 'checkedOutAt'])
        && (!('isActive' in request.resource.data) || request.resource.data.isActive is bool)
        && (!('isValid' in request.resource.data) || request.resource.data.isValid is bool)
        && (!('checkedOutAt' in request.resource.data) || request.resource.data.checkedOutAt is timestamp);
      allow delete: if isApprovedUser() && resource.data.userId == request.auth.uid;
    }

    // ===== PLAN TO GO =====
    match /planToGo/{planId} {
      // Only allow verified users to read plan to go
      allow read: if hasValidEmail();
      allow list: if hasValidEmail();
      allow create: if isApprovedUser()
        && request.resource.data.keys().hasOnly([
          'userId', 'userName', 'venueId', 'venueName', 'plannedAt'
        ])
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.userId is string
        && request.resource.data.userName is string
        && request.resource.data.venueId is string
        && request.resource.data.venueName is string
        && request.resource.data.plannedAt is timestamp;
      allow update: if isApprovedUser() && resource.data.userId == request.auth.uid;
      allow delete: if isApprovedUser() && resource.data.userId == request.auth.uid;
    }

    // ===== VENUE RATINGS =====
    match /venueRatings/{ratingId} {
      allow read: if hasValidEmail();
      allow list: if hasValidEmail();
      // Create a rating for self; only allowed fields
      allow create: if isApprovedUser()
        && request.resource.data.keys().hasOnly(['userId','venueId','rating','ratedAt'])
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.venueId is string
        && request.resource.data.rating is number
        && request.resource.data.rating >= 1 && request.resource.data.rating <= 5
        && request.resource.data.ratedAt is timestamp;
      // Update only the rating value/timestamp for self
      allow update: if isApprovedUser()
        && resource.data.userId == request.auth.uid
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(['rating','ratedAt'])
        && request.resource.data.rating is number
        && request.resource.data.rating >= 1 && request.resource.data.rating <= 5
        && request.resource.data.ratedAt is timestamp;
      allow delete: if isApprovedUser() && resource.data.userId == request.auth.uid;
    }

    // ===== TICKETS (server-managed) =====
    match /tickets/{ticketId} {
      // Per-doc read rules: purchaser or event host (auth required; no email verification needed)
      allow get: if isAuthenticated() && (
        resource.data.purchaserId == request.auth.uid ||
        (resource.data.eventId is string &&
          get(/databases/$(database)/documents/events/$(resource.data.eventId)).data.hostUserId == request.auth.uid)
      );
      // Allow queries for authenticated users; per-doc get above filters results
      allow list: if isAuthenticated();
      // Only server creates/updates/deletes
      allow create, update, delete: if false;
    }

    // ===== EVENTS (unchanged) =====
    match /events/{eventId} {
      allow read: if hasValidEmail();
      allow create: if isApprovedUser()
        && request.resource.data.keys().hasAll([
          'hostUserId', 'hostName', 'title', 'description', 'startsAt',
          'address', 'eventType', 'sellingTickets', 'createdAt', 'updatedAt'
        ])
        && request.resource.data.hostUserId == request.auth.uid
        && request.resource.data.title is string
        && request.resource.data.title.size() > 0
        && request.resource.data.title.size() <= 100
        && request.resource.data.description is string
        && request.resource.data.description.size() <= 1000
        && request.resource.data.address is string
        && request.resource.data.address.size() > 0
        && request.resource.data.eventType in ['greek', 'house', 'bar', 'club', 'other']
        && request.resource.data.startsAt is timestamp
        && request.resource.data.startsAt > request.time
        && request.resource.data.sellingTickets is bool
        && (!request.resource.data.sellingTickets || (
          request.resource.data.ticketPriceCents is int
          && request.resource.data.ticketPriceCents >= 0
          && request.resource.data.ticketQuantityTotal is int
          && request.resource.data.ticketQuantityTotal > 0
        ));
      // Host may update their event (original path)
      allow update: if isApprovedUser()
        && resource.data.hostUserId == request.auth.uid
        && request.resource.data.hostUserId == resource.data.hostUserId
        && (!('createdAt' in resource.data) || request.resource.data.createdAt == resource.data.createdAt);

      // Allow approved users to update rating summary fields only
      allow update: if isApprovedUser()
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(['ratingAverage','ratingCount']);
      allow delete: if false;
      
    }

    // ===== ORG VERIFICATIONS =====
    match /org_verifications/{verificationId} {
      // Owner can read their own doc (verified); admins can read/list all
      allow get: if isAdmin() || (hasValidEmail() && resource.data.user_id == request.auth.uid);
      allow list: if isAdmin();

      // Create by approved user for themselves; status must be 'pending'
      allow create: if isApprovedUser()
        && request.resource.data.keys().hasOnly(['user_id','organization_name','proof_url','status','created_at'])
        && request.resource.data.user_id == request.auth.uid
        && request.resource.data.organization_name is string
        && request.resource.data.organization_name.size() > 0
        && request.resource.data.proof_url is string
        && request.resource.data.status == 'pending'
        && request.resource.data.created_at is timestamp;

      // Admin can update status (approve/deny). Only 'status' and 'updated_at' may change
      allow update: if isAdmin()
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(['status','updated_at'])
        && request.resource.data.status in ['pending','approved','denied']
        && request.resource.data.updated_at is timestamp;

      // No deletes from clients
      allow delete: if false;
    }

    // ===== Nightlife overrides (public read; server/admin write only) =====
    match /nightlife/overrides {
      allow get: if true;
      allow list, create, update, delete: if false;
    }

    // ===== Nightlife scores (public read; server writes via admin SDK) =====
    match /nightlife/scores {
      allow get: if true;
      allow list, create, update, delete: if false;

      match /byVenue/{venueId} {
        allow get: if true;
        allow list, create, update, delete: if false;
      }

      match /meta/{docId} {
        allow get: if true;
        allow list, create, update, delete: if false;
      }
    }

    // ===== EVENT RATINGS =====
    match /eventRatings/{ratingId} {
      // Read/list allowed for signed-in JMU users
      allow get, list: if hasValidEmail();

      // Create new rating by approved user for self
      allow create: if isApprovedUser()
        && request.resource.data.keys().hasOnly([
          'eventId','userId','userName','userAvatarURL','rating','review','createdAt','updatedAt','helpfulCount'
        ])
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.eventId is string
        && request.resource.data.rating is number
        && request.resource.data.rating >= 1 && request.resource.data.rating <= 5
        && (!('review' in request.resource.data) || request.resource.data.review is string || request.resource.data.review == null)
        && request.resource.data.createdAt is timestamp
        && request.resource.data.updatedAt is timestamp
        && request.resource.data.helpfulCount is int;

      // Owner may update their rating value/review
      allow update: if isApprovedUser()
        && request.auth.uid == resource.data.userId
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(['rating','review','updatedAt'])
        && request.resource.data.rating is number
        && request.resource.data.rating >= 1 && request.resource.data.rating <= 5
        && (!('review' in request.resource.data) || request.resource.data.review is string || request.resource.data.review == null)
        && request.resource.data.updatedAt is timestamp;

      allow delete: if false;
    }

    // ===== ACTIVE USERS (location tracking for busyness) =====
    match /activeUsers/{userId} {
      // Users can only write their own location
      allow write: if request.auth != null && request.auth.uid == userId;

      // No one can read individual locations (privacy)
      allow read: if false;
    }

    // ===== VENUE ACTIVITY (cached busyness levels) =====
    match /venueActivity/{placeId} {
      // Anyone can read cached busyness levels
      allow read: if true;

      // Only backend can write
      allow write: if false;
    }

    // ===== Default deny =====
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
