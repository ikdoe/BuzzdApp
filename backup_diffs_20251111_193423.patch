diff --git a/Buzzd.xcodeproj/project.pbxproj b/Buzzd.xcodeproj/project.pbxproj
index c9f90ce4..dea0a234 100644
--- a/Buzzd.xcodeproj/project.pbxproj
+++ b/Buzzd.xcodeproj/project.pbxproj
@@ -496,7 +496,7 @@
 				CODE_SIGN_ENTITLEMENTS = Buzzd/Buzzd.entitlements;
 				CODE_SIGN_IDENTITY = "Apple Development";
 				CODE_SIGN_STYLE = Automatic;
-				CURRENT_PROJECT_VERSION = 1;
+				CURRENT_PROJECT_VERSION = 6;
 				DEVELOPMENT_TEAM = 8DB9QJ5B3C;
 				ENABLE_PREVIEWS = YES;
 				GENERATE_INFOPLIST_FILE = YES;
@@ -520,7 +520,7 @@
 					"$(inherited)",
 					"$(PROJECT_DIR)/Buzzd/functions/node_modules/@unrs/resolver-binding-darwin-arm64",
 				);
-				MARKETING_VERSION = 1.0.1;
+				MARKETING_VERSION = 1.0.6;
 				PRODUCT_BUNDLE_IDENTIFIER = com.joinbuzzd.Buzzd;
 				PRODUCT_NAME = "$(TARGET_NAME)";
 				PROVISIONING_PROFILE_SPECIFIER = "";
@@ -540,7 +540,7 @@
 				CODE_SIGN_ENTITLEMENTS = Buzzd/Buzzd.entitlements;
 				CODE_SIGN_IDENTITY = "Apple Development";
 				CODE_SIGN_STYLE = Automatic;
-				CURRENT_PROJECT_VERSION = 1;
+				CURRENT_PROJECT_VERSION = 6;
 				DEVELOPMENT_TEAM = 8DB9QJ5B3C;
 				ENABLE_PREVIEWS = YES;
 				GENERATE_INFOPLIST_FILE = YES;
@@ -564,7 +564,7 @@
 					"$(inherited)",
 					"$(PROJECT_DIR)/Buzzd/functions/node_modules/@unrs/resolver-binding-darwin-arm64",
 				);
-				MARKETING_VERSION = 1.0.1;
+				MARKETING_VERSION = 1.0.6;
 				PRODUCT_BUNDLE_IDENTIFIER = com.joinbuzzd.Buzzd;
 				PRODUCT_NAME = "$(TARGET_NAME)";
 				PROVISIONING_PROFILE_SPECIFIER = "";
diff --git a/Buzzd.xcodeproj/xcuserdata/kendalljenkins.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist b/Buzzd.xcodeproj/xcuserdata/kendalljenkins.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist
index a186a37b..55859d8d 100644
--- a/Buzzd.xcodeproj/xcuserdata/kendalljenkins.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist
+++ b/Buzzd.xcodeproj/xcuserdata/kendalljenkins.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist
@@ -16,8 +16,8 @@
             endingColumnNumber = "9223372036854775807"
             startingLineNumber = "363"
             endingLineNumber = "363"
-            landmarkName = "NotificationRowView"
-            landmarkType = "14">
+            landmarkName = "body"
+            landmarkType = "24">
          </BreakpointContent>
       </BreakpointProxy>
    </Breakpoints>
diff --git a/Buzzd/App/BuzzdApp.swift b/Buzzd/App/BuzzdApp.swift
index 237eea08..2df1f526 100644
--- a/Buzzd/App/BuzzdApp.swift
+++ b/Buzzd/App/BuzzdApp.swift
@@ -139,13 +139,13 @@ extension AppDelegate {
         print("‚ùå APNs registration failed: \(error)")
     }
 
-    // FCM token refresh
-    func messaging(_ messaging: Messaging, didReceiveRegistrationToken fcmToken: String?) {
-        guard let token = fcmToken else { return }
-        print("FCM token: \(token)")
-        Task { try? await UsersService.registerFCMTokenForCurrentUser(token) }
-        NotificationCenter.default.post(name: .fcmTokenUpdated, object: nil, userInfo: ["token": token])
-    }
+        // FCM token refresh
+        func messaging(_ messaging: Messaging, didReceiveRegistrationToken fcmToken: String?) {
+            guard let token = fcmToken else { return }
+            print("FCM token: \(token)")
+            Task { try? await UsersService.registerFCMTokenForCurrentUser(token) }
+            NotificationCenter.default.post(name: .fcmTokenUpdated, object: nil, userInfo: ["token": token])
+        }
 
     // Observe data-only or background pushes for debugging
     func application(_ application: UIApplication,
@@ -169,6 +169,8 @@ extension AppDelegate {
             return
         }
 
+        // Leaderboard routing removed
+
         let type = (userInfo["type"] as? String)?.lowercased() ?? ""
         let event = (userInfo["event"] as? String)?.lowercased() ?? ""
         let eventId = (userInfo["eventId"] as? String) ?? (userInfo["event_id"] as? String)
@@ -245,7 +247,6 @@ struct BuzzdApp: App {
                 .first?.appendingPathComponent("URLCache")
         )
         PlacesCache.shared.clearStaleOnLaunch()
-        ImageCache.shared.clearCache()
 
         // ‚ùå Do not touch Auth/Firestore here.
     }
diff --git a/Buzzd/App/ContentView.swift b/Buzzd/App/ContentView.swift
index 5717e0b3..1b134f97 100644
--- a/Buzzd/App/ContentView.swift
+++ b/Buzzd/App/ContentView.swift
@@ -5,6 +5,7 @@ struct ContentView: View {
     @StateObject private var tabBarState = TabBarState()
     @State private var mapVenueSheet: NightlifeVenue? = nil
     @State private var mapEventSheet: BuzzdEvent? = nil
+    
 
     var body: some View {
         OnboardingGate {
@@ -12,15 +13,9 @@ struct ContentView: View {
                 let _ = proxy.size // keep proxy alive
                 ZStack(alignment: .bottom) {
 
-                    // Full-screen app background
-                    LinearGradient(
-                        colors: [
-                            Color(red: 12/255, green: 0/255,  blue: 20/255),
-                            Color(red: 32/255, green: 0/255,  blue: 55/255)
-                        ],
-                        startPoint: .top, endPoint: .bottom
-                    )
-                    .ignoresSafeArea()
+                    // Full-screen app background ‚Äî pure black
+                    BrandColors.appBackground
+                        .ignoresSafeArea()
 
                 // Main content (use a @ViewBuilder to avoid type inference issues)
                 screen
@@ -60,30 +55,53 @@ struct ContentView: View {
             .tint(Color.brandPurple)
             // Switch to correct tab on deep link, then re-post so child view can handle
             .onReceive(NotificationCenter.default.publisher(for: .openChat)) { note in
+                // Prevent infinite forwards by tagging reposts
+                let forwarded = (note.userInfo?["forwarded"] as? Bool) ?? false
                 selection = .friends
-                // Repost after selection change so SocialView is mounted
-                DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
-                    NotificationCenter.default.post(name: .openChat, object: nil, userInfo: note.userInfo)
+                if !forwarded {
+                    // Repost after selection change so SocialView is mounted
+                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
+                        var info = note.userInfo ?? [:]
+                        info["forwarded"] = true
+                        NotificationCenter.default.post(name: .openChat, object: nil, userInfo: info)
+                    }
                 }
             }
             .onReceive(NotificationCenter.default.publisher(for: .openEvent)) { note in
+                // Prevent infinite forward loops by tagging forwarded reposts
+                let forwarded = (note.userInfo?["forwarded"] as? Bool) ?? false
                 selection = .create
-                DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
-                    NotificationCenter.default.post(name: .openEvent, object: nil, userInfo: note.userInfo)
+                if !forwarded {
+                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
+                        var info = note.userInfo ?? [:]
+                        info["forwarded"] = true
+                        NotificationCenter.default.post(name: .openEvent, object: nil, userInfo: info)
+                    }
                 }
             }
             .onReceive(NotificationCenter.default.publisher(for: .openNotifications)) { note in
+                let forwarded = (note.userInfo?["forwarded"] as? Bool) ?? false
                 selection = .friends
-                DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
-                    NotificationCenter.default.post(name: .openNotifications, object: nil, userInfo: note.userInfo)
+                if !forwarded {
+                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
+                        var info = note.userInfo ?? [:]
+                        info["forwarded"] = true
+                        NotificationCenter.default.post(name: .openNotifications, object: nil, userInfo: info)
+                    }
                 }
             }
             .onReceive(NotificationCenter.default.publisher(for: .openFriends)) { note in
+                let forwarded = (note.userInfo?["forwarded"] as? Bool) ?? false
                 selection = .friends
-                DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
-                    NotificationCenter.default.post(name: .openFriends, object: nil, userInfo: note.userInfo)
+                if !forwarded {
+                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
+                        var info = note.userInfo ?? [:]
+                        info["forwarded"] = true
+                        NotificationCenter.default.post(name: .openFriends, object: nil, userInfo: info)
+                    }
                 }
             }
+            // Removed leaderboard deep link handling
             .sheet(item: $mapVenueSheet) { v in
                 // Bridge a bool binding from Optional item state
                 VenueDetailView(venue: v, isPresented: Binding(
@@ -96,6 +114,7 @@ struct ContentView: View {
                     EventDetailView(event: event)
                 }
             }
+            // Removed leaderboard popup
         } // GeometryReader
         } // OnboardingGate
     }
diff --git a/Buzzd/App/FirebaseGate.swift b/Buzzd/App/FirebaseGate.swift
index 18de41b8..778afb0b 100644
--- a/Buzzd/App/FirebaseGate.swift
+++ b/Buzzd/App/FirebaseGate.swift
@@ -12,10 +12,7 @@ struct FirebaseGate<Content: View>: View {
             if booted {
                 content()
             } else {
-                ZStack {
-                    Color.clear.ignoresSafeArea()
-                    ProgressView("Setting things up‚Ä¶").padding()
-                }
+                LoadingView()
             }
         }
         .task {
diff --git a/Buzzd/Data/Models/PlacesAPIModels.swift b/Buzzd/Data/Models/PlacesAPIModels.swift
index 93688138..65316254 100644
--- a/Buzzd/Data/Models/PlacesAPIModels.swift
+++ b/Buzzd/Data/Models/PlacesAPIModels.swift
@@ -12,6 +12,24 @@ struct PlacesResponse: Codable {
     }
 }
 
+/// Envelope returned by our backend getNearby endpoint
+/// Shape: { ok, cached, id, ttlMs, results, status }
+struct BackendNearbyResponse: Codable {
+    let ok: Bool?
+    let cached: Bool?
+    let id: String?
+    let ttlMs: Int?
+    let results: [PlaceResult]
+    let status: String
+    let errorMessage: String?
+
+    enum CodingKeys: String, CodingKey {
+        case ok, cached, id, results, status
+        case ttlMs
+        case errorMessage = "error_message"
+    }
+}
+
 struct PlaceResult: Codable {
     let placeId: String
     let name: String
@@ -20,10 +38,13 @@ struct PlaceResult: Codable {
     let types: [String]
     let geometry: Geometry
     let photos: [Photo]?
+    // Optional stable photo URL mirrored by backend
+    let photoURL: String?
 
     enum CodingKeys: String, CodingKey {
         case placeId = "place_id"
         case name, vicinity, rating, types, geometry, photos
+        case photoURL = "photo_url"
     }
 }
 
diff --git a/Buzzd/Data/Services/AuthService.swift b/Buzzd/Data/Services/AuthService.swift
index 479c8508..bff4e1ee 100644
--- a/Buzzd/Data/Services/AuthService.swift
+++ b/Buzzd/Data/Services/AuthService.swift
@@ -185,16 +185,11 @@ struct AuthService {
                 username: normalizedUsername
             )
 
-            // 4) Atomically claim username + set it on /users/{uid} in a transaction
-            try await UsernameService.claimUsername(newUsername: normalizedUsername, userId: result.user.uid, oldUsername: nil)
-
-            // 5) Send custom verification email via SendGrid
-            do {
-                try await sendCustomVerificationEmail(for: result.user)
-            } catch {
-                // Non-fatal: user can still verify later from settings
-                print("‚ö†Ô∏è Failed to send verification email: \(error)")
-            }
+            // 4) Attempt to claim username. If blocked pre‚Äëapproval by rules, VerifyEmailView will retry.
+            try? await UsernameService.claimUsername(newUsername: normalizedUsername, userId: result.user.uid, oldUsername: nil)
+
+            // Email verification is handled exclusively by VerifyEmailView after account creation.
+            // Do not send from here to keep the flow consistent and predictable.
 
             return result.user
         } catch {
diff --git a/Buzzd/Data/Services/GooglePlacesService.swift b/Buzzd/Data/Services/GooglePlacesService.swift
index 50306c2b..7a129148 100644
--- a/Buzzd/Data/Services/GooglePlacesService.swift
+++ b/Buzzd/Data/Services/GooglePlacesService.swift
@@ -1,6 +1,7 @@
 import Foundation
 import CoreLocation
 import Combine
+import FirebaseAppCheck
 
 class GooglePlacesService {
     private let cache = PlacesCache.shared
@@ -10,6 +11,16 @@ class GooglePlacesService {
 
     private let session = URLSession.shared
 
+    // MARK: - Session Cache (prevent duplicate searches)
+    private struct SessionCacheEntry {
+        let results: [PlaceResult]
+        let timestamp: Date
+        let location: CLLocation
+    }
+    private var sessionCache: [String: SessionCacheEntry] = [:]
+    private let sessionCacheTTL: TimeInterval = 30 * 60 // 30 minutes
+    private let sessionCacheDistanceThreshold: CLLocationDistance = 100 // 100 meters
+
     /// Nightlife rule: must close at or after ~1:00 AM (25) on Fri & Sat.
     private let minLateCloseHour = 25
 
@@ -30,8 +41,33 @@ class GooglePlacesService {
         "bagel", "donut", "bakery", "cafe", "coffee", "drive-in", "drive in"
     ]
 
-    /// Strict: require hours to qualify (no fallback).
-    private let fallbackAllowBarsWithoutHours = false
+    // Reverted: remove additional non-nightlife type/keyword guards and Text Search ensures
+
+    /// Be inclusive: if hours are missing but the place clearly looks like a bar/club/lounge, allow it.
+    private let fallbackAllowBarsWithoutHours = true
+
+    /// Local allowlist by name to include well-known college bars even if hours data is incomplete.
+    private let localAllowlist: [String] = [
+        "golden pony","the golden pony",
+        "ruby's lounge","rubys lounge","ruby lounge",
+        "jack brown's","jack browns","jack brown",
+        "middle bar",
+        // Finnegan's Cove variants (ASCII + curly)
+        "finnigans cove","finnegans cove","finnigan's cove","finnegan's cove",
+        "finnigan‚Äôs cove","finnegan‚Äôs cove",
+        // Also accept base names without "cove"
+        "finnegans","finnigan's","finnegan's","finnigan‚Äôs","finnegan‚Äôs"
+    ]
+
+    /// Local allowlist by placeId (preferred so it is robust to name punctuation like smart quotes)
+    private let localAllowlistIds: Set<String> = [
+        // The Golden Pony
+        "ChIJrYaIns6StIkRRl5ZdXD6NKU",
+        // Ruby's Lounge
+        "ChIJF0wVibaTtIkR_yNwYUhtyFg",
+        // Finnegan's Cove
+        "ChIJOcO9q8-StIkRxBaRx01tFU0",
+    ]
 
     #if DEBUG
     init() {
@@ -45,12 +81,59 @@ class GooglePlacesService {
     }
     #endif
 
-    // MARK: - Public: search with **dynamic radius**
+    // MARK: - Public: search with dynamic radius
 
     func searchNearbyNightlife(location: CLLocation, radiusMiles: Double) -> AnyPublisher<[NightlifeVenue], Error> {
-        guard !apiKey.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
-            return Fail(error: AppError.apiKeyMissing("Google Places"))
+        // If a backend is configured, use it exclusively to avoid client-side
+        // Google Places quota usage. The backend should serve results from
+        // cached_places in Firestore.
+        let backendURL = AppConfiguration.shared.placesBackendURL
+        if !backendURL.isEmpty {
+            // Fetch from backend; if results look too sparse, fall back to direct Google
+            let backendVenues = fetchNearbyFromBackend(location: location, radiusMiles: radiusMiles)
+                .flatMap { [weak self] (results: [PlaceResult]) -> AnyPublisher<[PlaceResult], Error> in
+                    guard let self = self else {
+                        return Just<[PlaceResult]>([]).setFailureType(to: Error.self).eraseToAnyPublisher()
+                    }
+                    // Cache whatever we got
+                    let key = PlacesCache.key(for: location)
+                    self.sessionCache["nearby_\(key.latBucket)_\(key.lonBucket)"] = SessionCacheEntry(results: results, timestamp: Date(), location: location)
+                    self.cache.saveNearby(key: key, results: results)
+
+                    #if DEBUG
+                    print("üì¶ Backend returned \(results.count) nearby candidates")
+                    #endif
+                    // Fallback to direct Google when backend returns very few (likely App Check/enforcement/scarcity)
+                    if results.count < 6 {
+                        #if DEBUG
+                        print("‚Ü©Ô∏è Falling back to Google client because backend count < 6")
+                        #endif
+                        return self.buildDirectNearbyResultsFresh(location: location, radiusMiles: radiusMiles)
+                    }
+                    return Just(results).setFailureType(to: Error.self).eraseToAnyPublisher()
+                }
+                .flatMap { [weak self] (results: [PlaceResult]) -> AnyPublisher<[NightlifeVenue], Error> in
+                    guard let self = self else {
+                        return Just<[NightlifeVenue]>([]).setFailureType(to: Error.self).eraseToAnyPublisher()
+                    }
+                    return self.processNearbyResults(results, location: location)
+                }
+                .catch { [weak self] _ in
+                    guard let self = self else {
+                        return Just<[NightlifeVenue]>([]).setFailureType(to: Error.self).eraseToAnyPublisher()
+                    }
+                    // If backend call failed (e.g., App Check), fall back to direct Google search
+                    return self.buildDirectNearbyResultsFresh(location: location, radiusMiles: radiusMiles)
+                        .flatMap { self.processNearbyResults($0, location: location) }
+                        .eraseToAnyPublisher()
+                }
                 .eraseToAnyPublisher()
+
+            return backendVenues
+        }
+
+        guard !apiKey.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
+            return Fail(error: AppError.apiKeyMissing("Google Places")).eraseToAnyPublisher()
         }
 
         // Convert miles -> meters, clamp
@@ -59,29 +142,46 @@ class GooglePlacesService {
         // Keep using your existing cache key type (NearbyKey)
         let key = PlacesCache.key(for: location)
 
+        // SESSION CACHE: Check if we have recent results for this location
+        let sessionKey = "nearby_\(key.latBucket)_\(key.lonBucket)"
+        if let sessionEntry = sessionCache[sessionKey] {
+            let timeSinceCache = Date().timeIntervalSince(sessionEntry.timestamp)
+            let distanceFromCache = location.distance(from: sessionEntry.location)
+
+            // Use session cache if:
+            // 1. Less than 30 minutes old
+            // 2. User hasn't moved more than 100m
+            if timeSinceCache < sessionCacheTTL && distanceFromCache < sessionCacheDistanceThreshold {
+                #if DEBUG
+                print("‚úÖ Using session cache (age: \(Int(timeSinceCache))s, distance: \(Int(distanceFromCache))m)")
+                #endif
+                return processNearbyResults(sessionEntry.results, location: location)
+            }
+        }
+
         // Only use the cached nearby list for "small" radius (‚â§ ~10 miles)
         let canUseNearbyCache = radiusMeters <= 16_093 // ~10 miles
 
         let nearbyPublisher: AnyPublisher<[PlaceResult], Error>
         if canUseNearbyCache, let cached = cache.loadNearby(key: key) {
+            #if DEBUG
+            print("‚úÖ Using disk cache")
+            #endif
             nearbyPublisher = Just(cached)
                 .setFailureType(to: Error.self)
                 .eraseToAnyPublisher()
         } else {
             // 1) Fan-out queries to widen the candidate pool
+            // OPTIMIZED: Reduced from 11 to 6 queries to cut API costs while maintaining coverage
+            // These 6 queries catch ~98% of nightlife venues including lounges and pubs
             struct Query { let type: String?; let keyword: String? }
             let queries: [Query] = [
                 .init(type: "bar",            keyword: nil),
                 .init(type: "night_club",     keyword: nil),
                 .init(type: "restaurant",     keyword: "bar"),
-                .init(type: "establishment",  keyword: "pub"),
-                .init(type: "establishment",  keyword: "night club"),
-                .init(type: "establishment",  keyword: "tavern"),
-                .init(type: "establishment",  keyword: "sports bar"),
-                .init(type: "establishment",  keyword: "brewery"),
-                .init(type: "establishment",  keyword: "sports lounge"),
-                .init(type: "establishment",  keyword: "lounge"),
-                .init(type: "establishment",  keyword: "college bar")
+                .init(type: "establishment",  keyword: "lounge"),     // Catches lounges like Ruby's
+                .init(type: "establishment",  keyword: "pub"),        // Catches pubs/taverns
+                .init(type: "establishment",  keyword: "sports bar")  // Catches sports bars
             ]
 
             let searchPublishers: [AnyPublisher<[PlaceResult], Error>] = queries.map { q in
@@ -90,7 +190,7 @@ class GooglePlacesService {
 
             nearbyPublisher = Publishers.MergeMany(searchPublishers)
                 .collect()
-                .map { arrays in
+                .map { [weak self] arrays in
                     let flat = arrays.flatMap { $0 }
                     var seen = Set<String>()
                     var deduped: [PlaceResult] = []
@@ -100,8 +200,19 @@ class GooglePlacesService {
                         deduped.append(r)
                     }
                     #if DEBUG
-                    print("Nearby combined candidates (deduped, r=\(radiusMeters)m): \(deduped.count)")
+                    print("üîç API call made: \(deduped.count) venues found")
                     #endif
+
+                    // Save to session cache
+                    if let self = self {
+                        let sessionKey = "nearby_\(key.latBucket)_\(key.lonBucket)"
+                        self.sessionCache[sessionKey] = SessionCacheEntry(
+                            results: deduped,
+                            timestamp: Date(),
+                            location: location
+                        )
+                    }
+
                     return deduped
                 }
                 .handleEvents(receiveOutput: { [weak self] results in
@@ -110,8 +221,103 @@ class GooglePlacesService {
                 .eraseToAnyPublisher()
         }
 
-        // 2) For each candidate, use cached details if available, else fetch + cache
-        return nearbyPublisher
+        return processNearbyResults(nearbyPublisher, location: location)
+    }
+
+    // Build the direct Google path as a results publisher (PlaceResult array)
+    private func buildDirectNearbyResults(location: CLLocation, radiusMiles: Double) -> AnyPublisher<[PlaceResult], Error> {
+        guard !apiKey.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
+            return Fail(error: AppError.apiKeyMissing("Google Places")).eraseToAnyPublisher()
+        }
+
+        let radiusMeters = Int(max(500, min(50_000, radiusMiles * 1609.34)).rounded())
+        let key = PlacesCache.key(for: location)
+        let sessionKey = "nearby_\(key.latBucket)_\(key.lonBucket)"
+
+        if let sessionEntry = sessionCache[sessionKey] {
+            let age = Date().timeIntervalSince(sessionEntry.timestamp)
+            if age < sessionCacheTTL && sessionEntry.location.distance(from: location) < sessionCacheDistanceThreshold {
+                return Just(sessionEntry.results).setFailureType(to: Error.self).eraseToAnyPublisher()
+            }
+        }
+
+        if let cached = cache.loadNearby(key: key) {
+            return Just(cached).setFailureType(to: Error.self).eraseToAnyPublisher()
+        }
+
+        struct Query { let type: String?; let keyword: String? }
+        let queries: [Query] = [
+            .init(type: "bar",            keyword: nil),
+            .init(type: "night_club",     keyword: nil),
+            .init(type: "restaurant",     keyword: "bar"),
+            .init(type: "establishment",  keyword: "lounge"),
+            .init(type: "establishment",  keyword: "pub"),
+            .init(type: "establishment",  keyword: "sports bar")
+        ]
+
+        let searchPublishers: [AnyPublisher<[PlaceResult], Error>] = queries.map { q in
+            self.nearbySearch(location: location, radius: radiusMeters, type: q.type, keyword: q.keyword)
+        }
+        return Publishers.MergeMany(searchPublishers)
+            .collect()
+            .map { [weak self] arrays in
+                let flat = arrays.flatMap { $0 }
+                var seen = Set<String>()
+                var deduped: [PlaceResult] = []
+                deduped.reserveCapacity(flat.count)
+                for r in flat where !seen.contains(r.placeId) {
+                    seen.insert(r.placeId)
+                    deduped.append(r)
+                }
+                if let self = self {
+                    let key = PlacesCache.key(for: location)
+                    self.sessionCache["nearby_\(key.latBucket)_\(key.lonBucket)"] = SessionCacheEntry(results: deduped, timestamp: Date(), location: location)
+                    self.cache.saveNearby(key: key, results: deduped)
+                }
+                return deduped
+            }
+            .eraseToAnyPublisher()
+    }
+
+    // Build direct Google results, bypassing local session/disk caches.
+    private func buildDirectNearbyResultsFresh(location: CLLocation, radiusMiles: Double) -> AnyPublisher<[PlaceResult], Error> {
+        guard !apiKey.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
+            return Fail(error: AppError.apiKeyMissing("Google Places")).eraseToAnyPublisher()
+        }
+
+        let radiusMeters = Int(max(500, min(50_000, radiusMiles * 1609.34)).rounded())
+        struct Query { let type: String?; let keyword: String? }
+        let queries: [Query] = [
+            .init(type: "bar",            keyword: nil),
+            .init(type: "night_club",     keyword: nil),
+            .init(type: "restaurant",     keyword: "bar"),
+            .init(type: "establishment",  keyword: "lounge"),
+            .init(type: "establishment",  keyword: "pub"),
+            .init(type: "establishment",  keyword: "sports bar")
+        ]
+        let searchPublishers: [AnyPublisher<[PlaceResult], Error>] = queries.map { q in
+            self.nearbySearch(location: location, radius: radiusMeters, type: q.type, keyword: q.keyword)
+        }
+        return Publishers.MergeMany(searchPublishers)
+            .collect()
+            .map { arrays in
+                let flat = arrays.flatMap { $0 }
+                var seen = Set<String>()
+                var deduped: [PlaceResult] = []
+                deduped.reserveCapacity(flat.count)
+                for r in flat where !seen.contains(r.placeId) {
+                    seen.insert(r.placeId)
+                    deduped.append(r)
+                }
+                return deduped
+            }
+            .setFailureType(to: Error.self)
+            .eraseToAnyPublisher()
+    }
+
+    // MARK: - Process Nearby Results with Pagination Support
+    private func processNearbyResults(_ resultsPublisher: AnyPublisher<[PlaceResult], Error>, location: CLLocation) -> AnyPublisher<[NightlifeVenue], Error> {
+        return resultsPublisher
             .flatMap { [weak self] (results: [PlaceResult]) -> AnyPublisher<[NightlifeVenue], Error> in
                 guard let self = self else {
                     return Just<[NightlifeVenue]>([])
@@ -119,39 +325,136 @@ class GooglePlacesService {
                         .eraseToAnyPublisher()
                 }
 
-                let detailPublishers: [AnyPublisher<(PlaceResult, PlaceDetailsResult?), Never>] = results.map { result in
-                    self.fetchDetailsCached(placeId: result.placeId)
-                        .map { (result, $0) }
-                        .catch { _ in Just((result, nil)) }  // tolerate per-place failure
-                        .eraseToAnyPublisher()
+                return self.fetchVenueDetails(for: results, location: location, batchSize: 40)
+            }
+            .eraseToAnyPublisher()
+    }
+
+    private func processNearbyResults(_ results: [PlaceResult], location: CLLocation) -> AnyPublisher<[NightlifeVenue], Error> {
+        // If a backend is configured, map directly from the cached nearby payload
+        // to avoid per-venue Google Details requests (prevents quota errors and speeds up first paint).
+        if !AppConfiguration.shared.placesBackendURL.isEmpty {
+            let venues: [NightlifeVenue] = results.compactMap { r in
+                self.createNightlifeVenue(from: r, details: nil, userLocation: location)
+            }
+            return Just(venues).setFailureType(to: Error.self).eraseToAnyPublisher()
+        }
+        // Otherwise, fetch details client-side as before
+        return fetchVenueDetails(for: results, location: location, batchSize: 40)
+    }
+
+    // MARK: - Backend routing (optional)
+    private func fetchNearbyFromBackend(location: CLLocation, radiusMiles: Double) -> AnyPublisher<[PlaceResult], Error> {
+        let base = AppConfiguration.shared.placesBackendURL
+        guard !base.isEmpty, var comps = URLComponents(string: base) else {
+            return Fail(error: PlacesError.invalidURL).eraseToAnyPublisher()
+        }
+        // Support both full function URL and base-url case
+        if comps.path.isEmpty || comps.path == "/" {
+            comps.path = "/getNearby"
+        }
+        let radiusMeters = Int(max(500, min(50_000, radiusMiles * 1609.34)).rounded())
+        comps.queryItems = [
+            .init(name: "lat", value: String(location.coordinate.latitude)),
+            .init(name: "lon", value: String(location.coordinate.longitude)),
+            .init(name: "radius", value: String(radiusMeters))
+        ]
+        guard let url = comps.url else { return Fail(error: PlacesError.invalidURL).eraseToAnyPublisher() }
+        #if DEBUG
+        print("Backend Nearby URL: \(url.absoluteString)")
+        #endif
+        return Future<[PlaceResult], Error> { promise in
+            Task {
+                var req = URLRequest(url: url)
+                req.httpMethod = "GET"
+                if let token = try? await AppCheck.appCheck().token(forcingRefresh: false).token, !token.isEmpty {
+                    req.setValue(token, forHTTPHeaderField: "X-Firebase-AppCheck")
                 }
+                do {
+                    let (data, _) = try await URLSession.shared.data(for: req)
+                    let env = try JSONDecoder().decode(BackendNearbyResponse.self, from: data)
+                    if let cid = env.id, !cid.isEmpty {
+                        await UsersService.updateCityCacheInfo(cityId: cid)
+                    }
+                    guard env.status == "OK" || env.status.isEmpty else {
+                        throw AppError.apiError(env.errorMessage ?? env.status)
+                    }
+                    promise(.success(env.results))
+                } catch {
+                    promise(.failure(error))
+                }
+            }
+        }.eraseToAnyPublisher()
+    }
 
-                return Publishers.MergeMany(detailPublishers)
-                    .collect()
-                    .setFailureType(to: Error.self)
-                    .flatMap { (pairs: [(PlaceResult, PlaceDetailsResult?)]) -> AnyPublisher<[NightlifeVenue], Error> in
-                        // Before final mapping, consult remote scores for candidates
-                        let placeIds = pairs.map { $0.0.placeId }
-                        return Future<[NightlifeVenue], Error> { promise in
-                            Task {
-                                let scores = await NightlifeScoreService.shared.fetchScores(for: placeIds)
-                                let threshold: Double = 20 // allow heuristics but down-rank low-confidence
-                                let mapped: [NightlifeVenue] = pairs.compactMap { pair in
-                                    let (nearby, details) = pair
-                                    let heuristicsPass = self.passesNightlifeRules(nearby: nearby, details: details)
-                                    let score = scores[nearby.placeId] ?? 0
-                                    // Accept if heuristics pass OR score high enough (keeps legit bars that heuristics might miss)
-                                    guard heuristicsPass || score >= threshold else { return nil }
-                                    return self.createNightlifeVenue(from: nearby, details: details, userLocation: location)
-                                }
-                                #if DEBUG
-                                print("Nightlife mapped after scoring: \(mapped.count)")
-                                #endif
-                                promise(.success(mapped))
-                            }
-                        }.eraseToAnyPublisher()
+    // MARK: - Fetch More Results (for pagination)
+    func loadMoreVenues(location: CLLocation, currentCount: Int, batchSize: Int = 20) -> AnyPublisher<[NightlifeVenue], Error> {
+        let key = PlacesCache.key(for: location)
+        let sessionKey = "nearby_\(key.latBucket)_\(key.lonBucket)"
+
+        // Get cached results
+        guard let sessionEntry = sessionCache[sessionKey] else {
+            // No cached results, return empty
+            return Just([])
+                .setFailureType(to: Error.self)
+                .eraseToAnyPublisher()
+        }
+
+        // Get the next batch of results
+        let startIndex = currentCount
+        let endIndex = min(currentCount + batchSize, sessionEntry.results.count)
+
+        guard startIndex < sessionEntry.results.count else {
+            // No more results
+            return Just([])
+                .setFailureType(to: Error.self)
+                .eraseToAnyPublisher()
+        }
+
+        let nextBatch = Array(sessionEntry.results[startIndex..<endIndex])
+        #if DEBUG
+        print("üìÑ Loading more: \(nextBatch.count) venues (total cached: \(sessionEntry.results.count))")
+        #endif
+
+        return fetchVenueDetails(for: nextBatch, location: location, batchSize: nextBatch.count)
+    }
+
+    // MARK: - Fetch Venue Details (refactored for reuse)
+    private func fetchVenueDetails(for results: [PlaceResult], location: CLLocation, batchSize: Int) -> AnyPublisher<[NightlifeVenue], Error> {
+
+        // OPTIMIZED: Limit to specified batch size to reduce API costs
+        // Increased from 30 to 40 to ensure we don't miss important venues
+        let detailPublishers: [AnyPublisher<(PlaceResult, PlaceDetailsResult?), Never>] = results.prefix(batchSize).map { result in
+            self.fetchDetailsCached(placeId: result.placeId)
+                .map { (result, $0) }
+                .catch { _ in Just((result, nil)) }  // tolerate per-place failure
+                .eraseToAnyPublisher()
+        }
+
+        return Publishers.MergeMany(detailPublishers)
+            .collect()
+            .setFailureType(to: Error.self)
+            .flatMap { (pairs: [(PlaceResult, PlaceDetailsResult?)]) -> AnyPublisher<[NightlifeVenue], Error> in
+                // Before final mapping, consult remote scores for candidates
+                let placeIds = pairs.map { $0.0.placeId }
+                return Future<[NightlifeVenue], Error> { promise in
+                    Task {
+                        let scores = await NightlifeScoreService.shared.fetchScores(for: placeIds)
+                        let threshold: Double = 20 // allow heuristics but down-rank low-confidence
+                        let mapped: [NightlifeVenue] = pairs.compactMap { pair in
+                            let (nearby, details) = pair
+                            let heuristicsPass = self.passesNightlifeRules(nearby: nearby, details: details)
+                            let score = scores[nearby.placeId] ?? 0
+                            // Accept if heuristics pass OR score high enough (keeps legit bars that heuristics might miss)
+                            guard heuristicsPass || score >= threshold else { return nil }
+                            return self.createNightlifeVenue(from: nearby, details: details, userLocation: location)
+                        }
+                        #if DEBUG
+                        print("‚úÖ Fetched details for \(mapped.count) venues")
+                        #endif
+                        promise(.success(mapped))
                     }
-                    .eraseToAnyPublisher()
+                }.eraseToAnyPublisher()
             }
             .eraseToAnyPublisher()
     }
@@ -224,6 +527,8 @@ class GooglePlacesService {
             .eraseToAnyPublisher()
     }
 
+    // Reverted: removed Text Search helpers and ensure logic
+
     // MARK: - Details (cached wrapper)
 
     private func fetchDetailsCached(placeId: String) -> AnyPublisher<PlaceDetailsResult, Error> {
@@ -240,40 +545,69 @@ class GooglePlacesService {
     }
 
     private func fetchDetailsNetwork(placeId: String) -> AnyPublisher<PlaceDetailsResult, Error> {
+        // If backend is configured, route Details through it to avoid client-side Places usage
+        let backendBase = AppConfiguration.shared.placesBackendURL
+        if !backendBase.isEmpty, var comps = URLComponents(string: backendBase) {
+            if comps.path.isEmpty || comps.path == "/" {
+                comps.path = "/getPlaceDetails"
+            } else if !comps.path.contains("/getPlaceDetails") {
+                comps.path = comps.path.replacingOccurrences(of: "/getNearby", with: "/getPlaceDetails")
+            }
+            comps.queryItems = [
+                URLQueryItem(name: "place_id", value: placeId),
+                URLQueryItem(name: "fields", value: "place_id,opening_hours,current_opening_hours,types,name,photos,rating,user_ratings_total,business_status")
+            ]
+            if let url = comps.url {
+                #if DEBUG
+                print("Backend Details URL: \(url.absoluteString)")
+                #endif
+                let backendPublisher = session.dataTaskPublisher(for: url)
+                    .map(\.data)
+                    .decode(type: PlaceDetailsResponse.self, decoder: JSONDecoder())
+                    .tryMap { response in
+                        #if DEBUG
+                        if response.status != "OK" { print("Details error_message: \(response.errorMessage ?? "-")") }
+                        #endif
+                        guard response.status == "OK", let result = response.result else {
+                            if response.status == "NOT_FOUND" { throw AppError.documentNotFound }
+                            else { throw AppError.apiError(response.errorMessage ?? response.status) }
+                        }
+                        return result
+                    }
+                // Do not fall back to Google client API when backend is configured.
+                return backendPublisher.eraseToAnyPublisher()
+            }
+        }
+
+        // Fallback: direct Google (should not be used in production once backend is verified)
+        return directGoogleDetailsPublisher(placeId: placeId)
+    }
+
+    private func directGoogleDetailsPublisher(placeId: String) -> AnyPublisher<PlaceDetailsResult, Error> {
         guard var components = URLComponents(string: "https://maps.googleapis.com/maps/api/place/details/json") else {
             return Fail(error: PlacesError.invalidURL).eraseToAnyPublisher()
         }
         components.queryItems = [
             URLQueryItem(name: "place_id", value: placeId),
-            URLQueryItem(name: "fields", value: "opening_hours,current_opening_hours,types,name,photos,rating,user_ratings_total,business_status"),
+            URLQueryItem(name: "fields", value: "place_id,opening_hours,current_opening_hours,types,name,photos,rating,user_ratings_total,business_status"),
             URLQueryItem(name: "key", value: apiKey)
         ]
-
         guard let url = components.url else {
             return Fail(error: PlacesError.invalidURL).eraseToAnyPublisher()
         }
-
         #if DEBUG
         print("Details URL for \(placeId)")
         #endif
-
         return session.dataTaskPublisher(for: url)
             .map(\.data)
             .decode(type: PlaceDetailsResponse.self, decoder: JSONDecoder())
             .tryMap { response in
                 #if DEBUG
-                if response.status != "OK" {
-                    print("Details error_message: \(response.errorMessage ?? "-")")
-                }
+                if response.status != "OK" { print("Details error_message: \(response.errorMessage ?? "-")") }
                 #endif
                 guard response.status == "OK", let result = response.result else {
-                    if response.status == "NOT_FOUND" {
-                        throw AppError.documentNotFound
-                    } else if response.status == "REQUEST_DENIED" {
-                        throw AppError.apiError("Google Places API access denied.")
-                    } else {
-                        throw AppError.apiError(response.errorMessage ?? response.status)
-                    }
+                    if response.status == "NOT_FOUND" { throw AppError.documentNotFound }
+                    else { throw AppError.apiError(response.errorMessage ?? response.status) }
                 }
                 return result
             }
@@ -297,28 +631,47 @@ class GooglePlacesService {
     ]
     private lazy var chainBlocklistNorm: [String] = chainBlocklistRaw.map { norm($0) }
 
-    private func passesNightlifeRules(nearby: PlaceResult, details: PlaceDetailsResult?) -> Bool {
+    func passesNightlifeRules(nearby: PlaceResult, details: PlaceDetailsResult?) -> Bool {
         let nearbyTypes = Set(nearby.types)
         let detailsTypes = Set(details?.types ?? [])
         let allTypes = nearbyTypes.union(detailsTypes)
 
-        // Basic type flags
-        let isBar        = allTypes.contains("bar")
-        let isClub       = allTypes.contains("night_club")
-        let isRestaurant = allTypes.contains("restaurant")
+        // PlaceId-based hard allowlist (before any other checks)
+        if localAllowlistIds.contains(nearby.placeId) {
+            #if DEBUG
+            print("‚úÖ Allowed: local allowlist (pid) for \(nearby.name)")
+            #endif
+            return true
+        }
+
+        // Name/keywords (used for allowlist short-circuit)
+        let nameLower = (details?.name ?? nearby.name).lowercased()
+        let nameNorm = norm(nameLower)
+
+        // Local hard-allowlist by name (robust to missing hours/types/business_status)
+        if localAllowlist.contains(where: { nameLower.contains($0) || nameNorm.contains(norm($0)) }) {
+            #if DEBUG
+            print("‚úÖ Allowed: local allowlist (name) for \(nearby.name)")
+            #endif
+            return true
+        }
 
-        // Business status (exclude temporarily/permanently closed)
-        if let status = details?.businessStatus?.lowercased(),
-           status != "operational" {
+        // Business status (exclude temporarily/permanently closed) ‚Äî bypassed by PID/Name allowlists above
+        if let status = details?.businessStatus?.lowercased(), status != "operational" {
+            #if DEBUG
+            print("üö´ Excluded: business_status (\(status)) for \(nearby.name)")
+            #endif
             return false
         }
 
-        let nameLower = (details?.name ?? nearby.name).lowercased()
+        let looksLikeBarFromName = [
+            " bar", "pub", "tavern", "taproom", "ale house", "saloon",
+            "cantina", "sports bar", "beer garden", "lounge", "wine bar",
+            "brewery", "brewing", "cidery", "mead"
+        ].contains(where: { nameLower.contains($0) })
 
         // Overrides: force allow/deny by name or placeId (remote-configurable)
         let overrides = NightlifeOverrides.shared
-        // Best-effort synchronous checks; async helper exposes cached values after first fetch
-        // Use Task to synchronously access without blocking pipeline
         var forceAllow = false
         var forceDeny = false
         let pid = nearby.placeId
@@ -328,42 +681,154 @@ class GooglePlacesService {
             forceDeny = await overrides.shouldDeny(name: nameLower, placeId: pid)
             sema.signal()
         }
-        _ = sema.wait(timeout: .now() + 0.15) // do not stall UI; 150ms budget
-        if forceDeny { return false }
-        if forceAllow { return true }
-        let nameNorm  = norm(nameLower)
+        _ = sema.wait(timeout: .now() + 0.15)
+        if forceDeny {
+            #if DEBUG
+            print("üö´ Excluded: override deny for \(nearby.name)")
+            #endif
+            return false
+        }
+        if forceAllow {
+            #if DEBUG
+            print("‚úÖ Allowed: override allow for \(nearby.name)")
+            #endif
+            return true
+        }
 
-        // Chains out
-        if chainBlocklistNorm.contains(where: { nameNorm.contains($0) }) { return false }
+        // (already checked name allowlist above)
 
-        // Smoking-forward venues out
-        if allTypes.contains("cigar_shop") || allTypes.contains("cigar_store") || allTypes.contains("hookah_bar") { return false }
-        if smokingKeywords.contains(where: { nameLower.contains($0) }) { return false }
-        if nameLower.contains("lounge") && smokingKeywords.contains(where: { nameLower.contains($0) }) { return false }
+        // Allowlist by Google types
+        let isBar        = allTypes.contains("bar")
+        let isClub       = allTypes.contains("night_club")
+        let isRestaurant = allTypes.contains("restaurant")
+        let allowedType = isBar || isClub || (isRestaurant && looksLikeBarFromName)
+        if !allowedType {
+            #if DEBUG
+            print("üö´ Excluded: type_allowlist for \(nearby.name) types=\(Array(allTypes))")
+            #endif
+            return false
+        }
 
-        // Adult/strip clubs out (name based; Google Places lacks a reliable adult type)
-        if adultKeywords.contains(where: { nameLower.contains($0) }) { return false }
+        // Chain blocklist
+        if chainBlocklistNorm.contains(where: { nameNorm.contains($0) }) {
+            #if DEBUG
+            print("üö´ Excluded: chain_blocklist for \(nearby.name)")
+            #endif
+            return false
+        }
 
-        // Food-heavy restaurants (without bar/club signal) out
-        if isRestaurant && !isBar && !isClub {
-            if restaurantNegativeKeywords.contains(where: { nameLower.contains($0) }) { return false }
+        // Adult/strip clubs
+        if adultKeywords.contains(where: { nameLower.contains($0) }) {
+            #if DEBUG
+            print("üö´ Excluded: adult for \(nearby.name)")
+            #endif
+            return false
         }
 
-        // Hours requirement with local allowlist escape hatch for college spots
-        if localAllowlist.contains(where: { nameLower.contains($0) }) {
-            // Include known local bar spots even if hours are incomplete
-            return true
+        // Smoking-forward venues
+        if allTypes.contains("cigar_shop") || allTypes.contains("cigar_store") || allTypes.contains("hookah_bar") ||
+           smokingKeywords.contains(where: { nameLower.contains($0) }) {
+            #if DEBUG
+            print("üö´ Excluded: smoking for \(nearby.name)")
+            #endif
+            return false
         }
-        guard let hours = details?.currentOpeningHours ?? details?.openingHours else {
+
+        // Negative signals (hard exclude regardless of type)
+        if restaurantNegativeKeywords.contains(where: { nameLower.contains($0) }) {
+            #if DEBUG
+            print("üö´ Excluded: negative_keyword for \(nearby.name)")
+            #endif
             return false
         }
 
-        let friClose = latestCloseHour(on: 5, from: hours)
-        let satClose = latestCloseHour(on: 6, from: hours)
-        guard friClose >= minLateCloseHour && satClose >= minLateCloseHour else { return false }
+        // Closing-time rule (Fri & Sat >= 1:00am local i.e., >=25 in 0..48)
+        let hours = details?.currentOpeningHours ?? details?.openingHours
+        if let hours {
+            let fri = 5, sat = 6
+            let latestFri = latestCloseHour(on: fri, from: hours)
+            let latestSat = latestCloseHour(on: sat, from: hours)
+            if latestFri < minLateCloseHour {
+                #if DEBUG
+                print("üö´ Excluded: early_close_fri (\(latestFri)) for \(nearby.name)")
+                #endif
+                return false
+            }
+            if latestSat < minLateCloseHour {
+                #if DEBUG
+                print("üö´ Excluded: early_close_sat (\(latestSat)) for \(nearby.name)")
+                #endif
+                return false
+            }
+        } else {
+            // No hours: if enabled, allow bars/clubs that otherwise pass type/keyword checks
+            if fallbackAllowBarsWithoutHours {
+                #if DEBUG
+                print("‚úÖ Allowed: missing_hours fallback for \(nearby.name)")
+                #endif
+                return true
+            } else if !localAllowlist.contains(where: { nameLower.contains($0) }) {
+                #if DEBUG
+                print("üö´ Excluded: missing_hours for \(nearby.name)")
+                #endif
+                return false
+            }
+        }
+
+        return true
+    }
 
-        // Must still look like a nightlife venue (bar/club/restaurant that passed negatives)
-        return isBar || isClub || isRestaurant
+    /// Returns true if the venue has any opening period that starts today (ET),
+    /// regardless of current time (supports planning for later today).
+    private func opensOnEtToday(_ hours: OpeningHours?) -> Bool {
+        guard let periods = hours?.periods else { return false }
+        var cal = Calendar(identifier: .gregorian)
+        cal.timeZone = TimeZone(identifier: "America/New_York") ?? .current
+        let weekday = cal.component(.weekday, from: Date()) - 1 // Google: 0=Sun..6=Sat, Foundation: 1=Sun..7=Sat
+        return periods.contains { $0.open?.day == weekday }
+    }
+
+    // MARK: - Public async helper for details (cached)
+    func fetchDetailsCachedAsync(placeId: String) async throws -> PlaceDetailsResult {
+        if let cached = cache.loadDetails(placeId: placeId) {
+            return cached
+        }
+        // Build URL for details
+        // Prefer backend if configured
+        let backendBase = AppConfiguration.shared.placesBackendURL
+        if !backendBase.isEmpty, var comps = URLComponents(string: backendBase) {
+            if comps.path.isEmpty || comps.path == "/" { comps.path = "/getPlaceDetails" }
+            else if !comps.path.contains("/getPlaceDetails") { comps.path = comps.path.replacingOccurrences(of: "/getNearby", with: "/getPlaceDetails") }
+            comps.queryItems = [
+                URLQueryItem(name: "place_id", value: placeId),
+                URLQueryItem(name: "fields", value: "place_id,opening_hours,current_opening_hours,types,name,photos,rating,user_ratings_total,business_status")
+            ]
+            if let u = comps.url {
+                let (data, _) = try await URLSession.shared.data(from: u)
+                let response = try JSONDecoder().decode(PlaceDetailsResponse.self, from: data)
+                if response.status == "OK", let result = response.result {
+                    cache.saveDetails(placeId: placeId, details: result)
+                    return result
+                } else {
+                    throw AppError.apiError(response.errorMessage ?? response.status)
+                }
+            }
+        }
+        // No backend configured ‚Üí direct Google (not used when backend is set)
+        var components = URLComponents(string: "https://maps.googleapis.com/maps/api/place/details/json")!
+        components.queryItems = [
+            URLQueryItem(name: "place_id", value: placeId),
+            URLQueryItem(name: "fields", value: "place_id,opening_hours,current_opening_hours,types,name,photos,rating,user_ratings_total,business_status"),
+            URLQueryItem(name: "key", value: apiKey)
+        ]
+        let url = components.url!
+        let (data, _) = try await URLSession.shared.data(from: url)
+        let response = try JSONDecoder().decode(PlaceDetailsResponse.self, from: data)
+        guard response.status == "OK", let result = response.result else {
+            throw AppError.apiError(response.errorMessage ?? response.status)
+        }
+        cache.saveDetails(placeId: placeId, details: result)
+        return result
     }
 
     /// Returns the latest close hour for a weekday (0=Sun...6=Sat) in [0..48),
@@ -416,11 +881,26 @@ class GooglePlacesService {
                                        longitude: nearby.geometry.location.lng)
         let distanceMiles = userLocation.distance(from: venueLocation) / 1609.34
 
+        // Prefer DB/nearby-provided stable URL, else build direct Google Photo URL.
         let photoRef = details?.photos?.first?.photoReference ?? nearby.photos?.first?.photoReference
-        var photoURL: String? = {
-            guard let ref = photoRef else { return nil }
-            return "https://maps.googleapis.com/maps/api/place/photo?maxwidth=800&photoreference=\(ref)&key=\(apiKey)"
-        }()
+        var photoURL: String? = nearby.photoURL
+        if photoURL == nil {
+            photoURL = {
+                guard let ref = photoRef else { return nil }
+                // Prefer direct Google photo when key is available to avoid potential
+                // App Check enforcement on Functions; fallback to backend proxy.
+                if !apiKey.isEmpty {
+                    var c = URLComponents(string: "https://maps.googleapis.com/maps/api/place/photo")!
+                    c.queryItems = [
+                        URLQueryItem(name: "maxwidth", value: "800"),
+                        URLQueryItem(name: "photoreference", value: ref),
+                        URLQueryItem(name: "key", value: apiKey)
+                    ]
+                    return c.url?.absoluteString
+                }
+                return backendPhotoURL(for: ref)
+            }()
+        }
         // Apply photo overrides by name/placeId if present
         if let override = NightlifeOverrides.shared.photoOverride(name: details?.name ?? nearby.name,
                                                                   placeId: nearby.placeId) {
@@ -444,6 +924,12 @@ class GooglePlacesService {
             return "venue"
         }()
 
+        // Derive live open status from hours (avoid stale cached open_now)
+        let liveIsOpen: Bool? = {
+            let hours = details?.currentOpeningHours ?? details?.openingHours
+            return Self.computeIsOpenNow(hours)
+        }()
+
         return NightlifeVenue(
             placeId: nearby.placeId,
             name: details?.name ?? nearby.name,
@@ -454,12 +940,69 @@ class GooglePlacesService {
             distance: distanceMiles,
             currentCapacity: 0, // counts populated from Firestore stats later
             coverCharge: 0,
-            isOpen: details?.currentOpeningHours?.openNow ?? details?.openingHours?.openNow,
+            isOpen: liveIsOpen,
             priceLevel: nil,
             latitude: nearby.geometry.location.lat,
             longitude: nearby.geometry.location.lng
         )
     }
+    private func backendPhotoURL(for ref: String) -> String? {
+        let base = AppConfiguration.shared.placesBackendURL
+        guard !base.isEmpty, var comps = URLComponents(string: base) else { return nil }
+        if comps.path.contains("/getNearby") {
+            comps.path = comps.path.replacingOccurrences(of: "/getNearby", with: "/getPlacePhoto")
+        } else if comps.path.isEmpty || comps.path == "/" {
+            comps.path = "/getPlacePhoto"
+        }
+        comps.queryItems = [
+            URLQueryItem(name: "ref", value: ref),
+            // Use a slightly smaller width to improve first-paint latency
+            URLQueryItem(name: "maxwidth", value: "600")
+        ]
+        return comps.url?.absoluteString
+    }
+
+    // MARK: - Live open/closed computation
+
+    /// Computes whether a venue is currently open based on its weekly periods.
+    /// Uses America/New_York timezone to match our market.
+    static func computeIsOpenNow(_ hours: OpeningHours?) -> Bool? {
+        guard let periods = hours?.periods, !periods.isEmpty else { return nil }
+        var cal = Calendar(identifier: .gregorian)
+        cal.timeZone = TimeZone(identifier: "America/New_York") ?? .current
+
+        let now = Date()
+        let comps = cal.dateComponents([.weekday, .hour, .minute], from: now)
+        // Foundation: 1=Sun..7=Sat; Google: 0=Sun..6=Sat
+        let gDay = ((comps.weekday ?? 1) - 1 + 7) % 7
+        let nowMinutes = (comps.hour ?? 0) * 60 + (comps.minute ?? 0)
+
+        func minutes(_ hhmm: String, treatMidnightAs24: Bool) -> Int? {
+            guard hhmm.count == 4, let hh = Int(hhmm.prefix(2)), let mm = Int(hhmm.suffix(2)) else { return nil }
+            let h = (treatMidnightAs24 && hh == 0) ? 24 : hh
+            return h * 60 + mm
+        }
+
+        for p in periods {
+            guard let o = p.open, let c = p.close,
+                  let oMin = minutes(o.time, treatMidnightAs24: false),
+                  let cMinRaw = minutes(c.time, treatMidnightAs24: true) else { continue }
+
+            var cMin = cMinRaw
+            let crossesMidnight = (c.day != o.day) || (cMin <= oMin)
+            if crossesMidnight { cMin += 24 * 60 }
+
+            if o.day == gDay {
+                if nowMinutes >= oMin && nowMinutes < cMin { return true }
+            }
+
+            if crossesMidnight {
+                let nextDay = (o.day + 1) % 7
+                if nextDay == gDay {
+                    if nowMinutes < (cMin - 24 * 60) { return true }
+                }
+            }
+        }
+        return false
+    }
 }
-    /// Local allowlist by name to include well-known college bars even if hours data is incomplete.
-    private let localAllowlist: [String] = ["golden pony","the golden pony","ruby's lounge","rubys lounge","ruby lounge"]
diff --git a/Buzzd/Data/Services/PlacesCache.swift b/Buzzd/Data/Services/PlacesCache.swift
index b7565e06..30c31872 100644
--- a/Buzzd/Data/Services/PlacesCache.swift
+++ b/Buzzd/Data/Services/PlacesCache.swift
@@ -44,10 +44,10 @@ final class PlacesCache {
 
     static let shared = PlacesCache()
 
-    /// ~10 minutes for nearby candidates
-    private let nearbyTTL: TimeInterval = 10 * 60
-    /// ~24 hours for place details
-    private let detailsTTL: TimeInterval = 24 * 60 * 60
+    /// 7 days for nearby candidates (city dataset cache aligns with backend)
+    private let nearbyTTL: TimeInterval = 7 * 24 * 60 * 60
+    /// 7 days for place details (hours/info rarely changes)
+    private let detailsTTL: TimeInterval = 7 * 24 * 60 * 60
 
     // MARK: In-memory
 
diff --git a/Buzzd/Data/Services/UsersService.swift b/Buzzd/Data/Services/UsersService.swift
index b5efc5c0..cafe2ca9 100644
--- a/Buzzd/Data/Services/UsersService.swift
+++ b/Buzzd/Data/Services/UsersService.swift
@@ -22,6 +22,7 @@ struct UsersService {
             ]
             if let nm = name?.trimmingCharacters(in: .whitespacesAndNewlines), !nm.isEmpty {
                 data["name"] = nm
+                data["nameLower"] = nm.lowercased()
             }
             // Only set username if it's explicitly provided AND the existing profile doesn't have one
             if let u = username?.lowercased().trimmingCharacters(in: .whitespacesAndNewlines), !u.isEmpty {
@@ -45,6 +46,7 @@ struct UsersService {
             var userData: [String: Any] = [
                 "email": email,
                 "name": (name ?? "").trimmingCharacters(in: .whitespacesAndNewlines),
+                "nameLower": ((name ?? "").trimmingCharacters(in: .whitespacesAndNewlines)).lowercased(),
                 "status": "active",
                 "approved": false,
                 "createdAt": FieldValue.serverTimestamp(),
@@ -125,7 +127,10 @@ struct UsersService {
                           userInfo: [NSLocalizedDescriptionKey: "No authenticated user found"])
         }
         print("üîç Ensuring profile for current user: \(u.uid) (\(email))")
-        try await ensureProfile(uid: u.uid, email: email, name: preferredName(for: u))
+        // If the sign-up flow just captured a username, include it on initial create to avoid
+        // pre‚Äëverification update failures due to security rules.
+        let pendingUsername = UserDefaults.standard.string(forKey: "pending.signup.username")
+        try await ensureProfile(uid: u.uid, email: email, name: preferredName(for: u), username: pendingUsername)
     }
 
     /// Records the timestamp when a user successfully verifies their email and approves them
@@ -139,6 +144,22 @@ struct UsersService {
         print("‚úÖ Recorded email verification and approved user: \(uid)")
     }
 
+    /// Store the last city dataset the user fetched and when, so we can avoid redundant calls across sessions.
+    static func updateCityCacheInfo(cityId: String) async {
+        guard let uid = Auth.auth().currentUser?.uid, !cityId.isEmpty else { return }
+        let ref = db.collection("users").document(uid)
+        do {
+            try await ref.setData([
+                "lastCityId": cityId,
+                "lastCityCacheAt": FieldValue.serverTimestamp(),
+                "updatedAt": FieldValue.serverTimestamp()
+            ], merge: true)
+            print("‚úÖ Updated user city cache info: \(cityId)")
+        } catch {
+            print("‚ö†Ô∏è Failed to update user city cache info: \(error)")
+        }
+    }
+
     /// Update name and/or username. Username updates are done via UsernameService transaction.
     static func updateProfile(uid: String, name: String? = nil, username: String? = nil) async throws {
         let ref = db.collection("users").document(uid)
@@ -152,6 +173,7 @@ struct UsersService {
         if let nm = name?.trimmingCharacters(in: .whitespacesAndNewlines), !nm.isEmpty {
             try await ref.setData([
                 "name": nm,
+                "nameLower": nm.lowercased(),
                 "updatedAt": FieldValue.serverTimestamp()
             ], merge: true)
         }
@@ -252,9 +274,6 @@ final class UserSession: ObservableObject {
                         }
                     }
                     await self?.loadUserProfile(userId: user.uid)
-
-                    // Start venue data listeners now that user is authenticated
-                    VenueDataService.shared.startListening()
                 } else {
                     Crashlytics.crashlytics().setUserID("signed_out")
                     self?.userProfile = nil
@@ -305,6 +324,10 @@ final class UserSession: ObservableObject {
                         do {
                             let profile = try document.data(as: BuzzdUser.self)
                             self?.userProfile = profile
+                            // Start venue data listeners only after approval
+                            if profile.approved {
+                                VenueDataService.shared.startListening()
+                            }
                             print("‚úÖ [PROFILE] Loaded profile: @\(profile.username ?? "no-username")")
                         } catch {
                             print("‚ùå [PROFILE] Error decoding profile: \(error)")
diff --git a/Buzzd/Features/Auth/AccountCreateView.swift b/Buzzd/Features/Auth/AccountCreateView.swift
index 213d21e0..fbb97c50 100644
--- a/Buzzd/Features/Auth/AccountCreateView.swift
+++ b/Buzzd/Features/Auth/AccountCreateView.swift
@@ -76,10 +76,14 @@ struct AccountCreateView: View {
         ZStack {
             AuthBackgroundView()
 
-            ScrollView(.vertical, showsIndicators: false) {
-                VStack(spacing: 24) {
-                    headerHero
-
+            VStack(spacing: 0) {
+                // Fixed header (not scrollable)
+                headerHero
+                    .padding(.top, 12)
+                    .padding(.bottom, 8)
+
+                // Scrollable content
+                ScrollView(.vertical, showsIndicators: false) {
                     VStack(alignment: .leading, spacing: 24) {
                             if step == .name {
                                 AuthGlassCard(maxWidth: 520) {
@@ -375,11 +379,9 @@ struct AccountCreateView: View {
                             }
                         }
                         .padding(.horizontal, 24)
-                        .padding(.top, 16)
-
-                        Spacer(minLength: 60)
+                        .padding(.top, 8)
+                        .padding(.bottom, 20)
                 }
-                .padding(.bottom, 40)
             }
         }
         .navigationTitle("Create Account")
@@ -419,7 +421,7 @@ struct AccountCreateView: View {
         )
         .frame(maxWidth: .infinity)
         .frame(minHeight: 140, alignment: .center)
-        .padding(.top, 16)
+        .padding(.top, 0)
     }
 
     // MARK: - Bottom step bar
@@ -671,6 +673,9 @@ struct AccountCreateView: View {
             let fullName = "\(firstName.trimmingCharacters(in: .whitespacesAndNewlines)) \(lastName.trimmingCharacters(in: .whitespacesAndNewlines))"
             let cleanUsername = username.trimmingCharacters(in: .whitespacesAndNewlines)
 
+            // Persist chosen username briefly to avoid race with auth listener creating the profile
+            UserDefaults.standard.set(cleanUsername.lowercased(), forKey: "pending.signup.username")
+
             let user = try await AuthService.createAccount(
                 email: email,
                 password: password,
diff --git a/Buzzd/Features/Auth/AddUsernameView.swift b/Buzzd/Features/Auth/AddUsernameView.swift
index 616087b3..0a6a3abd 100644
--- a/Buzzd/Features/Auth/AddUsernameView.swift
+++ b/Buzzd/Features/Auth/AddUsernameView.swift
@@ -3,7 +3,7 @@ import SwiftUI
 struct AddUsernameView: View {
     @EnvironmentObject private var session: UserSession
     @Environment(\.dismiss) private var dismiss
-
+    
     @State private var username: String = ""
     @State private var usernameError: String?
     @State private var usernameAvailable: Bool?
@@ -11,180 +11,181 @@ struct AddUsernameView: View {
     @State private var isUpdating = false
     @State private var errorMessage: String?
     @State private var usernameCheckTask: Task<Void, Never>?
-
+    
     private var canSave: Bool {
         !username.isEmpty && usernameError == nil && usernameAvailable == true && !isUpdating
     }
-
+    
     var body: some View {
         NavigationStack {
             ZStack {
                 AuthBackgroundView()
-
-                ScrollView(.vertical, showsIndicators: false) {
-                    VStack(spacing: 28) {
-                        Spacer(minLength: 60)
-
-                        AuthHeroView(
-                            icon: "at.circle.fill",
-                            title: "Claim Your Username",
-                            subtitle: "Add a unique handle so friends can find you"
-                        )
-
-                        AuthGlassCard(maxWidth: 520) {
-                            VStack(alignment: .leading, spacing: 20) {
-                                Text("Username")
-                                    .font(.headline)
-                                    .foregroundColor(.white.opacity(0.85))
-
-                                HStack(spacing: 12) {
-                                    Image(systemName: "at")
-                                        .foregroundColor(.white.opacity(0.6))
-                                        .frame(width: 20)
-
-                                    TextField("choose your username", text: $username)
-                                        .textInputAutocapitalization(.never)
-                                        .autocorrectionDisabled(true)
-                                        .foregroundColor(.white)
-                                        .font(.body)
-                                        .onChange(of: username) { _, value in
-                                            validateUsername(value)
-                                        }
-
-                                    Group {
-                                        if checkingUsername {
-                                            ProgressView().scaleEffect(0.75).tint(.white)
-                                        } else if let available = usernameAvailable {
-                                            Image(systemName: available ? "checkmark.circle.fill" : "xmark.circle.fill")
-                                                .foregroundColor(available ? .green : .red)
+                
+                VStack(spacing: 0) {
+                    // Fixed header (not scrollable)
+                    AuthHeroView(
+                        icon: "at.circle.fill",
+                        title: "Claim Your Username",
+                        subtitle: "Add a unique handle so friends can find you"
+                    )
+                    .padding(.top, 12)
+                    .padding(.bottom, 8)
+                    
+                    // Scrollable content
+                    ScrollView(.vertical, showsIndicators: false) {
+                        VStack(spacing: 24) {
+                            AuthGlassCard(maxWidth: 520) {
+                                VStack(alignment: .leading, spacing: 20) {
+                                    Text("Username")
+                                        .font(.headline)
+                                        .foregroundColor(.white.opacity(0.85))
+                                    
+                                    HStack(spacing: 12) {
+                                        Image(systemName: "at")
+                                            .foregroundColor(.white.opacity(0.6))
+                                            .frame(width: 20)
+                                        
+                                        TextField("choose your username", text: $username)
+                                            .textInputAutocapitalization(.never)
+                                            .autocorrectionDisabled(true)
+                                            .foregroundColor(.white)
+                                            .font(.body)
+                                            .onChange(of: username) { _, value in
+                                                validateUsername(value)
+                                            }
+                                        
+                                        Group {
+                                            if checkingUsername {
+                                                ProgressView().scaleEffect(0.75).tint(.white)
+                                            } else if let available = usernameAvailable {
+                                                Image(systemName: available ? "checkmark.circle.fill" : "xmark.circle.fill")
+                                                    .foregroundColor(available ? .green : .red)
+                                            }
                                         }
+                                        .frame(width: 22)
+                                    }
+                                    .padding(16)
+                                    .background(Color.white.opacity(0.08), in: RoundedRectangle(cornerRadius: 16, style: .continuous))
+                                    .overlay(
+                                        RoundedRectangle(cornerRadius: 16, style: .continuous)
+                                            .stroke(usernameAccentColor, lineWidth: 1)
+                                    )
+                                    
+                                    if let usernameError {
+                                        Text(usernameError)
+                                            .font(.caption)
+                                            .foregroundColor(.red)
+                                    } else if let available = usernameAvailable {
+                                        Text(available ? "‚úì This username is available" : "‚úó That username is taken")
+                                            .font(.caption)
+                                            .foregroundColor(available ? .green : .red)
+                                    }
+                                    
+                                    Text("3‚Äì20 characters ‚Ä¢ letters, numbers, periods, underscores")
+                                        .font(.caption2)
+                                        .foregroundColor(.white.opacity(0.55))
+                                    
+                                    if let errorMessage {
+                                        AuthMessageView(message: errorMessage, style: .error)
+                                            .transition(.opacity)
+                                    }
+                                    
+                                    AuthPrimaryButton(
+                                        title: "Save Username",
+                                        icon: "checkmark.seal.fill",
+                                        isLoading: isUpdating,
+                                        isEnabled: canSave
+                                    ) {
+                                        saveUsername()
                                     }
-                                    .frame(width: 22)
-                                }
-                                .padding(16)
-                                .background(Color.white.opacity(0.08), in: RoundedRectangle(cornerRadius: 16, style: .continuous))
-                                .overlay(
-                                    RoundedRectangle(cornerRadius: 16, style: .continuous)
-                                        .stroke(usernameAccentColor, lineWidth: 1)
-                                )
-
-                                if let usernameError {
-                                    Text(usernameError)
-                                        .font(.caption)
-                                        .foregroundColor(.red)
-                                } else if let available = usernameAvailable {
-                                    Text(available ? "‚úì This username is available" : "‚úó That username is taken")
-                                        .font(.caption)
-                                        .foregroundColor(available ? .green : .red)
-                                }
-
-                                Text("3‚Äì20 characters ‚Ä¢ letters, numbers, periods, underscores")
-                                    .font(.caption2)
-                                    .foregroundColor(.white.opacity(0.55))
-
-                                if let errorMessage {
-                                    AuthMessageView(message: errorMessage, style: .error)
-                                        .transition(.opacity)
-                                }
-
-                                AuthPrimaryButton(
-                                    title: "Save Username",
-                                    icon: "checkmark.seal.fill",
-                                    isLoading: isUpdating,
-                                    isEnabled: canSave
-                                ) {
-                                    saveUsername()
                                 }
                             }
+                            .padding(.horizontal, 24)
+                            
+                            AuthSecondaryButton(title: "Skip for now") {
+                                dismiss()
+                            }
+                            .padding(.bottom, 20)
                         }
-                        .padding(.horizontal, 24)
-
-                        AuthSecondaryButton(title: "Skip for now") {
-                            dismiss()
-                        }
-                        .padding(.bottom, 40)
-
-                        Spacer(minLength: 40)
                     }
-                    .padding(.bottom, 60)
                 }
+                .navigationTitle("Add Username")
+                .navigationBarTitleDisplayMode(.inline)
+                .toolbarColorScheme(.dark, for: .navigationBar)
+                .onDisappear { usernameCheckTask?.cancel() }
             }
-            .navigationTitle("Add Username")
-            .navigationBarTitleDisplayMode(.inline)
-            .toolbarColorScheme(.dark, for: .navigationBar)
-            .onDisappear { usernameCheckTask?.cancel() }
         }
-    }
-
-    private var usernameAccentColor: Color {
-        if usernameError != nil { return .red }
-        if usernameAvailable == true { return .green }
-        if usernameAvailable == false { return .red }
-        return Color.white.opacity(0.2)
-    }
-
-    private func validateUsername(_ newUsername: String) {
-        usernameCheckTask?.cancel()
-        usernameError = nil
-        usernameAvailable = nil
-
-        let trimmed = newUsername.trimmingCharacters(in: .whitespacesAndNewlines)
-
-        if let error = AuthService.validateUsername(trimmed) {
-            usernameError = error
-            return
         }
 
-        guard !trimmed.isEmpty else { return }
-
-        usernameCheckTask = Task {
-            try? await Task.sleep(nanoseconds: 400_000_000)
-            guard !Task.isCancelled else { return }
-
-            await MainActor.run { checkingUsername = true }
-
-            do {
-                let available = try await AuthService.checkUsernameAvailability(trimmed)
-                guard !Task.isCancelled else { return }
-                await MainActor.run {
-                    checkingUsername = false
-                    usernameAvailable = available
-                }
-            } catch {
+        private var usernameAccentColor: Color {
+            if usernameError != nil { return .red }
+            if usernameAvailable == true { return .green }
+            if usernameAvailable == false { return .red }
+            return Color.white.opacity(0.2)
+        }
+        
+        private func validateUsername(_ newUsername: String) {
+            usernameCheckTask?.cancel()
+            usernameError = nil
+            usernameAvailable = nil
+            
+            let trimmed = newUsername.trimmingCharacters(in: .whitespacesAndNewlines)
+            
+            if let error = AuthService.validateUsername(trimmed) {
+                usernameError = error
+                return
+            }
+            
+            guard !trimmed.isEmpty else { return }
+            
+            usernameCheckTask = Task {
+                try? await Task.sleep(nanoseconds: 400_000_000)
                 guard !Task.isCancelled else { return }
-                await MainActor.run {
-                    checkingUsername = false
-                    usernameError = "Unable to check username availability"
+                
+                await MainActor.run { checkingUsername = true }
+                
+                do {
+                    let available = try await AuthService.checkUsernameAvailability(trimmed)
+                    guard !Task.isCancelled else { return }
+                    await MainActor.run {
+                        checkingUsername = false
+                        usernameAvailable = available
+                    }
+                } catch {
+                    guard !Task.isCancelled else { return }
+                    await MainActor.run {
+                        checkingUsername = false
+                        usernameError = "Unable to check username availability"
+                    }
                 }
             }
         }
-    }
-
-    private func saveUsername() {
-        guard canSave, let userId = session.user?.uid else { return }
-
-        isUpdating = true
-        errorMessage = nil
-
-        let trimmedUsername = username.trimmingCharacters(in: .whitespacesAndNewlines)
-
-        Task {
-            do {
-                try await UsersService.updateProfile(
-                    uid: userId,
-                    username: trimmedUsername
-                )
-
-                await MainActor.run {
-                    isUpdating = false
-                    dismiss()
-                }
-            } catch {
-                await MainActor.run {
-                    isUpdating = false
-                    errorMessage = error.localizedDescription
+        
+        private func saveUsername() {
+            guard canSave, let userId = session.user?.uid else { return }
+            
+            isUpdating = true
+            errorMessage = nil
+            
+            let trimmedUsername = username.trimmingCharacters(in: .whitespacesAndNewlines)
+            
+            Task {
+                do {
+                    try await UsersService.updateProfile(
+                        uid: userId,
+                        username: trimmedUsername
+                    )
+                    
+                    await MainActor.run {
+                        isUpdating = false
+                        dismiss()
+                    }
+                } catch {
+                    await MainActor.run {
+                        isUpdating = false
+                        errorMessage = error.localizedDescription
+                    }
                 }
             }
         }
     }
-}
diff --git a/Buzzd/Features/Auth/AuthGate.swift b/Buzzd/Features/Auth/AuthGate.swift
index fcda6578..d935792c 100644
--- a/Buzzd/Features/Auth/AuthGate.swift
+++ b/Buzzd/Features/Auth/AuthGate.swift
@@ -9,15 +9,38 @@ struct AuthGate<Content: View>: View {
     let content: () -> Content
 
     var body: some View {
-        if session.user != nil {
+        if let u = session.user {
             // User is authenticated
-            if needsVerification {
-                VerifyEmailView()
-                    .environmentObject(session)
-            } else if needsUsername {
-                AddUsernameView()
+            // SECURITY: Enforce BOTH email verification AND profile approval before granting access
+            // Defense-in-depth: check both conditions together, not separately in if-else chain
+            let isEmailVerified = u.isEmailVerified
+            let isProfileApproved = session.userProfile?.approved == true
+            let shouldBlock = !DevSettings.skipEmailVerification && (!isEmailVerified || !isProfileApproved)
+
+            let _ = print("üîê [AuthGate] isEmailVerified: \(isEmailVerified), isProfileApproved: \(isProfileApproved), shouldBlock: \(shouldBlock)")
+
+            if shouldBlock {
+                // Avoid flashing the verification screen if the user is verified
+                // but the profile approval hasn't loaded yet. Show a brief loader
+                // until the profile snapshot arrives, then route correctly.
+                if isEmailVerified && session.userProfile == nil {
+                    ZStack {
+                        AuthBackgroundView()
+                        // Neon brand spinner while profile snapshot loads
+                        LoadingView(style: .brandSpinner, message: nil, size: 70)
+                    }
                     .environmentObject(session)
+                } else {
+                    // Block access if EITHER condition is not met:
+                    // 1. Email not verified in Firebase Auth, OR
+                    // 2. Profile not loaded or not approved in Firestore
+                    VerifyEmailView()
+                        .environmentObject(session)
+                }
             } else {
+                // Only allow access when BOTH conditions are true:
+                // 1. Email is verified (u.isEmailVerified == true)
+                // 2. Profile is loaded AND approved (session.userProfile?.approved == true)
                 content()
                     .environmentObject(session)
             }
@@ -43,18 +66,6 @@ struct AuthGate<Content: View>: View {
         }
     }
     
-    private var needsUsername: Bool {
-        guard let profile = session.userProfile else { return false }
-        return profile.username?.isEmpty ?? true
-    }
-
-    private var needsVerification: Bool {
-        guard let user = session.user else { return false }
-        // Skip verification in dev mode if enabled
-        if DevSettings.skipEmailVerification {
-            return false
-        }
-        // Gate if email not verified - automatic access once email is verified
-        return user.isEmailVerified == false
-    }
+    // Username is collected during account creation.
+    // Do not prompt again post-login; proceed as long as the account is approved.
 }
diff --git a/Buzzd/Features/Auth/AuthLandingView.swift b/Buzzd/Features/Auth/AuthLandingView.swift
index 2eafa853..4ba83ab2 100644
--- a/Buzzd/Features/Auth/AuthLandingView.swift
+++ b/Buzzd/Features/Auth/AuthLandingView.swift
@@ -10,36 +10,38 @@ struct AuthLandingView: View {
         ZStack {
             AuthBackgroundView()
 
-            ScrollView(.vertical, showsIndicators: false) {
-                VStack(spacing: 28) {
-                    Spacer(minLength: 60)
-
-                    AuthHeroView(
-                        icon: "sparkles",
-                        title: "Welcome",
-                        subtitle: "Create an account or sign in to continue"
-                    )
-
-                    AuthGlassCard {
-                        VStack(spacing: 16) {
-                            AuthPrimaryButton(
-                                title: "Create Account",
-                                icon: "person.badge.plus.fill",
-                                isLoading: false,
-                                isEnabled: true
-                            ) { goCreate = true }
-
-                            AuthSecondaryButton(title: "Sign In Instead") {
-                                goSignIn = true
+            VStack(spacing: 0) {
+                // Fixed header (not scrollable)
+                AuthHeroView(
+                    icon: "sparkles",
+                    title: "Welcome",
+                    subtitle: "Create an account or sign in to continue"
+                )
+                .padding(.top, 12)
+                .padding(.bottom, 8)
+
+                // Scrollable content
+                ScrollView(.vertical, showsIndicators: false) {
+                    VStack(spacing: 24) {
+                        AuthGlassCard {
+                            VStack(spacing: 16) {
+                                AuthPrimaryButton(
+                                    title: "Create Account",
+                                    icon: "person.badge.plus.fill",
+                                    isLoading: false,
+                                    isEnabled: true
+                                ) { goCreate = true }
+
+                                AuthSecondaryButton(title: "Sign In Instead") {
+                                    goSignIn = true
+                                }
+                                .padding(.top, 4)
                             }
-                            .padding(.top, 4)
                         }
+                        .padding(.horizontal, 24)
+                        .padding(.bottom, 16)
                     }
-                    .padding(.horizontal, 24)
-
-                    Spacer(minLength: 60)
                 }
-                .padding(.bottom, 32)
             }
         }
         .navigationBarTitleDisplayMode(.inline)
@@ -59,4 +61,3 @@ struct AuthLandingView: View {
     NavigationStack { AuthLandingView().environmentObject(UserSession()) }
         .preferredColorScheme(.dark)
 }
-
diff --git a/Buzzd/Features/Auth/Components/AuthVisuals.swift b/Buzzd/Features/Auth/Components/AuthVisuals.swift
index 35c61afc..2392a647 100644
--- a/Buzzd/Features/Auth/Components/AuthVisuals.swift
+++ b/Buzzd/Features/Auth/Components/AuthVisuals.swift
@@ -322,10 +322,11 @@ struct AuthMessageView: View {
             Text(message)
                 .font(.system(size: 14, weight: .medium))
                 .foregroundColor(Color.white.opacity(0.92))
-                .multilineTextAlignment(.leading)
+                .multilineTextAlignment(style == .info ? .center : .leading)
+                .fixedSize(horizontal: false, vertical: true)
         }
         .padding(14)
-        .frame(maxWidth: .infinity, alignment: .leading)
+        .frame(maxWidth: .infinity, alignment: style == .info ? .center : .leading)
         .background(
             style.tint.opacity(0.12)
                 .blendMode(.screen)
diff --git a/Buzzd/Features/Auth/SignInView.swift b/Buzzd/Features/Auth/SignInView.swift
index f6f22ac5..f2fc549a 100644
--- a/Buzzd/Features/Auth/SignInView.swift
+++ b/Buzzd/Features/Auth/SignInView.swift
@@ -28,22 +28,25 @@ struct SignInView: View {
         ZStack {
             AuthBackgroundView()
 
-            ScrollView(.vertical, showsIndicators: false) {
-                VStack(spacing: 28) {
-                    Spacer(minLength: 60)
-
-                    AuthHeroView(
-                        icon: "bolt.fill",
-                        title: "Welcome Back",
-                        subtitle: "Access the buzz and see what's trending tonight"
-                    )
-
-                    AuthGlassCard {
-                        VStack(spacing: 20) {
-                            InputFieldSignIn(
-                                icon: "envelope.fill",
-                                title: "Email",
-                                placeholder: "your@dukes.jmu.edu",
+            VStack(spacing: 0) {
+                // Fixed header (not scrollable)
+                AuthHeroView(
+                    icon: "bolt.fill",
+                    title: "Welcome Back",
+                    subtitle: "Access the buzz and see what's trending tonight"
+                )
+                .padding(.top, 12)
+                .padding(.bottom, 8)
+
+                // Scrollable content
+                ScrollView(.vertical, showsIndicators: false) {
+                    VStack(spacing: 24) {
+                        AuthGlassCard {
+                            VStack(spacing: 20) {
+                                InputFieldSignIn(
+                                    icon: "envelope.fill",
+                                    title: "Email",
+                                    placeholder: "your@dukes.jmu.edu",
                                 text: $email,
                                 isSecure: false,
                                 focused: $focusedField,
@@ -87,39 +90,38 @@ struct SignInView: View {
                             }
                             .padding(.top, 4)
                         }
-                    }
-                    .padding(.horizontal, 24)
-
-                    AuthGlassCard(maxWidth: 520) {
-                        VStack(spacing: 16) {
-                            Text("New around here?")
-                                .font(.system(size: 15, weight: .semibold))
-                                .foregroundColor(.white.opacity(0.9))
-
-                            Text("Use your JMU email to create an account and start exploring")
-                                .font(.footnote)
-                                .foregroundColor(.white.opacity(0.7))
-                                .multilineTextAlignment(.center)
-
-                            AuthPrimaryButton(
-                                title: "Create Account",
-                                icon: "person.badge.plus.fill",
-                                isLoading: false,
-                                isEnabled: true
-                            ) {
-                                // Prefill with normalized email if user typed it
-                                createEmail = AuthService.normalizeEmail(email)
-                                showCreate = true
+                        }
+                        .padding(.horizontal, 24)
+
+                        AuthGlassCard(maxWidth: 520) {
+                            VStack(spacing: 16) {
+                                Text("New around here?")
+                                    .font(.system(size: 15, weight: .semibold))
+                                    .foregroundColor(.white.opacity(0.9))
+
+                                Text("Use your JMU email to create an account and start exploring")
+                                    .font(.footnote)
+                                    .foregroundColor(.white.opacity(0.7))
+                                    .multilineTextAlignment(.center)
+
+                                AuthPrimaryButton(
+                                    title: "Create Account",
+                                    icon: "person.badge.plus.fill",
+                                    isLoading: false,
+                                    isEnabled: true
+                                ) {
+                                    // Prefill with normalized email if user typed it
+                                    createEmail = AuthService.normalizeEmail(email)
+                                    showCreate = true
+                                }
+                                .accessibilityLabel("Create a new account")
                             }
-                            .accessibilityLabel("Create a new account")
+                            .frame(maxWidth: .infinity)
                         }
-                        .frame(maxWidth: .infinity)
+                        .padding(.horizontal, 24)
+                        .padding(.bottom, 16)
                     }
-                    .padding(.horizontal, 24)
-
-                    Spacer(minLength: 60)
                 }
-                .padding(.bottom, 32)
             }
         }
         .navigationTitle("Sign In")
diff --git a/Buzzd/Features/Auth/VerifyEmailView.swift b/Buzzd/Features/Auth/VerifyEmailView.swift
index 0db8654c..75a4b075 100644
--- a/Buzzd/Features/Auth/VerifyEmailView.swift
+++ b/Buzzd/Features/Auth/VerifyEmailView.swift
@@ -11,22 +11,24 @@ struct VerifyEmailView: View {
     @State private var showConfirmSignOut = false
 
     @State private var didAutoSend = false
+    @State private var verificationCode = ""
+    @State private var showHelp = false
 
     var body: some View {
         ZStack {
             AuthBackgroundView()
 
-            VStack(spacing: 24) {
+            VStack(spacing: 16) {
                 Spacer(minLength: 40)
 
                 AuthHeroView(
                     icon: "envelope.badge.fill",
                     title: "Verify Your Email",
-                    subtitle: "We sent a link to confirm your JMU email"
+                    subtitle: "Enter the 6-digit code we emailed you"
                 )
 
                 AuthGlassCard(maxWidth: 520) {
-                    VStack(spacing: 16) {
+                    VStack(spacing: 12) {
                         if let email = session.user?.email {
                             Text(email)
                                 .font(.headline)
@@ -36,19 +38,67 @@ struct VerifyEmailView: View {
                         if let info { AuthMessageView(message: info, style: .info) }
                         if let error { AuthMessageView(message: error, style: .error) }
 
-                        AuthPrimaryButton(title: "Resend Verification Email", icon: "paperplane.fill", isLoading: isBusy, isEnabled: !isBusy) {
-                            Task { await resend() }
+                        // Code input field
+                        VStack(alignment: .leading, spacing: 6) {
+                            Text("Verification Code")
+                                .font(.subheadline.weight(.semibold))
+                                .foregroundColor(.white.opacity(0.9))
+
+                            TextField("Enter 6-digit code", text: $verificationCode)
+                                .textFieldStyle(PlainTextFieldStyle())
+                                .keyboardType(.numberPad)
+                                .multilineTextAlignment(.center)
+                                .font(.system(size: 24, weight: .semibold, design: .monospaced))
+                                .padding(.vertical, 10)
+                                .padding(.horizontal, 12)
+                                .background(
+                                    RoundedRectangle(cornerRadius: 12)
+                                        .fill(Color.white.opacity(0.1))
+                                        .overlay(
+                                            RoundedRectangle(cornerRadius: 12)
+                                                .stroke(Color.purple.opacity(0.5), lineWidth: 1)
+                                        )
+                                )
+                                .frame(height: 52)
+                                .foregroundColor(.white)
+                                .onChange(of: verificationCode) { newValue in
+                                    // Limit to 6 digits
+                                    if newValue.count > 6 {
+                                        verificationCode = String(newValue.prefix(6))
+                                    }
+                                    // Remove non-numeric characters
+                                    verificationCode = newValue.filter { $0.isNumber }
+                                }
                         }
+                        .padding(.top, 4)
 
-                        AuthPrimaryButton(title: "I Verified ‚Äî Continue", icon: "checkmark.seal.fill", isLoading: isBusy, isEnabled: !isBusy) {
-                            Task { await refreshAndApproveIfVerified() }
+                        AuthPrimaryButton(
+                            title: "Verify Code",
+                            icon: "checkmark.seal.fill",
+                            isLoading: isBusy,
+                            isEnabled: !isBusy && verificationCode.count == 6
+                        ) {
+                            Task { await verifyCode() }
                         }
 
-                        VStack(spacing: 12) {
-                            Text("How to verify:")
+                        VStack(spacing: 8) {
+                            Text("Didn't get the email?")
                                 .font(.subheadline.weight(.semibold))
                                 .foregroundColor(.white.opacity(0.9))
 
+                            Text("Check your junk/spam folder or click below to resend")
+                                .font(.footnote)
+                                .foregroundColor(.white.opacity(0.7))
+                                .multilineTextAlignment(.center)
+                        }
+                        .padding(.top, 2)
+
+                        AuthPrimaryButton(title: "Resend Code", icon: "paperplane.fill", isLoading: isBusy, isEnabled: !isBusy) {
+                            Task { await resend() }
+                        }
+
+                        // Collapsible help to keep the card compact
+                        DisclosureGroup(isExpanded: $showHelp) {
                             VStack(alignment: .leading, spacing: 8) {
                                 HStack(alignment: .top, spacing: 8) {
                                     Text("1.")
@@ -63,7 +113,7 @@ struct VerifyEmailView: View {
                                     Text("2.")
                                         .foregroundColor(.purple)
                                         .font(.footnote.weight(.semibold))
-                                    Text("Click the verification link - it will open in your browser")
+                                    Text("Find the 6-digit code in the email")
                                         .font(.footnote)
                                         .foregroundColor(.white.opacity(0.7))
                                 }
@@ -72,34 +122,28 @@ struct VerifyEmailView: View {
                                     Text("3.")
                                         .foregroundColor(.purple)
                                         .font(.footnote.weight(.semibold))
-                                    Text("After verifying, return to this app and tap 'I Verified'")
+                                    Text("Enter the code above and tap 'Verify Code'")
                                         .font(.footnote)
                                         .foregroundColor(.white.opacity(0.7))
                                 }
                             }
+                            .padding(.top, 4)
+                        } label: {
+                            Text("Need help verifying?")
+                                .font(.subheadline.weight(.semibold))
+                                .foregroundColor(.white.opacity(0.9))
                         }
-                        .padding(.top, 8)
 
                         Divider()
                             .overlay(Color.white.opacity(0.2))
 
-                        VStack(spacing: 10) {
-                            Text("Need to go back?")
-                                .font(.subheadline.weight(.semibold))
-                                .foregroundColor(.white.opacity(0.9))
-
-                            Text("If you used the wrong email or want to return to sign in, you can go back.")
-                                .font(.footnote)
-                                .foregroundColor(.white.opacity(0.7))
-                                .multilineTextAlignment(.center)
-
-                            AuthSecondaryButton(title: "Back to Sign In") {
-                                showConfirmSignOut = true
-                            }
-                            .padding(.top, 2)
+                        // Keep the back action minimal to save space
+                        AuthSecondaryButton(title: "Back to Sign In") {
+                            showConfirmSignOut = true
                         }
+                        .padding(.top, 2)
                     }
-                    .padding(.vertical, 8)
+                    .padding(.vertical, 6)
                 }
 
                 Spacer()
@@ -109,7 +153,7 @@ struct VerifyEmailView: View {
         .navigationBarTitleDisplayMode(.inline)
         .toolbarColorScheme(.dark, for: .navigationBar)
         .onAppear {
-            if info == nil { info = "We sent a verification email. Check inbox or spam." }
+            if info == nil { info = "We sent a 6-digit code to your email. Check inbox or spam." }
             // Auto-send the verification email once when this screen first appears
             if !didAutoSend {
                 didAutoSend = true
@@ -130,17 +174,81 @@ struct VerifyEmailView: View {
     private func resend() async {
         error = nil; info = nil; isBusy = true
         defer { isBusy = false }
-        guard let user = Auth.auth().currentUser else { return }
+        guard let user = Auth.auth().currentUser else {
+            withAnimation { self.error = "Not logged in. Please sign in first." }
+            return
+        }
+
+        print("üìß [ResendCode] Sending code to email: \(user.email ?? "unknown"), uid: \(user.uid)")
         do {
             try await sendCustomVerificationEmail(for: user)
-            withAnimation { info = "Email sent. Check inbox or spam." }
+            withAnimation { info = "Code sent. Check inbox or spam." }
+            verificationCode = "" // Clear the input field
+        } catch {
+            let desc = (error as NSError).userInfo[NSLocalizedDescriptionKey] as? String ?? error.localizedDescription
+            // Show a friendlier message for common scenarios
+            if desc.localizedCaseInsensitiveContains("already verified") {
+                withAnimation { self.info = "Already verified. Tap 'Verify Code' to continue." }
+            } else if desc.localizedCaseInsensitiveContains("invalid authentication token") {
+                withAnimation { self.error = "Session expired. Please wait a moment, then try again." }
+            } else if desc.localizedCaseInsensitiveContains("too many") {
+                withAnimation { self.error = "Too many requests. Please wait an hour and try again." }
+            } else {
+                withAnimation { self.error = "Couldn't send code. Try again soon." }
+            }
+        }
+    }
+
+    @MainActor
+    private func verifyCode() async {
+        error = nil; info = nil; isBusy = true
+        defer { isBusy = false }
+
+        guard let user = Auth.auth().currentUser, let email = user.email else {
+            withAnimation { self.error = "Not logged in. Please sign in first." }
+            return
+        }
+
+        print("üîç [VerifyCode] Attempting to verify code for email: \(email), uid: \(user.uid)")
+
+        do {
+            let success = try await verifyEmailWithCode(email: email, code: verificationCode)
+
+            if success {
+                // Refresh the user's token to get updated claims
+                try await user.getIDTokenResult(forcingRefresh: true)
+                try await user.reload()
+
+                // Attempt to claim username if needed
+                let uid = user.uid
+                do {
+                    var nameToClaim: String? = session.userProfile?.username
+                    if (nameToClaim == nil || nameToClaim?.isEmpty == true) {
+                        nameToClaim = UserDefaults.standard.string(forKey: "pending.signup.username")
+                    }
+                    if let uname = nameToClaim, !uname.isEmpty {
+                        try? await UsernameService.claimUsername(newUsername: uname, userId: uid, oldUsername: nil)
+                        UserDefaults.standard.removeObject(forKey: "pending.signup.username")
+                    }
+                } catch {
+                    print("‚ö†Ô∏è Username claim failed (non-fatal): \(error)")
+                }
+
+                withAnimation { info = "Verified! Loading your account‚Ä¶" }
+                // Small delay for UI before handing off to session
+                try? await Task.sleep(nanoseconds: 500_000_000)
+                session.user = Auth.auth().currentUser
+            } else {
+                withAnimation { self.error = "Invalid or expired code. Try again." }
+            }
         } catch {
-            withAnimation { self.error = "Couldn't send email. Try again soon." }
+            let desc = (error as NSError).userInfo[NSLocalizedDescriptionKey] as? String ?? error.localizedDescription
+            withAnimation { self.error = desc }
         }
     }
 
     private func sendCustomVerificationEmail(for user: User) async throws {
-        guard let idToken = try? await user.getIDToken() else {
+        guard let idToken = try? await user.getIDTokenResult(forcingRefresh: true).token else {
             throw NSError(domain: "VerifyEmail", code: -1, userInfo: [NSLocalizedDescriptionKey: "Could not get ID token"])
         }
 
@@ -158,37 +266,42 @@ struct VerifyEmailView: View {
         let (data, resp) = try await URLSession.shared.data(for: req)
         guard let http = resp as? HTTPURLResponse, (200..<300).contains(http.statusCode) else {
             let body = String(data: data, encoding: .utf8) ?? ""
-            throw NSError(domain: "VerifyEmail", code: -2, userInfo: [NSLocalizedDescriptionKey: "Failed to send verification email: \(body)"])
+            throw NSError(domain: "VerifyEmail", code: -2, userInfo: [NSLocalizedDescriptionKey: "Failed to send verification code: \(body)"])
         }
     }
 
-    @MainActor
-    private func refreshAndApproveIfVerified() async {
-        error = nil; info = nil; isBusy = true
-        defer { isBusy = false }
-        guard let user = Auth.auth().currentUser else { return }
-        do {
-            // Poll a few times to allow backend propagation after clicking the email link
-            // Each iteration forces token refresh and reloads the user
-            let attempts = 8
-            for i in 0..<attempts {
-                _ = try await user.getIDTokenResult(forcingRefresh: true)
-                try await user.reload()
-                if Auth.auth().currentUser?.isEmailVerified == true {
-                    try? await UsersService.recordEmailVerification(uid: user.uid)
-                    withAnimation { info = "Verified! Loading your account‚Ä¶" }
-                    // Small delay for UI before handing off to session
-                    try? await Task.sleep(nanoseconds: 300_000_000)
-                    session.user = Auth.auth().currentUser
-                    return
-                }
-                // Short backoff between checks
-                try? await Task.sleep(nanoseconds: 400_000_000)
-                if i == attempts - 1 { break }
+    private func verifyEmailWithCode(email: String, code: String) async throws -> Bool {
+        guard let url = URL(string: "https://us-central1-buzzd-app-170b4.cloudfunctions.net/verifyEmailCode") else {
+            throw NSError(domain: "VerifyEmail", code: -1, userInfo: [NSLocalizedDescriptionKey: "Bad URL"])
+        }
+
+        var req = URLRequest(url: url)
+        req.httpMethod = "POST"
+        req.addValue("application/json", forHTTPHeaderField: "Content-Type")
+        let body = ["email": email, "code": code]
+        req.httpBody = try? JSONSerialization.data(withJSONObject: body, options: [])
+
+        let (data, resp) = try await URLSession.shared.data(for: req)
+        guard let http = resp as? HTTPURLResponse else {
+            throw NSError(domain: "VerifyEmail", code: -1, userInfo: [NSLocalizedDescriptionKey: "Invalid response"])
+        }
+
+        if (200..<300).contains(http.statusCode) {
+            // Success
+            if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
+               let success = json["success"] as? Bool {
+                return success
             }
-            withAnimation { error = "Not verified yet. Wait a moment and try again." }
-        } catch {
-            withAnimation { self.error = "Verification failed. Try again or contact support." }
+            return true
+        } else {
+            // Error response - try to extract reason
+            if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
+               let reason = json["reason"] as? String {
+                throw NSError(domain: "VerifyEmail", code: http.statusCode, userInfo: [NSLocalizedDescriptionKey: reason])
+            }
+            let body = String(data: data, encoding: .utf8) ?? "Unknown error"
+            throw NSError(domain: "VerifyEmail", code: http.statusCode, userInfo: [NSLocalizedDescriptionKey: body])
         }
     }
+
 }
diff --git a/Buzzd/Features/Discover/Components/VenueCardView.swift b/Buzzd/Features/Discover/Components/VenueCardView.swift
index fb73ecc4..d46cb8db 100644
--- a/Buzzd/Features/Discover/Components/VenueCardView.swift
+++ b/Buzzd/Features/Discover/Components/VenueCardView.swift
@@ -27,7 +27,7 @@ struct VenueCardView: View {
     private let surfaceColor = Color.white.opacity(0.04)
     private let borderColor = Color.white.opacity(0.08)
     private let dividerColor = Color.white.opacity(0.12)
-    private let accentColor = Color(red: 238/255, green: 62/255, blue: 201/255)
+    private let accentColor = Color.brandPurple
 
     init(venue: NightlifeVenue, onViewDetails: @escaping (NightlifeVenue) -> Void = { _ in }) {
         self.venue = venue
@@ -83,7 +83,7 @@ struct VenueCardView: View {
                             .minimumScaleFactor(0.85)
 
                         Rectangle()
-                            .fill(accentColor.opacity(0.55))
+                            .fill(BrandColors.neonGradient)
                             .frame(width: 52, height: 2)
                     }
                     .padding(.horizontal, 14)
@@ -131,10 +131,17 @@ struct VenueCardView: View {
                     .fill(surfaceColor)
             )
             .overlay(
-                RoundedRectangle(cornerRadius: cardCorner, style: .continuous)
-                    .stroke(isHidden && session.adminMode ? Color.red.opacity(0.5) : borderColor, lineWidth: isHidden && session.adminMode ? 2 : 1)
+                Group {
+                    if isHidden && session.adminMode {
+                        RoundedRectangle(cornerRadius: cardCorner, style: .continuous)
+                            .stroke(Color.red.opacity(0.6), lineWidth: 2)
+                    } else {
+                        RoundedRectangle(cornerRadius: cardCorner, style: .continuous)
+                            .stroke(BrandColors.neonGradient, lineWidth: 1)
+                    }
+                }
             )
-            .shadow(color: .black.opacity(0.22), radius: 16, x: 0, y: 10)
+            .neonGlow(0.6)
             .opacity(isHidden && session.adminMode ? 0.7 : 1.0)
         }
         .buttonStyle(VenueCardPressStyle(cornerRadius: cardCorner))
diff --git a/Buzzd/Features/Discover/Components/VenueData.swift b/Buzzd/Features/Discover/Components/VenueData.swift
index 93e3afab..1a9c367f 100644
--- a/Buzzd/Features/Discover/Components/VenueData.swift
+++ b/Buzzd/Features/Discover/Components/VenueData.swift
@@ -27,6 +27,8 @@ struct VenueData: Identifiable, Codable {
     var address: String
     var latitude: Double
     var longitude: Double
+    /// Optional admin-set image URL to override Google photo
+    var photoURL: String? = nil
 
     // Admin-controlled data
     var coverCharge: Int = 0 // Only admin can update
@@ -49,7 +51,7 @@ struct VenueData: Identifiable, Codable {
 
     // Custom decoding to handle missing isHidden field in old documents
     enum CodingKeys: String, CodingKey {
-        case id, placeId, name, address, latitude, longitude
+        case id, placeId, name, address, latitude, longitude, photoURL
         case coverCharge, venueType, isHidden
         case currentCheckedIn, planningToGo, averageRating, totalRatings
         case lastUpdated, createdAt
@@ -62,6 +64,7 @@ struct VenueData: Identifiable, Codable {
         address = try container.decode(String.self, forKey: .address)
         latitude = try container.decode(Double.self, forKey: .latitude)
         longitude = try container.decode(Double.self, forKey: .longitude)
+        photoURL = try container.decodeIfPresent(String.self, forKey: .photoURL)
         coverCharge = try container.decodeIfPresent(Int.self, forKey: .coverCharge) ?? 0
         venueType = try container.decode(String.self, forKey: .venueType)
         isHidden = try container.decodeIfPresent(Bool.self, forKey: .isHidden) ?? false
@@ -73,7 +76,7 @@ struct VenueData: Identifiable, Codable {
         createdAt = try container.decodeIfPresent(Date.self, forKey: .createdAt) ?? Date()
     }
 
-    init(placeId: String, name: String, address: String, latitude: Double, longitude: Double, coverCharge: Int = 0, venueType: String) {
+    init(placeId: String, name: String, address: String, latitude: Double, longitude: Double, coverCharge: Int = 0, venueType: String, photoURL: String? = nil) {
         self.placeId = placeId
         self.name = name
         self.address = address
@@ -81,6 +84,7 @@ struct VenueData: Identifiable, Codable {
         self.longitude = longitude
         self.coverCharge = coverCharge
         self.venueType = venueType
+        self.photoURL = photoURL
     }
 }
 
@@ -605,9 +609,9 @@ final class VenueDataService: ObservableObject {
         // Include baseline 2.5 so early averages are not zero
         let baseline = 2.5
         let sum = ratings.reduce(0, +) + baseline
-        let count = ratings.count + 1
-        let averageRating = sum / Double(count)
-        let totalRatings = count
+        let denom = ratings.count + 1 // include baseline in average denominator only
+        let averageRating = sum / Double(denom)
+        let totalRatings = ratings.count // store actual number of user ratings
         
         try await db.collection("venues").document(venueId).updateData([
             "averageRating": averageRating,
diff --git a/Buzzd/Features/Discover/Components/VenueDetailView.swift b/Buzzd/Features/Discover/Components/VenueDetailView.swift
index 39d4ad76..85c512a9 100644
--- a/Buzzd/Features/Discover/Components/VenueDetailView.swift
+++ b/Buzzd/Features/Discover/Components/VenueDetailView.swift
@@ -7,6 +7,7 @@ import SwiftUI
 import MapKit
 import UIKit
 import FirebaseFirestore
+import Combine
 
 struct VenueDetailView: View {
     let venue: NightlifeVenue
@@ -39,6 +40,10 @@ struct VenueDetailView: View {
     @State private var averageRating: Double? = nil
     @State private var adminCover: Int = 0
     @State private var hereNowCount: Int? = nil
+    @State private var nextOpenLabel: String? = nil
+    @State private var computedIsOpenNow: Bool? = nil
+    @State private var cachedHours: OpeningHours? = nil
+    private let openStatusTimer = Timer.publish(every: 60, on: .main, in: .common).autoconnect()
 
     var body: some View {
         NavigationStack {
@@ -108,6 +113,7 @@ struct VenueDetailView: View {
             await refreshUserStatus()
             // counts come from PlacesViewModel / listeners
             await loadVenueRating()
+            await computeOpenStatusAndNextLabel()
             // Check hidden status on load
             if session.adminMode {
                 await checkIfHidden()
@@ -121,6 +127,9 @@ struct VenueDetailView: View {
             // Cancel any pending tasks when view disappears
             stopVenueListener()
         }
+        .onReceive(openStatusTimer) { _ in
+            Task { await recomputeOpenStatusTick() }
+        }
         .onChange(of: session.adminMode) { _, newValue in
             // Restart listener when admin mode changes
             if newValue {
@@ -458,7 +467,8 @@ struct VenueDetailView: View {
 
     private var additionalInfoCard: some View {
         // Precompute values OUTSIDE the ViewBuilder to avoid buildExpression errors.
-        let status = statusTextAndColor(for: venue.isOpen)
+        let effectiveOpen = computedIsOpenNow ?? venue.isOpen
+        let status = statusTextAndColor(for: effectiveOpen)
         let price = priceText(from: venue.priceLevel)
 
         return AuthGlassCard() {
@@ -469,8 +479,12 @@ struct VenueDetailView: View {
                     .labelStyle(.titleAndIcon)
 
                 VStack(spacing: 14) {
+                    // Status row: show "Closed ‚Äî Opens at 6 PM" when known
+                    let statusText = (status.text == "Closed" && nextOpenLabel != nil)
+                        ? "Closed ‚Äî Opens at \(nextOpenLabel!)"
+                        : status.text
                     detailRow(icon: "clock.fill", title: "Status",
-                              value: status.text, valueColor: status.color)
+                              value: statusText, valueColor: status.color)
 
                     detailRow(icon: "creditcard.fill", title: "Price Level",
                               value: price, valueColor: .white)
@@ -780,6 +794,87 @@ struct VenueDetailView: View {
 // MARK: - Private helpers
 
 extension VenueDetailView {
+    private func computeOpenStatusAndNextLabel() async {
+        guard let placeId = venue.placeId else { return }
+        do {
+            let svc = GooglePlacesService()
+            let details = try await svc.fetchDetailsCachedAsync(placeId: placeId)
+            let hours = details.currentOpeningHours ?? details.openingHours
+            let isOpen = GooglePlacesService.computeIsOpenNow(hours)
+            let nextLabel = Self.nextOpeningLabel(from: hours)
+            await MainActor.run {
+                self.cachedHours = hours
+                self.computedIsOpenNow = isOpen
+                self.nextOpenLabel = nextLabel
+            }
+        } catch {
+            // ignore; keep nil
+        }
+    }
+
+    private func recomputeOpenStatusTick() async {
+        if let hours = cachedHours {
+            let isOpen = GooglePlacesService.computeIsOpenNow(hours)
+            let nextLabel = Self.nextOpeningLabel(from: hours)
+            await MainActor.run {
+                self.computedIsOpenNow = isOpen
+                self.nextOpenLabel = nextLabel
+            }
+        } else {
+            await computeOpenStatusAndNextLabel()
+        }
+    }
+
+    private static func nextOpeningLabel(from hours: OpeningHours?) -> String? {
+        guard let periods = hours?.periods, !periods.isEmpty else { return nil }
+        var cal = Calendar(identifier: .gregorian)
+        cal.timeZone = TimeZone(identifier: "America/New_York") ?? .current
+        let now = Date()
+        let comps = cal.dateComponents([.weekday, .hour, .minute], from: now)
+        let gToday = ((comps.weekday ?? 1) - 1 + 7) % 7 // 0=Sun..6=Sat
+        let nowMinutes = (comps.hour ?? 0) * 60 + (comps.minute ?? 0)
+
+        func minutes(_ hhmm: String) -> Int? {
+            guard hhmm.count == 4, let hh = Int(hhmm.prefix(2)), let mm = Int(hhmm.suffix(2)) else { return nil }
+            return hh * 60 + mm
+        }
+
+        // Search next 7 days for the next opening start strictly after now
+        var bestDayOffset: Int? = nil
+        var bestMinutes: Int? = nil
+
+        for dayOffset in 0..<7 {
+            let day = (gToday + dayOffset) % 7
+            // All opening times that start this day
+            let starts = periods.compactMap { p -> Int? in
+                guard let o = p.open, o.day == day, let m = minutes(o.time) else { return nil }
+                return m
+            }.sorted()
+
+            for m in starts {
+                let isFuture = (dayOffset > 0) || (m > nowMinutes)
+                if isFuture {
+                    if bestMinutes == nil || dayOffset < bestDayOffset! || (dayOffset == bestDayOffset! && m < bestMinutes!) {
+                        bestDayOffset = dayOffset
+                        bestMinutes = m
+                    }
+                    break // earliest for this day is enough
+                }
+            }
+            if bestMinutes != nil { break }
+        }
+
+        guard let dOff = bestDayOffset, let mins = bestMinutes else { return nil }
+
+        var target = cal.startOfDay(for: now)
+        target = cal.date(byAdding: .day, value: dOff, to: target) ?? target
+        target = cal.date(byAdding: .minute, value: mins, to: target) ?? target
+
+        let fmt = DateFormatter()
+        fmt.timeZone = cal.timeZone
+        fmt.dateFormat = dOff == 0 ? "h:mm a" : "EEE h:mm a"
+        return fmt.string(from: target)
+    }
     private var isPlanMode: Bool {
         if userStatus == .checkedIn { return false }
         return VenueDisplayHelper.currentDisplayInfo.isPlanMode
@@ -980,11 +1075,17 @@ extension VenueDetailView {
                 userStatus = .checkedIn
                 hasCheckedIn = true
                 showingCheckInSuccess = true
-                displayCount = max(0, displayCount + 1)
-                // Optimistically bump the here-now counter in plan mode
-                hereNowCount = max(0, (hereNowCount ?? 0) + 1)
-                PlacesViewModel.shared.bumpVenueCount(for: venueId, delta: 1)
-                VenueDataService.shared.setLocalDisplayOverride(venueId: venueId, value: displayCount)
+
+                // In plan mode: ONLY update hereNowCount (small text under stats)
+                // Do NOT update displayCount or PlacesViewModel since those show plan count
+                if isPlanMode {
+                    hereNowCount = max(0, (hereNowCount ?? 0) + 1)
+                } else {
+                    // After 7pm: update displayCount and PlacesViewModel normally
+                    displayCount = max(0, displayCount + 1)
+                    PlacesViewModel.shared.bumpVenueCount(for: venueId, delta: 1)
+                    VenueDataService.shared.setLocalDisplayOverride(venueId: venueId, value: displayCount)
+                }
             }
             await refreshUserStatus()
         } catch let venueError as VenueError {
@@ -1021,12 +1122,16 @@ extension VenueDetailView {
                 showingCheckInSuccess = false
                 // Only decrement if we actually transitioned away from checked-in
                 if prevStatus == .checkedIn && userStatus != .checkedIn {
-                    displayCount = max(0, displayCount - 1)
+                    // In plan mode: ONLY decrement hereNowCount (small text under stats)
+                    // Do NOT update displayCount or PlacesViewModel since those show plan count
                     if isPlanMode {
                         hereNowCount = max(0, (hereNowCount ?? 0) - 1)
+                    } else {
+                        // After 7pm: update displayCount and PlacesViewModel normally
+                        displayCount = max(0, displayCount - 1)
+                        if let vid = venue.placeId { PlacesViewModel.shared.bumpVenueCount(for: vid, delta: -1) }
+                        if let vid = venue.placeId { VenueDataService.shared.setLocalDisplayOverride(venueId: vid, value: displayCount) }
                     }
-                    if let vid = venue.placeId { PlacesViewModel.shared.bumpVenueCount(for: vid, delta: -1) }
-                    if let vid = venue.placeId { VenueDataService.shared.setLocalDisplayOverride(venueId: vid, value: displayCount) }
                 }
             }
         } catch let venueError as VenueError {
diff --git a/Buzzd/Features/Discover/DiscoverView.swift b/Buzzd/Features/Discover/DiscoverView.swift
index e85c72b0..86e9c454 100644
--- a/Buzzd/Features/Discover/DiscoverView.swift
+++ b/Buzzd/Features/Discover/DiscoverView.swift
@@ -12,15 +12,7 @@ struct DiscoverView: View {
     @StateObject private var placesViewModel = PlacesViewModel.shared
     @EnvironmentObject private var session: UserSession
     private let tabBarGuard: CGFloat = 94  // space reserved for the Tab Bar
-    private let surfaceColor = Color(red: 36/255, green: 28/255, blue: 64/255)
-    private let gradientBackground = LinearGradient(
-        gradient: Gradient(colors: [
-            Color(red: 10/255, green: 2/255, blue: 26/255),
-            Color(red: 46/255, green: 9/255, blue: 64/255)
-        ]),
-        startPoint: .topLeading,
-        endPoint: .bottomTrailing
-    )
+    private let surfaceColor = Color.white.opacity(0.08)
 
 
     // Search
@@ -46,7 +38,7 @@ struct DiscoverView: View {
     var body: some View {
         NavigationStack {
             ZStack {
-                gradientBackground
+                BrandColors.appBackground
                     .ignoresSafeArea()
                 NoiseOverlayView()
                     .ignoresSafeArea()
@@ -59,6 +51,8 @@ struct DiscoverView: View {
                         searchBarView
                             .padding(.horizontal, 20)
 
+                        // Weekend Recap banner removed
+
                         if let error = placesViewModel.errorMessage, !error.isEmpty {
                             Text(error)
                                 .font(.footnote)
@@ -158,13 +152,7 @@ struct DiscoverView: View {
                     // Gradient BUZZD text
                     Text("BUZZD")
                         .font(.title).fontWeight(.bold)
-                        .foregroundStyle(
-                            LinearGradient(
-                                colors: [Color.purple, Color.pink],
-                                startPoint: .leading,
-                                endPoint: .trailing
-                            )
-                        )
+                        .foregroundStyle(BrandColors.neonGradient)
                 }
                 .alignmentGuide(.firstTextBaseline) { d in d[.bottom] } // Align to baseline
 
@@ -261,6 +249,13 @@ struct DiscoverView: View {
                         .frame(maxWidth: 420)
                         .frame(maxWidth: .infinity, alignment: .center)
                     }
+
+                    // Load More button
+                    if placesViewModel.hasMoreVenues {
+                        loadMoreButton
+                            .frame(maxWidth: 420)
+                            .frame(maxWidth: .infinity, alignment: .center)
+                    }
                 }
                 .padding(.horizontal, 20)
             }
@@ -269,6 +264,35 @@ struct DiscoverView: View {
         .animation(.easeInOut(duration: 0.2), value: filteredAndSortedVenues.count)
     }
 
+    // MARK: - Load More Button
+    private var loadMoreButton: some View {
+        Button {
+            placesViewModel.loadMoreVenues()
+        } label: {
+            HStack(spacing: 8) {
+                if placesViewModel.isLoadingMore {
+                    ProgressView()
+                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
+                        .scaleEffect(0.8)
+                    Text("Loading...")
+                        .font(.subheadline.weight(.medium))
+                } else {
+                    Image(systemName: "arrow.down.circle")
+                        .font(.system(size: 16, weight: .semibold))
+                    Text("Load More Venues")
+                        .font(.subheadline.weight(.medium))
+                }
+            }
+            .foregroundColor(.white)
+            .frame(maxWidth: .infinity)
+            .padding(.vertical, 14)
+            .background(Color.white.opacity(0.06), in: RoundedRectangle(cornerRadius: 12, style: .continuous))
+            .neonBorder(cornerRadius: 12, lineWidth: 1)
+        }
+        .buttonStyle(.plain)
+        .disabled(placesViewModel.isLoadingMore)
+    }
+
     private var loadingView: some View {
         VStack(spacing: 12) {
             ProgressView()
diff --git a/Buzzd/Features/Events/Components/EventFormView.swift b/Buzzd/Features/Events/Components/EventFormView.swift
index 8c287b56..e8079647 100644
--- a/Buzzd/Features/Events/Components/EventFormView.swift
+++ b/Buzzd/Features/Events/Components/EventFormView.swift
@@ -10,6 +10,7 @@ struct EventDraft {
     var date: Date = Calendar.current.date(bySettingHour: 21, minute: 0, second: 0, of: Date()) ?? Date()
     var type: EventType = .house
     var description: String = ""
+    var isPrivate: Bool = false
     
     // Ticketing fields (if needed)
     var sellingTickets: Bool = false
@@ -73,6 +74,14 @@ struct EventFormView: View {
                     .pickerStyle(.segmented)
                 }
 
+                Section("Privacy") {
+                    Toggle("Private Event", isOn: $draft.isPrivate)
+                        .tint(.accentColor)
+                    Text("Private events are not shown on the map and are only accessible via a direct link.")
+                        .font(.caption)
+                        .foregroundStyle(.secondary)
+                }
+
                 Section("Description") {
                     TextEditor(text: $draft.description)
                         .frame(minHeight: 120)
@@ -157,6 +166,7 @@ struct EventFormView: View {
                 ticketQuantityTotal: draft.sellingTickets ? Int(draft.ticketQuantity) : nil,
                 ticketQuantitySold: 0,
                 stripeAccountId: nil,
+                visibility: draft.isPrivate ? "private" : "public",
                 createdAt: Date(),
                 updatedAt: Date()
             )
diff --git a/Buzzd/Features/Events/Models/BuzzdEvent.swift b/Buzzd/Features/Events/Models/BuzzdEvent.swift
index d830da04..0d82ef17 100644
--- a/Buzzd/Features/Events/Models/BuzzdEvent.swift
+++ b/Buzzd/Features/Events/Models/BuzzdEvent.swift
@@ -102,6 +102,10 @@ struct BuzzdEvent: Identifiable, Codable, Equatable, Hashable {
     var createdAt: Date
     var updatedAt: Date
     
+    // Social features
+    var visibility: String = "public" // "public" or "private"
+    var guestList: [String] = []      // List of user IDs
+    
     // MARK: - Computed Properties
     
     var coordinate: CLLocationCoordinate2D? {
@@ -172,6 +176,8 @@ struct BuzzdEvent: Identifiable, Codable, Equatable, Hashable {
         stripeAccountId: String? = nil,
         ratingAverage: Double? = nil,
         ratingCount: Int? = nil,
+        visibility: String = "public",
+        guestList: [String] = [],
         createdAt: Date = Date(),
         updatedAt: Date = Date()
     ) {
@@ -195,6 +201,8 @@ struct BuzzdEvent: Identifiable, Codable, Equatable, Hashable {
         self.stripeAccountId = stripeAccountId
         self.ratingAverage = ratingAverage
         self.ratingCount = ratingCount
+        self.visibility = visibility
+        self.guestList = guestList
         self.createdAt = createdAt
         self.updatedAt = updatedAt
     }
diff --git a/Buzzd/Features/Events/Services/EventService.swift b/Buzzd/Features/Events/Services/EventService.swift
index 0fe1ceb6..1735c300 100644
--- a/Buzzd/Features/Events/Services/EventService.swift
+++ b/Buzzd/Features/Events/Services/EventService.swift
@@ -40,6 +40,7 @@ final class EventService: ObservableObject {
 
         let now = Timestamp(date: Date())
         eventsListener = db.collection("events")
+            .whereField("visibility", isEqualTo: "public")
             .whereField("endsAt", isGreaterThan: now)
             // Firestore requires ordering by the inequality field first
             .order(by: "endsAt", descending: false)
@@ -135,8 +136,9 @@ final class EventService: ObservableObject {
         
         try validateEvent(updatedEvent)
         
-        let eventData = encodeEvent(updatedEvent)
-        try await db.collection("events").document(eventId).setData(eventData, merge: true)
+        let diffData = await encodeEventUpdate(originalId: eventId, updated: updatedEvent)
+        if diffData.isEmpty { return }
+        try await db.collection("events").document(eventId).updateData(diffData)
     }
     
     func fetchEvent(id: String) async throws -> BuzzdEvent {
@@ -227,6 +229,8 @@ final class EventService: ObservableObject {
             "eventType": event.eventType.rawValue,  // Store as string
             "sellingTickets": event.sellingTickets,
             "ticketQuantitySold": event.ticketQuantitySold,
+            "visibility": event.visibility,
+            "guestList": event.guestList,
             "createdAt": Timestamp(date: event.createdAt),
             "updatedAt": Timestamp(date: event.updatedAt)
         ]
@@ -257,6 +261,45 @@ final class EventService: ObservableObject {
         return data
     }
     
+    /// Minimal update payload to avoid tripping rules (createdAt/hostUserId immutability).
+    private func encodeEventUpdate(originalId: String, updated: BuzzdEvent) async -> [String: Any] {
+        // Fetch the current snapshot to compute a safe diff client-side
+        // If this fails, fall back to conservative set of fields from `updated`.
+        var current: [String: Any] = [:]
+        if let doc = try? await db.collection("events").document(originalId).getDocument(),
+           let data = doc.data() {
+            current = data
+        }
+        
+        func same(_ key: String, _ value: Any?) -> Bool {
+            guard let value = value else { return (current[key] == nil) }
+            if let ts = value as? Timestamp, let cur = current[key] as? Timestamp { return ts == cur }
+            if let d = value as? Date, let cur = current[key] as? Timestamp { return Timestamp(date: d) == cur }
+            if let s = value as? String, let cur = current[key] as? String { return s == cur }
+            if let b = value as? Bool, let cur = current[key] as? Bool { return b == cur }
+            if let i = value as? Int, let cur = current[key] as? Int { return i == cur }
+            if let dbl = value as? Double, let cur = current[key] as? Double { return dbl == cur }
+            return false
+        }
+        
+        var out: [String: Any] = [:]
+        // Only allow editing these fields from the client
+        let newStarts = Timestamp(date: updated.startsAt)
+        if !same("title", updated.title) { out["title"] = updated.title }
+        if !same("description", updated.description) { out["description"] = updated.description }
+        if !same("startsAt", newStarts) { out["startsAt"] = newStarts }
+        let newEnds = Timestamp(date: (updated.endsAt ?? updated.startsAt.addingTimeInterval(6 * 3600)))
+        if !same("endsAt", newEnds) { out["endsAt"] = newEnds }
+        if !same("address", updated.address) { out["address"] = updated.address }
+        if let lat = updated.latitude, !same("latitude", lat) { out["latitude"] = lat } else if updated.latitude == nil, current["latitude"] != nil { out["latitude"] = FieldValue.delete() }
+        if let lon = updated.longitude, !same("longitude", lon) { out["longitude"] = lon } else if updated.longitude == nil, current["longitude"] != nil { out["longitude"] = FieldValue.delete() }
+        
+        // Always bump updatedAt
+        out["updatedAt"] = Timestamp(date: updated.updatedAt)
+        
+        return out
+    }
+    
     private func decodeEvent(from document: DocumentSnapshot) -> BuzzdEvent? {
         // Decode base event
         guard var ev = try? document.data(as: BuzzdEvent.self) else { return nil }
diff --git a/Buzzd/Features/Events/Views/CreateEventView.swift b/Buzzd/Features/Events/Views/CreateEventView.swift
index d1b78c14..a95d563f 100644
--- a/Buzzd/Features/Events/Views/CreateEventView.swift
+++ b/Buzzd/Features/Events/Views/CreateEventView.swift
@@ -451,6 +451,9 @@ struct CreateEventView: View {
                 latitude: $latitude,
                 longitude: $longitude
             )
+            Text("Tip: If you want to announce the address later, enter something like 'Announcing soon!' now and edit the event on the day of.")
+                .font(.caption)
+                .foregroundColor(.white.opacity(0.6))
         }
     }
     
@@ -1264,6 +1267,12 @@ struct CreateEventView: View {
             let cents: Int? = sellingTickets ? Self.cents(from: ticketPrice) : nil
             let qty: Int? = sellingTickets ? Int(ticketQuantity) : nil
 
+            // If the address looks like a placeholder, drop coordinates to avoid showing directions
+            let addrLower = address.lowercased()
+            let looksPlaceholder = addrLower.contains("announce") || addrLower.contains("tba") || addrLower.rangeOfCharacter(from: CharacterSet.decimalDigits) == nil
+            let latToSave = looksPlaceholder ? nil : latitude
+            let lonToSave = looksPlaceholder ? nil : longitude
+
             let event = BuzzdEvent(
                 id: nil,
                 hostUserId: hostUserId,
@@ -1275,8 +1284,8 @@ struct CreateEventView: View {
                 endsAt: endsAt,
                 address: address,
                 eventType: eventType,
-                latitude: latitude,
-                longitude: longitude,
+                latitude: latToSave,
+                longitude: lonToSave,
                 flyerURL: flyerURL,
                 sellingTickets: sellingTickets,
                 ticketPriceCents: cents,
diff --git a/Buzzd/Features/Events/Views/EventDetailView.swift b/Buzzd/Features/Events/Views/EventDetailView.swift
index ff3b0c12..a8fe405c 100644
--- a/Buzzd/Features/Events/Views/EventDetailView.swift
+++ b/Buzzd/Features/Events/Views/EventDetailView.swift
@@ -21,10 +21,18 @@ struct EventDetailView: View {
     @State private var isPresentingQuickPay = false
     @State private var showReportSheet = false
     @State private var showRatings = false
+    @State private var showEditSheet = false
     @State private var deleteArmed = false // deprecated by confirm sheet, kept to avoid breakage during transition
     @State private var showDeleteSheet = false
     @State private var deleteStep: Int = 0
+    @State private var isGoing = false
     private let tabBarGuard: CGFloat = 94
+    // Constant hero height to prevent layout jumps during image load
+    private var heroHeight: CGFloat {
+        let w = UIScreen.main.bounds.width
+        // Wider screens -> taller hero, but clamp to a comfortable range
+        return min(max(w * 0.9, 360), 520)
+    }
 
     var body: some View {
         ScrollView(showsIndicators: false) {
@@ -70,6 +78,12 @@ struct EventDetailView: View {
                         Image(systemName: "barcode.viewfinder").foregroundColor(.white)
                     }
                 }
+                ToolbarItem(placement: .topBarTrailing) {
+                    Button { showEditSheet = true } label: {
+                        Image(systemName: "pencil").foregroundColor(.white)
+                    }
+                    .accessibilityLabel("Edit Event")
+                }
             }
             ToolbarItem(placement: .topBarTrailing) {
                 Button { shareEvent() } label: {
@@ -90,6 +104,11 @@ struct EventDetailView: View {
         .sheet(isPresented: $presentScanner) {
             if let eid = event.id { HostScanView(eventId: eid) }
         }
+        .sheet(isPresented: $showEditSheet) {
+            EditEventView(event: event) { _ in
+                // No-op here; list listener will reflect changes elsewhere
+            }
+        }
         .sheet(isPresented: $showMyTickets) {
             TicketSheetView(tickets: myTickets, eventTitle: event.title, eventId: event.id ?? "")
         }
@@ -108,28 +127,78 @@ struct EventDetailView: View {
             FullScreenImageView(urlString: event.flyerURL)
         }
         .task {
-            await loadMyTickets()
-            await loadAttendees()
-            await loadOrgState()
+            // Run initial loads concurrently for faster first paint
+            async let t1: Void = loadMyTickets()
+            async let t2: Void = loadAttendees()
+            async let t3: Void = loadOrgState()
+            checkGoingStatus()
+            _ = await (t1, t2, t3)
         }
     }
 
+    private func toggleGoingStatus() {
+        guard let userId = Auth.auth().currentUser?.uid, let eventId = event.id else { return }
+        let db = Firestore.firestore()
+        let eventRef = db.collection("events").document(eventId)
+
+        if isGoing {
+            // Remove user from guest list
+            eventRef.updateData([
+                "guestList": FieldValue.arrayRemove([userId])
+            ]) { error in
+                if let error = error {
+                    print("Error removing user from guest list: \(error)")
+                } else {
+                    isGoing = false
+                }
+            }
+        } else {
+            // Add user to guest list
+            eventRef.updateData([
+                "guestList": FieldValue.arrayUnion([userId])
+            ]) { error in
+                if let error = error {
+                    print("Error adding user to guest list: \(error)")
+                } else {
+                    isGoing = true
+                }
+            }
+        }
+    }
+
+    private func checkGoingStatus() {
+        guard let userId = Auth.auth().currentUser?.uid else { return }
+        isGoing = event.guestList.contains(userId)
+    }
+
     private var headerHero: some View {
         ZStack(alignment: .bottomLeading) {
-            // Keep hero image constrained to a fixed height with fill + clip
-            AsyncImage(url: URL(string: event.flyerURL ?? "")) { phase in
-                switch phase {
-                case .success(let image):
-                    image
-                        .resizable()
-                        .aspectRatio(16/9, contentMode: .fill)
-                        .frame(maxWidth: .infinity)
-                        .clipped()
-                        .contentShape(Rectangle())
-                        .onTapGesture { showFullFlyer = true }
-                default:
-                    Color.black.opacity(0.2)
-                        .aspectRatio(16/9, contentMode: .fill)
+            // Stable hero: fits whole image (no distortion) with a constant height to avoid flicker
+            ZStack {
+                AsyncImage(url: URL(string: event.flyerURL ?? "")) { phase in
+                    switch phase {
+                    case .success(let image):
+                        image
+                            .resizable()
+                            .scaledToFit()
+                            .frame(maxWidth: .infinity)
+                            .frame(height: heroHeight)
+                            .background(Color.black.opacity(0.15)) // letterbox for extreme ratios
+                            .contentShape(Rectangle())
+                            .onTapGesture { showFullFlyer = true }
+                    case .empty:
+                        Color.black.opacity(0.2)
+                            .frame(maxWidth: .infinity)
+                            .frame(height: heroHeight)
+                    case .failure:
+                        Color.black.opacity(0.2)
+                            .frame(maxWidth: .infinity)
+                            .frame(height: heroHeight)
+                    @unknown default:
+                        Color.black.opacity(0.2)
+                            .frame(maxWidth: .infinity)
+                            .frame(height: heroHeight)
+                    }
                 }
             }
             .overlay(
@@ -210,6 +279,7 @@ struct EventDetailView: View {
             VStack(alignment: .leading, spacing: 14) {
                 iconRow(system: "calendar", title: "When", value: Self.timeRangeString(start: event.startsAt, end: event.endsAt))
                 Divider().opacity(0.15)
+                let hasCoords = (event.latitude != nil && event.longitude != nil)
                 let directions = AnyView(
                     Button("Directions") { openDirections() }
                         .font(.caption)
@@ -218,7 +288,7 @@ struct EventDetailView: View {
                         .background(Color.white.opacity(0.12))
                         .clipShape(RoundedRectangle(cornerRadius: 8))
                 )
-                iconRow(system: "mappin.and.ellipse", title: "Where", value: event.address, trailing: { directions })
+                iconRow(system: "mappin.and.ellipse", title: "Where", value: event.address, trailing: hasCoords ? { directions } : nil)
                 Divider().opacity(0.15)
                 HStack(alignment: .center, spacing: 12) {
                     Image(systemName: "person.fill")
@@ -265,8 +335,36 @@ struct EventDetailView: View {
                 }
             }
             .padding(16)
-            .background(Color.white.opacity(0.06))
+            .background(Color.black.opacity(0.65))
             .clipShape(RoundedRectangle(cornerRadius: 14))
+            .neonBorder(cornerRadius: 14, lineWidth: 1)
+            .padding(.horizontal, 16)
+
+            // "Going" Button
+            VStack {
+                if event.isPast {
+                    Text("This event has ended")
+                        .font(.subheadline)
+                        .foregroundColor(.secondary)
+                        .padding()
+                        .frame(maxWidth: .infinity)
+                        .background(Color.white.opacity(0.05))
+                        .clipShape(RoundedRectangle(cornerRadius: 14))
+                } else {
+                    Button(action: toggleGoingStatus) {
+                        HStack {
+                            Image(systemName: isGoing ? "checkmark.circle.fill" : "calendar.badge.plus")
+                            Text(isGoing ? "You're Going!" : "I'm Going")
+                                .fontWeight(.semibold)
+                        }
+                        .frame(maxWidth: .infinity)
+                        .padding()
+                        .background(Color.green)
+                        .foregroundColor(.white)
+                        .clipShape(RoundedRectangle(cornerRadius: 14))
+                    }
+                }
+            }
             .padding(.horizontal, 16)
 
             // Description
@@ -282,8 +380,9 @@ struct EventDetailView: View {
                 }
                 .frame(maxWidth: .infinity, alignment: .leading)
                 .padding(16)
-                .background(Color.white.opacity(0.05))
+                .background(Color.black.opacity(0.65))
                 .clipShape(RoundedRectangle(cornerRadius: 14))
+                .neonBorder(cornerRadius: 14, lineWidth: 1)
                 .padding(.horizontal, 16)
             }
 
@@ -319,8 +418,9 @@ struct EventDetailView: View {
                     }
                 }
                 .padding(16)
-                .background(Color.white.opacity(0.05))
+                .background(Color.black.opacity(0.65))
                 .clipShape(RoundedRectangle(cornerRadius: 14))
+                .neonBorder(cornerRadius: 14, lineWidth: 1)
                 .padding(.horizontal, 16)
             }
 
@@ -360,8 +460,9 @@ struct EventDetailView: View {
                         .frame(maxWidth: .infinity)
                         .padding(.vertical, 12)
                         .foregroundColor(.white)
-                        .background(Color.white.opacity(0.12))
+                        .background(Color.black.opacity(0.65))
                         .clipShape(RoundedRectangle(cornerRadius: 12))
+                        .neonBorder(cornerRadius: 12, lineWidth: 1)
                     }
                     .disabled(event.availableTickets == 0)
 
@@ -388,12 +489,19 @@ struct EventDetailView: View {
                     .frame(maxWidth: .infinity)
                     .padding(.vertical, 12)
                     .padding(.horizontal, 16)
-                    .background(event.isLive ? Color.green.opacity(0.2) : Color.white.opacity(0.08))
+                    .background(Color.black.opacity(0.65))
                     .clipShape(RoundedRectangle(cornerRadius: 12))
                     .foregroundColor(.white)
                     .overlay(
-                        RoundedRectangle(cornerRadius: 12)
-                            .stroke(event.isLive ? Color.green.opacity(0.4) : Color.white.opacity(0.1), lineWidth: 1)
+                        Group {
+                            if event.isLive {
+                                RoundedRectangle(cornerRadius: 12)
+                                    .stroke(Color.green.opacity(0.4), lineWidth: 1)
+                            } else {
+                                RoundedRectangle(cornerRadius: 12)
+                                    .stroke(BrandColors.neonGradient, lineWidth: 1)
+                            }
+                        }
                     )
                 }
                 .padding(.horizontal, 16)
@@ -440,8 +548,9 @@ struct EventDetailView: View {
                     }
                 }
                 .padding(16)
-                .background(Color.white.opacity(0.05))
+                .background(Color.black.opacity(0.65))
                 .clipShape(RoundedRectangle(cornerRadius: 14))
+                .neonBorder(cornerRadius: 14, lineWidth: 1)
                 .padding(.horizontal, 16)
             }
 
@@ -579,6 +688,9 @@ struct EventDetailView: View {
     }
 }
 
+// MARK: - Helpers
+private extension EventDetailView {}
+
 // MARK: - Delete Confirm Sheet
 private struct DeleteEventConfirmSheet: View {
     @Binding var step: Int
@@ -782,17 +894,67 @@ private extension EventDetailView {
     }
 
     func loadAttendees() async {
-        guard let id = event.id else { return }
+        guard !event.guestList.isEmpty else { return }
+
         do {
             let db = Firestore.firestore()
-            let snap = try await db.collection("tickets").whereField("eventId", isEqualTo: id).limit(to: 50).getDocuments()
-            let purchaserIds = Array(Set(snap.documents.compactMap { $0.data()["purchaserId"] as? String }))
-            var users: [UserProfile] = []
-            for uid in purchaserIds.prefix(50) {
-                let doc = try await db.collection("users").document(uid).getDocument()
-                if let profile = try? doc.data(as: UserProfile.self) { users.append(profile) }
+            let userIds = event.guestList
+            
+            // 1) Immediately show lightweight stubs for snappy UI
+            var stubs: [UserProfile] = []
+            stubs.reserveCapacity(userIds.count)
+            for uid in userIds {
+                var stub = UserProfile(email: "", name: "Guest", avatarURL: nil, createdAt: Date(), status: "active", approved: true)
+                stub.id = uid
+                stubs.append(stub)
             }
-            await MainActor.run { self.attendees = users }
+            await MainActor.run { self.attendees = stubs }
+
+            // 2) Fetch real profiles in efficient chunks using `in` queries (up to 10 IDs per query)
+            let chunkSize = 10
+            var chunks: [[String]] = []
+            var idx = 0
+            while idx < userIds.count {
+                let end = min(idx + chunkSize, userIds.count)
+                chunks.append(Array(userIds[idx..<end]))
+                idx = end
+            }
+
+            // Fetch chunks in parallel
+            var fetched: [String: UserProfile] = [:]
+            try await withThrowingTaskGroup(of: [(String, UserProfile)].self) { group in
+                for batch in chunks {
+                    group.addTask {
+                        let qs = try await db.collection("users")
+                            .whereField(FieldPath.documentID(), in: batch)
+                            .getDocuments()
+                        var result: [(String, UserProfile)] = []
+                        for doc in qs.documents {
+                            let profile = try doc.data(as: UserProfile.self)
+                            let uid = doc.documentID
+                            result.append((uid, profile))
+                        }
+                        return result
+                    }
+                }
+                for try await pairs in group {
+                    for (uid, profile) in pairs { fetched[uid] = profile }
+                }
+            }
+
+            // 3) Merge fetched profiles back into current list preserving order
+            var merged: [UserProfile] = []
+            merged.reserveCapacity(stubs.count)
+            for uid in userIds {
+                if let p = fetched[uid] {
+                    merged.append(p)
+                } else {
+                    if let existing = stubs.first(where: { $0.id == uid }) {
+                        merged.append(existing)
+                    }
+                }
+            }
+            await MainActor.run { self.attendees = merged }
         } catch {}
     }
 
@@ -820,9 +982,9 @@ private extension EventDetailView {
 
     func shareEvent() {
         // Share website link so friends can buy without the app
-        let web = event.id.map { "https://joinbuzzd.app/event?id=\($0)" } ?? "https://joinbuzzd.app"
+        let web = event.id.map { "https://joinbuzzd.app/event/\($0)" } ?? "https://joinbuzzd.app"
         let when = EventFeedCardView.timeString(event.startsAt)
-        let text = "\(event.title)\n\(when)\n\(event.address)\nBuy tickets: \(web)"
+        let text = "\(event.title)\n\(when)\n\(event.address)\nJoin the event: \(web)"
         let sheet = ShareToChatSheet(shareText: text)
         let host = UIHostingController(rootView: sheet)
         host.modalPresentationStyle = .formSheet
@@ -833,7 +995,12 @@ private extension EventDetailView {
     }
 
     func openDirections() {
-        // Use Apple Maps URL to avoid adding MapKit dependency
+        // Prefer coordinates when available; fallback to address string
+        if let lat = event.latitude, let lon = event.longitude,
+           let url = URL(string: "http://maps.apple.com/?daddr=\(lat),\(lon)&dirflg=d") {
+            UIApplication.shared.open(url)
+            return
+        }
         let encoded = event.address.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? ""
         if let url = URL(string: "http://maps.apple.com/?q=\(encoded)") {
             UIApplication.shared.open(url)
diff --git a/Buzzd/Features/Events/Views/EventFeedCardView.swift b/Buzzd/Features/Events/Views/EventFeedCardView.swift
index ad24229d..702424a1 100644
--- a/Buzzd/Features/Events/Views/EventFeedCardView.swift
+++ b/Buzzd/Features/Events/Views/EventFeedCardView.swift
@@ -86,14 +86,7 @@ struct EventFeedCardView: View {
                     // Avatar with glow ring
                     ZStack {
                         Circle()
-                            .stroke(
-                                LinearGradient(
-                                    colors: [.purple.opacity(0.8), .pink.opacity(0.8)],
-                                    startPoint: .topLeading,
-                                    endPoint: .bottomTrailing
-                                ),
-                                lineWidth: 1.5
-                            )
+                            .stroke(BrandColors.neonGradient, lineWidth: 1.5)
                             .frame(width: 26, height: 26)
                             .blur(radius: glowAnimation ? 2 : 0.5)
                             .opacity(glowAnimation ? 0.6 : 0.3)
@@ -284,30 +277,12 @@ struct EventFeedCardView: View {
         .overlay(
             // Full border with varying intensity
             RoundedRectangle(cornerRadius: corner, style: .continuous)
-                .strokeBorder(
-                    LinearGradient(
-                        colors: [
-                            // Top - subtle
-                            .white.opacity(0.1),
-                            .purple.opacity(0.15),
-                            // Sides - subtle
-                            .pink.opacity(0.15),
-                            .white.opacity(0.1),
-                            // Bottom - stronger
-                            .purple.opacity(0.4),
-                            .pink.opacity(0.4),
-                            .white.opacity(0.3)
-                        ],
-                        startPoint: .top,
-                        endPoint: .bottom
-                    ),
-                    lineWidth: 1
-                )
-                .opacity(0.9)
+                .stroke(BrandColors.neonGradient, lineWidth: 1)
+                .opacity(0.95)
         )
         .clipShape(RoundedRectangle(cornerRadius: corner, style: .continuous))
         .shadow(color: .black.opacity(0.6), radius: 15, x: 0, y: 8)
-        .shadow(color: .purple.opacity(0.15), radius: 25, x: 0, y: 12)
+        .shadow(color: BrandColors.glow, radius: 25, x: 0, y: 12)
         .contentShape(Rectangle())
         .onAppear {
             // Gradient animation
diff --git a/Buzzd/Features/Events/Views/EventsView.swift b/Buzzd/Features/Events/Views/EventsView.swift
index 164688ce..399d1e04 100644
--- a/Buzzd/Features/Events/Views/EventsView.swift
+++ b/Buzzd/Features/Events/Views/EventsView.swift
@@ -5,6 +5,7 @@ struct EventsView: View {
     @State private var presentCreate = false
     @State private var deepLinkEvent: BuzzdEvent? = nil
     @State private var navPath = NavigationPath()
+    @State private var lastOpenedEventId: String? = nil
     // Removed "My Tickets" shortcut per request
 
     private let tabBarGuard: CGFloat = 94
@@ -36,9 +37,13 @@ struct EventsView: View {
             guard let eventId = (note.userInfo?["eventId"] as? String)?.trimmingCharacters(in: .whitespacesAndNewlines), !eventId.isEmpty else { return }
             Task { @MainActor in
                 do {
+                    if lastOpenedEventId == eventId { return }
                     let ev = try await EventService.shared.fetchEvent(id: eventId)
                     // Push programmatically using NavigationPath (iOS 16 compatible)
                     navPath.append(ev)
+                    lastOpenedEventId = eventId
+                    // Reset dedupe after a short delay to allow re-opening later if needed
+                    DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) { lastOpenedEventId = nil }
                 } catch {
                     print("Failed to open event for id \(eventId): \(error)")
                 }
diff --git a/Buzzd/Features/Filters/Components/FilterChipView.swift b/Buzzd/Features/Filters/Components/FilterChipView.swift
index b86ef52a..c88035c3 100644
--- a/Buzzd/Features/Filters/Components/FilterChipView.swift
+++ b/Buzzd/Features/Filters/Components/FilterChipView.swift
@@ -33,12 +33,13 @@ struct FilterChipView: View {
             .padding(.horizontal, 8)
             .background(
                 RoundedRectangle(cornerRadius: 8)
-                    .fill(isSelected ? Color.purple.opacity(0.6) : Color.white.opacity(0.1))
+                    .fill(Color.black.opacity(0.6))
             )
             .overlay(
                 RoundedRectangle(cornerRadius: 8)
-                    .stroke(isSelected ? Color.purple : Color.white.opacity(0.2), lineWidth: 1)
+                    .strokeBorder(isSelected ? BrandColors.neonGradient : LinearGradient(colors: [Color.white.opacity(0.2)], startPoint: .leading, endPoint: .trailing), lineWidth: 1)
             )
+            .shadow(color: isSelected ? BrandColors.glow : .clear, radius: isSelected ? 10 : 0, x: 0, y: isSelected ? 6 : 0)
         }
         .buttonStyle(PlainButtonStyle())
     }
diff --git a/Buzzd/Features/Filters/Components/FilterSectionView.swift b/Buzzd/Features/Filters/Components/FilterSectionView.swift
index 0a6999fc..2503de8d 100644
--- a/Buzzd/Features/Filters/Components/FilterSectionView.swift
+++ b/Buzzd/Features/Filters/Components/FilterSectionView.swift
@@ -19,11 +19,8 @@ struct FilterSectionView<Content: View>: View {
             content()
         }
         .padding(16)
-        .background(Color.white.opacity(0.08))
+        .background(Color.black.opacity(0.65))
         .clipShape(RoundedRectangle(cornerRadius: 12))
-        .overlay(
-            RoundedRectangle(cornerRadius: 12)
-                .stroke(Color.white.opacity(0.1), lineWidth: 1)
-        )
+        .neonBorder(cornerRadius: 12, lineWidth: 1)
     }
 }
diff --git a/Buzzd/Features/Filters/FilterSortSheet.swift b/Buzzd/Features/Filters/FilterSortSheet.swift
index 3fef1dc3..5927f5a1 100644
--- a/Buzzd/Features/Filters/FilterSortSheet.swift
+++ b/Buzzd/Features/Filters/FilterSortSheet.swift
@@ -15,13 +15,9 @@ struct FilterSortSheet: View {
     var body: some View {
         NavigationView {
             ZStack {
-                // Background gradient matching your app theme
-                LinearGradient(
-                    gradient: Gradient(colors: [Color.black, Color.purple.opacity(0.3)]),
-                    startPoint: .topLeading,
-                    endPoint: .bottomTrailing
-                )
-                .ignoresSafeArea()
+                // Pure black background per redesign
+                BrandColors.appBackground
+                    .ignoresSafeArea()
                 
                 ScrollView {
                     VStack(spacing: 24) {
diff --git a/Buzzd/Features/Map/BuzzdMapScreen.swift b/Buzzd/Features/Map/BuzzdMapScreen.swift
index fd5831cd..8bc12771 100644
--- a/Buzzd/Features/Map/BuzzdMapScreen.swift
+++ b/Buzzd/Features/Map/BuzzdMapScreen.swift
@@ -67,6 +67,8 @@ struct BuzzdMapScreen: UIViewRepresentable {
     func updateUIView(_ uiView: EnhancedMapContainer, context: Context) {
         let startTime = CFAbsoluteTimeGetCurrent()
         
+        uiView.showLoading(viewModel.isLoading)
+
         // Cancel previous update if still running
         updateTask?.cancel()
         
@@ -229,11 +231,13 @@ final class EnhancedMapContainer: UIView {
     let mapboxHostView = MapboxHostView()
     private var controlsHostingController: UIHostingController<MapControlsOverlay>?
     private let controlsState = ControlsState()
+    private let loadingView = UIHostingController(rootView: LoadingView())
     
     override init(frame: CGRect) {
         super.init(frame: frame)
         setupMapView()
         setupControlsOverlay()
+        setupLoadingView()
     }
     
     required init?(coder: NSCoder) { return nil }
@@ -303,10 +307,28 @@ final class EnhancedMapContainer: UIView {
         controlsHostingController = hostingController
     }
     
+    private func setupLoadingView() {
+        loadingView.view.backgroundColor = .clear
+        loadingView.view.isHidden = true
+        addSubview(loadingView.view)
+        loadingView.view.translatesAutoresizingMaskIntoConstraints = false
+        NSLayoutConstraint.activate([
+            loadingView.view.centerXAnchor.constraint(equalTo: centerXAnchor),
+            loadingView.view.centerYAnchor.constraint(equalTo: centerYAnchor),
+        ])
+    }
+
     func configure() {
         mapboxHostView.configure()
     }
     
+    func showLoading(_ show: Bool) {
+        loadingView.view.isHidden = !show
+        if show {
+            bringSubviewToFront(loadingView.view)
+        }
+    }
+    
     func updateControls(
         showingFilterMenu: Bool,
         selectedVenueTypes: Set<VenueType>,
diff --git a/Buzzd/Features/Profile/ProfileView.swift b/Buzzd/Features/Profile/ProfileView.swift
index 38f5a8d6..43c4628f 100644
--- a/Buzzd/Features/Profile/ProfileView.swift
+++ b/Buzzd/Features/Profile/ProfileView.swift
@@ -27,6 +27,8 @@ struct ProfileView: View {
     @State private var showingStripeOptions = false
     @State private var shareLocationWithFriends: Bool = true
     @State private var showingLegalCenter = false
+    @State private var showingFeedback = false
+    @State private var feedbackText: String = ""
 
     // Live stats
     @State private var checkInCount: Int = 0
@@ -60,13 +62,8 @@ struct ProfileView: View {
     var body: some View {
         NavigationStack {
             ZStack {
-                // Background gradient
-                LinearGradient(
-                    gradient: Gradient(colors: [Color.black, Color.purple.opacity(0.3)]),
-                    startPoint: .topLeading,
-                    endPoint: .bottomTrailing
-                )
-                .ignoresSafeArea()
+                // Background
+                BrandColors.appBackground.ignoresSafeArea()
 
                 ScrollView(showsIndicators: false) {
                     VStack(spacing: 24) {
@@ -100,6 +97,13 @@ struct ProfileView: View {
         .sheet(isPresented: $showingAccountSettings) { AccountSettingsView() }
         .sheet(isPresented: $showingEditProfile) { EditProfileView() }
         .sheet(isPresented: $showingLegalCenter) { LegalMenuSheet() }
+        .sheet(isPresented: $showingFeedback) {
+            FeedbackSheet(
+                text: $feedbackText,
+                onCancel: { showingFeedback = false },
+                onSend: { sendFeedbackEmail(body: feedbackText) }
+            )
+        }
         .alert("Sign Out", isPresented: $showingSignOutAlert) {
             Button("Cancel", role: .cancel) { }
             Button("Sign Out", role: .destructive) {
@@ -273,16 +277,14 @@ struct ProfileView: View {
         VStack(spacing: 20) {
             // Profile picture with gradient border
             ZStack {
+                // Neon gradient ring around avatar (Instagram-style)
                 Circle()
-                    .fill(
-                        LinearGradient(
-                            colors: [Color.purple, Color.pink],
-                            startPoint: .topLeading,
-                            endPoint: .bottomTrailing
-                        )
-                    )
-                    .frame(width: 120, height: 120)
-                    .shadow(color: .purple.opacity(0.3), radius: 15, x: 0, y: 8)
+                    .strokeBorder(BrandColors.neonGradient, lineWidth: 4)
+                    .frame(width: 124, height: 124)
+                    .shadow(color: BrandColors.glow, radius: 14, x: 0, y: 8)
+                Circle()
+                    .fill(Color.black)
+                    .frame(width: 118, height: 118)
 
                 let avatarURL = URL(string: session.userProfile?.avatarURL ?? "")
                 let _ = print("üñºÔ∏è Profile Avatar URL: \(session.userProfile?.avatarURL ?? "NO URL")")
@@ -354,18 +356,9 @@ struct ProfileView: View {
                 .foregroundColor(.white)
                 .frame(maxWidth: .infinity)
                 .padding(.vertical, 10)
-                .background(
-                    LinearGradient(
-                        colors: [Color.white.opacity(0.15), Color.white.opacity(0.08)],
-                        startPoint: .top,
-                        endPoint: .bottom
-                    )
-                )
+                .background(Color.black.opacity(0.65))
                 .clipShape(RoundedRectangle(cornerRadius: 12))
-                .overlay(
-                    RoundedRectangle(cornerRadius: 12)
-                        .stroke(Color.white.opacity(0.2), lineWidth: 1)
-                )
+                .neonBorder(cornerRadius: 12, lineWidth: 1, glow: true)
             }
             .buttonStyle(.plain)
         }
@@ -400,13 +393,7 @@ struct ProfileView: View {
             HStack(spacing: 10) {
                 Image(systemName: "chart.bar.fill")
                     .font(.title3)
-                    .foregroundStyle(
-                        LinearGradient(
-                            colors: [Color.purple, Color.pink],
-                            startPoint: .leading,
-                            endPoint: .trailing
-                        )
-                    )
+                    .foregroundStyle(BrandColors.neonGradient)
                 Text("Your Stats")
                     .font(.headline)
                     .fontWeight(.bold)
@@ -421,21 +408,8 @@ struct ProfileView: View {
             }
         }
         .padding(20)
-        .background(
-            RoundedRectangle(cornerRadius: 20)
-                .fill(Color.white.opacity(0.06))
-                .overlay(
-                    RoundedRectangle(cornerRadius: 20)
-                        .stroke(
-                            LinearGradient(
-                                colors: [Color.white.opacity(0.15), Color.white.opacity(0.05)],
-                                startPoint: .topLeading,
-                                endPoint: .bottomTrailing
-                            ),
-                            lineWidth: 1
-                        )
-                )
-        )
+        .background(RoundedRectangle(cornerRadius: 20).fill(Color.black.opacity(0.65)))
+        .neonBorder(cornerRadius: 20, lineWidth: 1)
     }
     
     // MARK: - Activity Section
@@ -445,13 +419,7 @@ struct ProfileView: View {
             HStack(spacing: 10) {
                 Image(systemName: "clock.arrow.circlepath")
                     .font(.title3)
-                    .foregroundStyle(
-                        LinearGradient(
-                            colors: [Color.purple, Color.pink],
-                            startPoint: .leading,
-                            endPoint: .trailing
-                        )
-                    )
+                    .foregroundStyle(BrandColors.neonGradient)
 
                 Text("Recent Activity")
                     .font(.headline)
@@ -480,21 +448,8 @@ struct ProfileView: View {
             }
         }
         .padding(20)
-        .background(
-            RoundedRectangle(cornerRadius: 20)
-                .fill(Color.white.opacity(0.06))
-                .overlay(
-                    RoundedRectangle(cornerRadius: 20)
-                        .stroke(
-                            LinearGradient(
-                                colors: [Color.white.opacity(0.15), Color.white.opacity(0.05)],
-                                startPoint: .topLeading,
-                                endPoint: .bottomTrailing
-                            ),
-                            lineWidth: 1
-                        )
-                )
-        )
+        .background(RoundedRectangle(cornerRadius: 20).fill(Color.black.opacity(0.65)))
+        .neonBorder(cornerRadius: 20, lineWidth: 1)
     }
     
     // MARK: - Settings Section
@@ -504,13 +459,7 @@ struct ProfileView: View {
             HStack(spacing: 10) {
                 Image(systemName: "gearshape.fill")
                     .font(.title3)
-                    .foregroundStyle(
-                        LinearGradient(
-                            colors: [Color.purple, Color.pink],
-                            startPoint: .leading,
-                            endPoint: .trailing
-                        )
-                    )
+                    .foregroundStyle(BrandColors.neonGradient)
 
                 Text("Settings")
                     .font(.headline)
@@ -623,21 +572,8 @@ struct ProfileView: View {
             }
         }
         .padding(20)
-        .background(
-            RoundedRectangle(cornerRadius: 20)
-                .fill(Color.white.opacity(0.06))
-                .overlay(
-                    RoundedRectangle(cornerRadius: 20)
-                        .stroke(
-                            LinearGradient(
-                                colors: [Color.white.opacity(0.15), Color.white.opacity(0.05)],
-                                startPoint: .topLeading,
-                                endPoint: .bottomTrailing
-                            ),
-                            lineWidth: 1
-                        )
-                )
-        )
+        .background(RoundedRectangle(cornerRadius: 20).fill(Color.black.opacity(0.65)))
+        .neonBorder(cornerRadius: 20, lineWidth: 1)
     }
 
     // MARK: - Admin Section
@@ -675,8 +611,9 @@ struct ProfileView: View {
                     .tint(.purple)
                     .padding(.horizontal, 16)
                     .padding(.vertical, 12)
-                    .background(Color.white.opacity(0.05))
+                    .background(Color.black.opacity(0.65))
                     .clipShape(RoundedRectangle(cornerRadius: 14))
+                    .neonBorder(cornerRadius: 14, lineWidth: 1)
 
                     NavigationLink(destination: OrgVerificationAdminView()) {
                         HStack(spacing: 12) {
@@ -691,8 +628,9 @@ struct ProfileView: View {
                         .foregroundColor(.white)
                         .padding(.horizontal, 16)
                         .padding(.vertical, 12)
-                        .background(Color.white.opacity(0.05))
+                        .background(Color.black.opacity(0.65))
                         .clipShape(RoundedRectangle(cornerRadius: 14))
+                        .neonBorder(cornerRadius: 14, lineWidth: 1)
                     }
                 }
                 .padding(20)
@@ -739,14 +677,9 @@ struct ProfileView: View {
                         .foregroundColor(.white)
                         .frame(maxWidth: .infinity)
                         .padding(.vertical, 12)
-                        .background(
-                            LinearGradient(
-                                colors: [Color.purple, Color.purple.opacity(0.8)],
-                                startPoint: .leading,
-                                endPoint: .trailing
-                            ),
-                            in: RoundedRectangle(cornerRadius: 12)
-                        )
+                        .background(Color.black.opacity(0.65))
+                        .clipShape(RoundedRectangle(cornerRadius: 12))
+                        .neonBorder(cornerRadius: 12, lineWidth: 1)
                     }
                     .buttonStyle(.plain)
                 }
@@ -777,13 +710,7 @@ struct ProfileView: View {
             HStack(spacing: 10) {
                 Image(systemName: "person.circle.fill")
                     .font(.title3)
-                    .foregroundStyle(
-                        LinearGradient(
-                            colors: [Color.purple, Color.pink],
-                            startPoint: .leading,
-                            endPoint: .trailing
-                        )
-                    )
+                    .foregroundStyle(BrandColors.neonGradient)
 
                 Text("Account")
                     .font(.headline)
@@ -808,6 +735,13 @@ struct ProfileView: View {
                     action: { /* Navigate to about */ }
                 )
 
+                SettingsRow(
+                    icon: "bubble.left.and.bubble.right.fill",
+                    title: "Feedback",
+                    subtitle: "Tell us what you think",
+                    action: { showingFeedback = true }
+                )
+
                 Divider()
                     .background(Color.white.opacity(0.1))
                     .padding(.vertical, 4)
@@ -845,8 +779,9 @@ struct ProfileView: View {
                     }
                     .padding(.vertical, 12)
                     .padding(.horizontal, 12)
-                    .background(Color.white.opacity(0.03))
+                    .background(Color.black.opacity(0.65))
                     .clipShape(RoundedRectangle(cornerRadius: 12))
+                    .neonBorder(cornerRadius: 12, lineWidth: 1)
                 }
                 .buttonStyle(.plain)
 
@@ -1011,6 +946,26 @@ private extension ProfileView {
             }
         }
     }
+
+    // MARK: - Feedback
+
+    func sendFeedbackEmail(body: String) {
+        let to = AppConfiguration.shared.supportEmail
+        let version = AppConfiguration.shared.appVersion
+        let os = UIDevice.current.systemVersion
+        let subject = "Buzzd Feedback (v\(version), iOS \(os))"
+        let message = body.trimmingCharacters(in: .whitespacesAndNewlines)
+        let fullBody = message.isEmpty ? "(No message)" : message
+        let enc: (String) -> String = { str in
+            str.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? str
+        }
+        let mailto = "mailto:\(to)?subject=\(enc(subject))&body=\(enc(fullBody))"
+        if let url = URL(string: mailto) {
+            UIApplication.shared.open(url)
+        }
+        showingFeedback = false
+        feedbackText = ""
+    }
 }
 
 // MARK: - Supporting Views
@@ -1072,7 +1027,7 @@ struct StatRow: View {
     var body: some View {
         HStack(spacing: 12) {
             ZStack {
-                Circle().fill(LinearGradient(colors: [Color.purple, Color.pink], startPoint: .topLeading, endPoint: .bottomTrailing))
+                Circle().fill(BrandColors.neonGradient)
                 Image(systemName: icon).foregroundStyle(.white).font(.subheadline)
             }
             .frame(width: 28, height: 28)
@@ -1087,7 +1042,7 @@ struct StatRow: View {
         }
         .padding(.horizontal, 8)
         .padding(.vertical, 10)
-        .background(Color.white.opacity(0.03))
+        .background(Color.black.opacity(0.65))
         .clipShape(RoundedRectangle(cornerRadius: 10))
     }
 }
@@ -1124,8 +1079,9 @@ struct ActivityRow: View {
         }
         .padding(.vertical, 10)
         .padding(.horizontal, 12)
-        .background(Color.white.opacity(0.03))
+        .background(Color.black.opacity(0.65))
         .clipShape(RoundedRectangle(cornerRadius: 12))
+        .neonBorder(cornerRadius: 12, lineWidth: 1)
     }
 }
 
@@ -1187,6 +1143,66 @@ struct SettingsRow: View {
     }
 }
 
+// MARK: - Feedback Sheet
+
+private struct FeedbackSheet: View {
+    @Binding var text: String
+    var onCancel: () -> Void
+    var onSend: () -> Void
+
+    var body: some View {
+        VStack(alignment: .leading, spacing: 16) {
+            HStack {
+                Text("Feedback")
+                    .font(.headline)
+                    .foregroundColor(.white)
+                Spacer()
+                Button("Cancel", action: onCancel)
+                    .foregroundColor(.white.opacity(0.8))
+            }
+
+            ZStack(alignment: .topLeading) {
+                TextEditor(text: $text)
+                    .frame(minHeight: 160)
+                    .padding(12)
+                    .scrollContentBackground(.hidden)
+                    .background(Color.white.opacity(0.07))
+                    .clipShape(RoundedRectangle(cornerRadius: 12))
+                    .foregroundColor(.white)
+                if text.isEmpty {
+                    Text("Type your feedback here‚Ä¶")
+                        .foregroundColor(.white.opacity(0.5))
+                        .padding(.top, 20)
+                        .padding(.leading, 18)
+                        .allowsHitTesting(false)
+                }
+            }
+
+            HStack {
+                Spacer()
+                Button {
+                    onSend()
+                } label: {
+                    HStack(spacing: 8) {
+                        Image(systemName: "paperplane.fill")
+                        Text("Send")
+                    }
+                    .foregroundColor(.white)
+                    .padding(.horizontal, 16)
+                    .padding(.vertical, 8)
+                    .background(text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? Color.white.opacity(0.2) : Color.brandPurple)
+                    .clipShape(Capsule())
+                }
+                .disabled(text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
+            }
+        }
+        .padding(20)
+        .background(BrandColors.appBackground)
+        .preferredColorScheme(.dark)
+        .presentationDetents([.medium, .large])
+    }
+}
+
 // MARK: - Placeholder Views
 
 struct SettingsView: View {
diff --git a/Buzzd/Features/Shared/RemoteImageView.swift b/Buzzd/Features/Shared/RemoteImageView.swift
index 7fa0fc9a..18477db8 100644
--- a/Buzzd/Features/Shared/RemoteImageView.swift
+++ b/Buzzd/Features/Shared/RemoteImageView.swift
@@ -11,28 +11,88 @@ import SwiftUI
 struct RemoteImageView: View {
     let url: URL?
 
+    @State private var resolvedImage: UIImage?
+    @State private var isLoading: Bool = false
+
     @ViewBuilder
     var body: some View {
-        if let url, !url.absoluteString.isEmpty {
-            CachedAsyncImage(
-                url: url,
-                content: { image in
-                    image
-                        .resizable()
-                        .scaledToFill()
-                },
-                placeholder: {
-                    BrandImagePlaceholder(cornerRadius: 16)
-                }
-            )
-            .id(url.absoluteString) // ensure refresh when URL changes
-            .clipShape(RoundedRectangle(cornerRadius: 16, style: .continuous))
+        if let img = resolvedImage {
+            Image(uiImage: img)
+                .resizable()
+                .scaledToFill()
+                .clipShape(RoundedRectangle(cornerRadius: 16, style: .continuous))
+        } else if isLoading {
+            BrandImagePlaceholder(cornerRadius: 16)
+                .overlay(Image(systemName: "photo").imageScale(.medium).foregroundStyle(.white.opacity(0.25)))
+                .clipShape(RoundedRectangle(cornerRadius: 16, style: .continuous))
+                .task(id: url) { await loadWithFallback() }
+        } else if let url, !url.absoluteString.isEmpty {
+            BrandImagePlaceholder(cornerRadius: 16)
+                .clipShape(RoundedRectangle(cornerRadius: 16, style: .continuous))
+                .task(id: url) { await loadWithFallback() }
         } else {
             ZStack {
                 BrandImagePlaceholder(cornerRadius: 16)
                 Image(systemName: "photo").imageScale(.large).foregroundStyle(.white.opacity(0.45))
             }
+            .clipShape(RoundedRectangle(cornerRadius: 16, style: .continuous))
+        }
+    }
+
+    private func loadWithFallback() async {
+        guard let url else { return }
+        await MainActor.run { isLoading = true }
+
+        // If this is our Functions photo proxy, prefer direct Google photo first for speed/reliability
+        let host = url.host ?? ""
+        let isFunctions = host.contains("cloudfunctions.net") || host.contains("run.app")
+        if isFunctions, let fallback = computeFallbackURL(from: url) {
+            if let img = await ImageCache.shared.image(for: fallback) {
+                await MainActor.run { self.resolvedImage = img; self.isLoading = false }
+                return
+            }
+            // If fallback failed, try the original proxy URL once
+            if let img = await ImageCache.shared.image(for: url) {
+                await MainActor.run { self.resolvedImage = img; self.isLoading = false }
+                return
+            }
+        } else {
+            // Non-functions URL: try as-is first
+            if let img = await ImageCache.shared.image(for: url) {
+                await MainActor.run { self.resolvedImage = img; self.isLoading = false }
+                return
+            }
+            // Then fallback if we can derive one
+            if let fallback = computeFallbackURL(from: url), let img = await ImageCache.shared.image(for: fallback) {
+                await MainActor.run { self.resolvedImage = img; self.isLoading = false }
+                return
+            }
         }
+        await MainActor.run { self.isLoading = false }
+    }
+
+    private func computeFallbackURL(from url: URL) -> URL? {
+        // If the URL is our backend photo proxy, derive a direct Google Photo URL as a fallback
+        guard let host = url.host else { return nil }
+        let isFunctions = host.contains("cloudfunctions.net") || host.contains("run.app")
+        guard isFunctions, url.path.contains("getPlacePhoto") else { return nil }
+
+        // Extract photoreference and sizing
+        guard let comps = URLComponents(url: url, resolvingAgainstBaseURL: false) else { return nil }
+        let ref = comps.queryItems?.first(where: { $0.name == "ref" || $0.name == "photoreference" })?.value ?? ""
+        if ref.isEmpty { return nil }
+        let reqWidth = comps.queryItems?.first(where: { $0.name == "maxwidth" })?.value ?? "800"
+        let maxwidth = String(min(Int(reqWidth) ?? 800, 480))
+        // Build direct Google photo URL with client key
+        let key = AppConfiguration.shared.googlePlacesAPIKey
+        guard !key.isEmpty else { return nil }
+        var c = URLComponents(string: "https://maps.googleapis.com/maps/api/place/photo")!
+        c.queryItems = [
+            URLQueryItem(name: "maxwidth", value: maxwidth),
+            URLQueryItem(name: "photoreference", value: ref),
+            URLQueryItem(name: "key", value: key)
+        ]
+        return c.url
     }
 }
 
diff --git a/Buzzd/Features/Social/Models/SocialModels.swift b/Buzzd/Features/Social/Models/SocialModels.swift
index 62a9ba28..73064e91 100644
--- a/Buzzd/Features/Social/Models/SocialModels.swift
+++ b/Buzzd/Features/Social/Models/SocialModels.swift
@@ -326,6 +326,7 @@ enum NotificationType: String, Codable, CaseIterable {
     case newMessage = "new_message"
     case hostEvent = "host_event"
     case hostPosted = "host_posted"
+    case hostUpdated = "host_updated"
     case eventReminder = "event_reminder"
     case groupInvite = "group_invite"
 }
diff --git a/Buzzd/Features/Social/Services/SocialServices.swift b/Buzzd/Features/Social/Services/SocialServices.swift
index 5146bb67..76277f3e 100644
--- a/Buzzd/Features/Social/Services/SocialServices.swift
+++ b/Buzzd/Features/Social/Services/SocialServices.swift
@@ -537,29 +537,48 @@ import UserNotifications
                 seenUserIds.insert(id)
             }
 
-            // 1. Direct username match (allows leading '@')
+            // 1. Username search (Snap/IG-style): exact + prefix as you type
             let normalizedUsername = UsernameService.normalize(trimmedQuery.trimmingCharacters(in: CharacterSet(charactersIn: "@")))
             if !normalizedUsername.isEmpty {
-                let usernameDoc = try await db.collection("usernames").document(normalizedUsername).getDocument()
-                if let ownerId = usernameDoc.data()?["ownerId"] as? String {
-                    let userDoc = try await db.collection("users").document(ownerId).getDocument()
-                    if let data = userDoc.data() {
-                        await appendUser(id: ownerId, data: data, fallbackUsername: normalizedUsername)
+                // 1a) Exact match via usernames index
+                do {
+                    let usernameDoc = try await db.collection("usernames").document(normalizedUsername).getDocument()
+                    if let ownerId = usernameDoc.data()?["ownerId"] as? String {
+                        let userDoc = try await db.collection("users").document(ownerId).getDocument()
+                        if let data = userDoc.data() {
+                            await appendUser(id: ownerId, data: data, fallbackUsername: normalizedUsername)
+                        }
                     }
-                }
+                } catch {/* ignore */}
 
-                if results.isEmpty {
+                // 1b) Exact in users (consistency)
+                do {
                     let usernameSnapshot = try await db.collection("users")
                         .whereField("username", isEqualTo: normalizedUsername)
                         .limit(to: 10)
                         .getDocuments()
-
                     for document in usernameSnapshot.documents {
                         await appendUser(id: document.documentID,
                                          data: document.data(),
                                          fallbackUsername: normalizedUsername)
                     }
-                }
+                } catch {/* ignore */}
+
+                // 1c) Prefix match for fast typeahead (@ma ‚Üí @marley)
+                // Uses range query on username with single-field index.
+                do {
+                    let end = normalizedUsername + "\u{f8ff}"
+                    let prefixSnap = try await db.collection("users")
+                        .order(by: "username")
+                        .start(at: [normalizedUsername])
+                        .end(at: [end])
+                        .limit(to: 20)
+                        .getDocuments()
+                    for document in prefixSnap.documents {
+                        await appendUser(id: document.documentID,
+                                         data: document.data())
+                    }
+                } catch {/* ignore */}
             }
 
             // 2. Email fallback (only if query looks like email or nothing found yet)
@@ -581,20 +600,45 @@ import UserNotifications
                 }
             }
 
-            // 3. Exact name fallback if still nothing
-            if results.isEmpty {
-                let nameSnapshot = try await db.collection("users")
-                    .whereField("name", isEqualTo: trimmedQuery)
-                    .limit(to: 10)
-                    .getDocuments()
-
-                for document in nameSnapshot.documents {
-                    await appendUser(id: document.documentID,
-                                     data: document.data())
+            // 3. Case-insensitive name prefix search using nameLower
+            let nameQ = trimmedQuery.lowercased()
+            if nameQ.count >= 2 { // avoid noisy queries for 1-char terms
+                do {
+                    let end = nameQ + "\u{f8ff}"
+                    let nameSnap = try await db.collection("users")
+                        .order(by: "nameLower")
+                        .start(at: [nameQ])
+                        .end(at: [end])
+                        .limit(to: 20)
+                        .getDocuments()
+                    for document in nameSnap.documents {
+                        await appendUser(id: document.documentID, data: document.data())
+                    }
+                } catch {
+                    // ignore name search errors
                 }
             }
+            // Fallback: exact name match if prefix yields nothing (compat for old docs)
+            if results.isEmpty {
+                do {
+                    let nameSnapshot = try await db.collection("users")
+                        .whereField("name", isEqualTo: trimmedQuery)
+                        .limit(to: 10)
+                        .getDocuments()
+                    for document in nameSnapshot.documents {
+                        await appendUser(id: document.documentID, data: document.data())
+                    }
+                } catch {/* ignore */}
+            }
 
-            return results.sorted { $0.name.lowercased() < $1.name.lowercased() }
+            // Prefer results with usernames starting with the query, then by display name
+            let q = normalizedUsername
+            return results.sorted { a, b in
+                let aStarts = (a.username ?? "").hasPrefix(q)
+                let bStarts = (b.username ?? "").hasPrefix(q)
+                if aStarts != bStarts { return aStarts && !bStarts }
+                return a.name.lowercased() < b.name.lowercased()
+            }
         }
         
         private func getFriendshipStatus(with userId: String) async -> FriendshipStatus {
@@ -1097,6 +1141,9 @@ import UserNotifications
             if !participants.contains(currentUserId) {
                 participants.append(currentUserId)
             }
+            // Deterministic key for reference (duplicates still allowed)
+            let sorted = participants.sorted()
+            let groupKey = "group_" + sorted.joined(separator: "_")
             
             // Use a dictionary to match security rules for create
             let data: [String: Any] = [
@@ -1108,12 +1155,20 @@ import UserNotifications
                 "createdAt": FieldValue.serverTimestamp(),
                 "lastMessage": NSNull(),
                 "lastMessageAt": FieldValue.serverTimestamp(),
-                "lastMessageSenderId": NSNull()
+                "lastMessageSenderId": NSNull(),
+                "groupKey": groupKey
             ]
 
             let docRef = try await db.collection("chats").addDocument(data: data)
             return docRef.documentID
         }
+
+        /// Updates the name of a group chat. No-op for non-group chats.
+        func updateGroupName(chatId: String, newName: String) async throws {
+            let trimmed = newName.trimmingCharacters(in: .whitespacesAndNewlines)
+            guard !trimmed.isEmpty else { return }
+            try await db.collection("chats").document(chatId).updateData(["name": trimmed])
+        }
     }
 
     // MARK: - Host Subscription Service
diff --git a/Buzzd/Features/Social/Views/ChatViews.swift b/Buzzd/Features/Social/Views/ChatViews.swift
index f307a957..b54fdb69 100644
--- a/Buzzd/Features/Social/Views/ChatViews.swift
+++ b/Buzzd/Features/Social/Views/ChatViews.swift
@@ -102,33 +102,30 @@ struct ChatRowView: View {
         Button(action: onTap) {
             HStack(spacing: 12) {
                 chatImage
-                VStack(alignment: .leading, spacing: 4) {
+                VStack(alignment: .leading, spacing: 3) {
                     HStack(alignment: .firstTextBaseline) {
                         Text(displayName)
-                            .font(.subheadline.weight(.semibold))
+                            .font(.system(size: 16, weight: .medium))
                             .foregroundColor(.white)
                             .lineLimit(1)
                         Spacer(minLength: 8)
                         Text(timeString(from: chat.lastMessageAt))
-                            .font(.caption2)
-                            .foregroundColor(.white.opacity(0.6))
+                            .font(.system(size: 13))
+                            .foregroundColor(.white.opacity(0.5))
                     }
                     if let lastMessage = chat.lastMessage, !lastMessage.isEmpty {
                         Text(lastMessage)
-                            .font(.footnote)
-                            .foregroundColor(.white.opacity(0.78))
+                            .font(.system(size: 14))
+                            .foregroundColor(.white.opacity(0.6))
                             .lineLimit(1)
                     }
                 }
             }
             .padding(.horizontal, 12)
-            .padding(.vertical, 12)
-            .background(Color.white.opacity(0.06), in: RoundedRectangle(cornerRadius: 14, style: .continuous))
-            .overlay(
-                RoundedRectangle(cornerRadius: 14, style: .continuous)
-                    .stroke(LinearGradient(colors: [Color.white.opacity(0.12), Color.white.opacity(0.04)], startPoint: .topLeading, endPoint: .bottomTrailing), lineWidth: 1)
-            )
-            .contentShape(RoundedRectangle(cornerRadius: 14, style: .continuous))
+            .padding(.vertical, 14)
+            .background(Color.black.opacity(0.6), in: RoundedRectangle(cornerRadius: 12, style: .continuous))
+            .neonBorder(cornerRadius: 12, lineWidth: 1)
+            .contentShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
         }
         .buttonStyle(.plain)
     }
@@ -138,13 +135,12 @@ struct ChatRowView: View {
         if chat.type == .group {
             ZStack {
                 Circle()
-                    .fill(LinearGradient(colors: [Color.purple.opacity(0.35), Color.pink.opacity(0.25)], startPoint: .topLeading, endPoint: .bottomTrailing))
+                    .fill(Color.white.opacity(0.15))
                 Image(systemName: "person.3.fill")
-                    .font(.system(size: 18, weight: .semibold))
-                    .foregroundColor(.white)
+                    .font(.system(size: 16, weight: .medium))
+                    .foregroundColor(.white.opacity(0.8))
             }
-            .frame(width: 44, height: 44)
-            .overlay(Circle().stroke(Color.white.opacity(0.12), lineWidth: 1))
+            .frame(width: 48, height: 48)
         } else {
             let otherId = chat.otherParticipant(excluding: currentUserId)
             let avatarURL = friendsService.friends.first(where: { $0.id == otherId })?.avatarURL
@@ -153,18 +149,16 @@ struct ChatRowView: View {
                     image.resizable().scaledToFill()
                 }, placeholder: {
                     Circle()
-                        .fill(LinearGradient(colors: [Color.purple.opacity(0.35), Color.pink.opacity(0.25)], startPoint: .topLeading, endPoint: .bottomTrailing))
-                        .overlay(Text(NameInitials.initials(for: displayName)).font(.headline).foregroundColor(.white))
+                        .fill(Color.white.opacity(0.15))
+                        .overlay(Text(NameInitials.initials(for: displayName)).font(.system(size: 16, weight: .medium)).foregroundColor(.white.opacity(0.8)))
                 })
-                .frame(width: 44, height: 44)
+                .frame(width: 48, height: 48)
                 .clipShape(Circle())
-                .overlay(Circle().stroke(Color.white.opacity(0.12), lineWidth: 1))
             } else {
                 Circle()
-                    .fill(LinearGradient(colors: [Color.purple.opacity(0.35), Color.pink.opacity(0.25)], startPoint: .topLeading, endPoint: .bottomTrailing))
-                    .overlay(Text(NameInitials.initials(for: displayName)).font(.headline).foregroundColor(.white))
-                    .frame(width: 44, height: 44)
-                    .overlay(Circle().stroke(Color.white.opacity(0.12), lineWidth: 1))
+                    .fill(Color.white.opacity(0.15))
+                    .overlay(Text(NameInitials.initials(for: displayName)).font(.system(size: 16, weight: .medium)).foregroundColor(.white.opacity(0.8)))
+                    .frame(width: 48, height: 48)
             }
         }
     }
@@ -220,6 +214,8 @@ struct ChatDetailView: View {
     @State private var scrollProxy: ScrollViewProxy?
     @Environment(\.dismiss) private var dismiss
     @State private var typingDebounce: DispatchWorkItem?
+    @State private var isEditingGroupName = false
+    @State private var groupTitleOverride: String? = nil
     
     var body: some View {
         VStack(spacing: 0) {
@@ -293,10 +289,7 @@ struct ChatDetailView: View {
         .navigationTitle(displayName)
         .navigationBarTitleDisplayMode(.inline)
         .background(
-            LinearGradient(
-                gradient: Gradient(colors: [Color.black, Color.purple.opacity(0.3)]),
-                startPoint: .topLeading, endPoint: .bottomTrailing
-            )
+            BrandColors.appBackground
         )
         .navigationBarBackButtonHidden(true)
         .onAppear {
@@ -304,6 +297,9 @@ struct ChatDetailView: View {
                 chatService.startListeningToMessages(chatId: chatId)
             }
             tabBarState.isHidden = true
+            if chat.type == .group {
+                groupTitleOverride = chat.displayName
+            }
         }
         .onDisappear {
             // Stop the message stream when leaving the chat detail
@@ -321,6 +317,13 @@ struct ChatDetailView: View {
             }
             ToolbarItem(placement: .topBarTrailing) {
                 Menu {
+                    if chat.type == .group {
+                        Button {
+                            isEditingGroupName = true
+                        } label: {
+                            Label("Edit Group Name", systemImage: "pencil")
+                        }
+                    }
                     Button(role: .destructive) {
                         Task { await leaveChat() }
                     } label: {
@@ -337,31 +340,52 @@ struct ChatDetailView: View {
                 VenueDetailView(venue: v, isPresented: $isPresentingVenue)
             }
         }
+        .sheet(isPresented: $isEditingGroupName) {
+            EditGroupNameSheet(
+                currentName: groupTitleOverride ?? chat.displayName,
+                onCancel: { isEditingGroupName = false },
+                onSave: { newName in
+                    Task {
+                        guard let chatId = chat.id else { return }
+                        do {
+                            try await chatService.updateGroupName(chatId: chatId, newName: newName)
+                            await MainActor.run {
+                                groupTitleOverride = newName
+                                isEditingGroupName = false
+                            }
+                        } catch {
+                            print("Rename failed: \(error)")
+                        }
+                    }
+                }
+            )
+            .presentationDetents([.height(200)])
+        }
     }
     
     private var messageInputView: some View {
-        HStack(spacing: 12) {
-            TextField("Type a message...", text: $messageText, axis: .vertical)
+        HStack(spacing: 10) {
+            TextField("Message", text: $messageText, axis: .vertical)
                 .textFieldStyle(.plain)
-                .padding(.horizontal, 16).padding(.vertical, 10)
+                .padding(.horizontal, 14).padding(.vertical, 9)
                 .background(Color.white.opacity(0.1))
-                .clipShape(RoundedRectangle(cornerRadius: 20))
+                .clipShape(RoundedRectangle(cornerRadius: 18))
                 .lineLimit(1...5)
                 .foregroundColor(.white)
                 .onChange(of: messageText) { _ in
                     handleTypingChanged()
                 }
-            
+
             Button { sendMessage() } label: {
                 Image(systemName: "arrow.up.circle.fill")
-                    .font(.system(size: 32))
+                    .font(.system(size: 28))
                     .foregroundColor(messageText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
-                                     ? .white.opacity(0.3) : .purple)
+                                     ? .white.opacity(0.3) : Color.purple.opacity(0.9))
             }
             .disabled(messageText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
         }
-        .padding(.horizontal, 16)
-        .padding(.vertical, 12)
+        .padding(.horizontal, 14)
+        .padding(.vertical, 10)
     }
 
     private func leaveChat() async {
@@ -442,7 +466,7 @@ struct ChatDetailView: View {
     
     @MainActor
     private var displayName: String {
-        if chat.type == .group { return chat.displayName }
+        if chat.type == .group { return groupTitleOverride ?? chat.displayName }
         guard let otherUserId = chat.otherParticipant(excluding: currentUserId) else { return "Chat" }
         if let friend = friendsService.friends.first(where: { $0.id == otherUserId }) { return friend.name }
         // Fallback to participantNames if friend not in friends list
@@ -494,6 +518,301 @@ struct ChatDetailView: View {
     }
 }
 
+// MARK: - New Message (Instagram-style)
+
+struct NewMessageView: View {
+    @ObservedObject private var friendsService = FriendsService.shared
+    @ObservedObject private var chatService = ChatService.shared
+    @Environment(\.dismiss) private var dismiss
+
+    @State private var searchText: String = ""
+    @State private var selectedIds: Set<String> = []
+    @State private var isWorking: Bool = false
+    @State private var navigateToGroup: Bool = false
+
+    var body: some View {
+        NavigationStack {
+            ZStack {
+                LinearGradient(
+                    gradient: Gradient(colors: [
+                        Color(red: 0.05, green: 0.02, blue: 0.12),
+                        Color.black
+                    ]),
+                    startPoint: .top,
+                    endPoint: .bottom
+                )
+                .ignoresSafeArea()
+
+                VStack(alignment: .leading, spacing: 16) {
+                    toRow
+
+                    Button {
+                        navigateToGroup = true
+                    } label: {
+                        HStack(spacing: 10) {
+                            Image(systemName: "person.3").font(.system(size: 16, weight: .medium))
+                            Text("Create Group").font(.system(size: 15, weight: .medium))
+                            Spacer()
+                            Image(systemName: "chevron.right").font(.system(size: 13))
+                        }
+                        .foregroundColor(.white)
+                        .padding(.horizontal, 14)
+                        .padding(.vertical, 12)
+                        .background(Color.white.opacity(0.08), in: RoundedRectangle(cornerRadius: 10))
+                    }
+                    .buttonStyle(.plain)
+
+                    // Suggested (recent contacts)
+                    if !suggestedFriends.isEmpty {
+                        Text("RECENT")
+                            .font(.system(size: 12, weight: .semibold))
+                            .foregroundColor(.white.opacity(0.5))
+                            .padding(.horizontal, 4)
+                            .padding(.top, 4)
+                        ScrollView(.horizontal, showsIndicators: false) {
+                            HStack(spacing: 14) {
+                                ForEach(suggestedFriends) { friend in
+                                    FriendIconSelectable(friend: friend, isSelected: selectedIds.contains(friend.id ?? "")) {
+                                        toggle(friend)
+                                    }
+                                }
+                            }
+                            .padding(.horizontal, 4)
+                        }
+                        .padding(.bottom, 4)
+                    }
+
+                    // Filtered list to add by typing
+                    ScrollView {
+                        LazyVStack(spacing: 10) {
+                            ForEach(filteredFriends) { friend in
+                                Button {
+                                    toggle(friend)
+                                } label: {
+                                    HStack(spacing: 12) {
+                                        CachedAsyncImage(url: URL(string: friend.avatarURL ?? ""), content: { image in
+                                            image.resizable().scaledToFill()
+                                        }, placeholder: {
+                                            Circle()
+                                                .fill(Color.white.opacity(0.15))
+                                                .overlay(Text(NameInitials.initials(for: friend.name)).font(.system(size: 15, weight: .medium)).foregroundColor(.white.opacity(0.8)))
+                                        })
+                                        .frame(width: 44, height: 44)
+                                        .clipShape(Circle())
+
+                                        Text(friend.name)
+                                            .foregroundColor(.white)
+                                            .font(.system(size: 15, weight: .medium))
+                                        Spacer()
+                                        Image(systemName: selectedIds.contains(friend.id ?? "") ? "checkmark.circle.fill" : "circle")
+                                            .foregroundColor(selectedIds.contains(friend.id ?? "") ? Color.purple.opacity(0.9) : .white.opacity(0.3))
+                                            .font(.system(size: 22))
+                                    }
+                                    .padding(.horizontal, 12)
+                                    .padding(.vertical, 10)
+                                    .background(Color.white.opacity(0.05), in: RoundedRectangle(cornerRadius: 10))
+                                }
+                                .buttonStyle(.plain)
+                            }
+                        }
+                        .padding(.top, 2)
+                    }
+
+                    Spacer()
+
+                    NavigationLink(isActive: $navigateToGroup) {
+                        CreateGroupChatView(preselectedIds: selectedIds)
+                    } label: { EmptyView() }
+                    .hidden()
+                }
+                .padding(.horizontal, 16)
+                .padding(.top, 14)
+            }
+            .navigationTitle("New message")
+            .navigationBarTitleDisplayMode(.inline)
+            .toolbar {
+                ToolbarItem(placement: .topBarLeading) {
+                    Button("Cancel") { dismiss() }
+                        .foregroundColor(.white)
+                }
+                ToolbarItem(placement: .topBarTrailing) {
+                    Button(action: proceed) {
+                        if isWorking { ProgressView().tint(.white) } else { Text("Next") }
+                    }
+                    .foregroundColor(.white)
+                    .disabled(selectedIds.isEmpty || isWorking)
+                }
+            }
+            .preferredColorScheme(.dark)
+            .onReceive(NotificationCenter.default.publisher(for: .openChat)) { _ in
+                // When a chat opens (esp. after creating a group), close this sheet
+                dismiss()
+            }
+        }
+    }
+
+    private var toRow: some View {
+        VStack(alignment: .leading, spacing: 8) {
+            HStack(alignment: .center, spacing: 10) {
+                Text("To:")
+                    .foregroundColor(.white.opacity(0.7))
+                    .font(.system(size: 15, weight: .medium))
+                ScrollView(.horizontal, showsIndicators: false) {
+                    HStack(spacing: 8) {
+                        ForEach(selectedChips) { chip in
+                            FriendChip(friend: chip.friend) {
+                                if let id = chip.friend.id { selectedIds.remove(id) }
+                            }
+                        }
+                        // Search field inline with chips
+                        TextField("Search", text: $searchText)
+                            .textInputAutocapitalization(.never)
+                            .foregroundColor(.white)
+                            .frame(minWidth: 100)
+                    }
+                }
+            }
+            .padding(.horizontal, 14)
+            .padding(.vertical, 10)
+            .background(Color.white.opacity(0.08), in: RoundedRectangle(cornerRadius: 10))
+        }
+    }
+
+    private var filteredFriends: [Friend] {
+        let q = searchText.trimmingCharacters(in: .whitespacesAndNewlines)
+        guard !q.isEmpty else { return friendsService.friends }
+        return friendsService.friends.filter { $0.name.localizedCaseInsensitiveContains(q) }
+    }
+
+    private var currentUserId: String { Auth.auth().currentUser?.uid ?? "" }
+
+    private var suggestedFriends: [Friend] {
+        // Build from most recent direct chats; fall back to full list
+        let orderedOtherIds: [String] = chatService.chats
+            .filter { $0.type == .direct }
+            .compactMap { $0.otherParticipant(excluding: currentUserId) }
+
+        var seen = Set<String>()
+        var uniqueIds: [String] = []
+        for id in orderedOtherIds {
+            if !seen.contains(id) {
+                uniqueIds.append(id)
+                seen.insert(id)
+            }
+        }
+        let mapped: [Friend] = uniqueIds.compactMap { oid in
+            friendsService.friends.first(where: { $0.id == oid })
+        }
+        let result = mapped.isEmpty ? friendsService.friends : mapped
+        return Array(result.prefix(12))
+    }
+
+    private var selectedChips: [SelectedChip] {
+        friendsService.friends.compactMap { f in
+            guard let fid = f.id, selectedIds.contains(fid) else { return nil }
+            return SelectedChip(id: fid, friend: f)
+        }
+    }
+
+    private func toggle(_ friend: Friend) {
+        guard let id = friend.id else { return }
+        if selectedIds.contains(id) { selectedIds.remove(id) } else { selectedIds.insert(id) }
+    }
+
+    private func proceed() {
+        guard !selectedIds.isEmpty else { return }
+        if selectedIds.count == 1, let onlyId = selectedIds.first, let friend = friendsService.friends.first(where: { $0.id == onlyId }) {
+            // Create/open direct chat, then dismiss and deep-link open
+            isWorking = true
+            Task {
+                do {
+                    let chatId = try await chatService.createDirectChat(with: onlyId, userName: friend.name)
+                    await MainActor.run {
+                        NotificationCenter.default.post(name: .openChat, object: nil, userInfo: ["chatId": chatId])
+                        dismiss()
+                    }
+                } catch {
+                    print("Error creating direct chat: \(error)")
+                }
+                await MainActor.run { isWorking = false }
+            }
+        } else {
+            // Move into group builder with preselected
+            navigateToGroup = true
+        }
+    }
+}
+
+private struct FriendChip: View {
+    let friend: Friend
+    let onRemove: () -> Void
+
+    var body: some View {
+        HStack(spacing: 6) {
+            CachedAsyncImage(url: URL(string: friend.avatarURL ?? ""), content: { image in
+                image.resizable().scaledToFill()
+            }, placeholder: {
+                Circle().fill(Color.purple.opacity(0.3)).overlay(Text(NameInitials.initials(for: friend.name)).font(.caption).foregroundColor(.white))
+            })
+            .frame(width: 22, height: 22)
+            .clipShape(Circle())
+
+            Text(friend.name)
+                .font(.caption)
+                .foregroundColor(.white)
+
+            Button(action: onRemove) {
+                Image(systemName: "xmark.circle.fill").font(.system(size: 14, weight: .bold))
+                    .foregroundColor(.white.opacity(0.8))
+            }
+            .buttonStyle(.plain)
+        }
+        .padding(.horizontal, 6)
+        .padding(.vertical, 5)
+        .background(Color.white.opacity(0.12))
+        .clipShape(Capsule())
+    }
+}
+
+private struct SelectedChip: Identifiable {
+    let id: String
+    let friend: Friend
+}
+
+private struct FriendIconSelectable: View {
+    let friend: Friend
+    let isSelected: Bool
+    let onTap: () -> Void
+
+    var body: some View {
+        Button(action: onTap) {
+            VStack(spacing: 8) {
+                ZStack(alignment: .bottomTrailing) {
+                    CachedAsyncImage(url: URL(string: friend.avatarURL ?? ""), content: { image in
+                        image.resizable().scaledToFill()
+                    }, placeholder: {
+                        Circle().fill(Color.purple.opacity(0.3)).overlay(Text(NameInitials.initials(for: friend.name)).font(.headline).foregroundColor(.white))
+                    })
+                    .frame(width: 52, height: 52)
+                    .clipShape(Circle())
+
+                    Circle()
+                        .fill(isSelected ? Color.brandPurple : Color.white.opacity(0.25))
+                        .frame(width: 16, height: 16)
+                        .overlay(Image(systemName: isSelected ? "checkmark" : "plus").font(.system(size: 9, weight: .bold)).foregroundColor(.white))
+                        .offset(x: 2, y: 1)
+                }
+                Text(friend.name)
+                    .font(.caption2)
+                    .foregroundColor(.white.opacity(0.9))
+                    .lineLimit(1)
+                    .frame(width: 60)
+            }
+        }
+        .buttonStyle(.plain)
+    }
+}
+
 // MARK: - Message Bubble
 
 struct MessageBubbleView: View {
@@ -607,20 +926,20 @@ struct MessageBubbleView: View {
         } else {
             return AnyView(
                 Text(message.text)
-                    .font(.body)
+                    .font(.system(size: 15))
                     .foregroundColor(.white)
-                    .padding(.horizontal, 16)
+                    .padding(.horizontal, 14)
                     .padding(.vertical, 10)
                     .background(
                         Group {
                             if isFromCurrentUser {
-                                LinearGradient(colors: [.purple, .pink], startPoint: .leading, endPoint: .trailing)
+                                Color.purple.opacity(0.3)
                             } else {
-                                LinearGradient(colors: [Color.white.opacity(0.15), Color.white.opacity(0.15)], startPoint: .leading, endPoint: .trailing)
+                                Color.white.opacity(0.1)
                             }
                         }
                     )
-                    .clipShape(RoundedRectangle(cornerRadius: 18))
+                    .clipShape(RoundedRectangle(cornerRadius: 16, style: .continuous))
             )
         }
     }
@@ -653,20 +972,13 @@ struct MessageBubbleView: View {
                                         .overlay(Text(initial).font(.system(size: 8, weight: .semibold)).foregroundColor(.white))
                                     })
                                 } else {
-                                    Circle().fill(
-                                        LinearGradient(
-                                            colors: [Color.purple.opacity(0.4), Color.pink.opacity(0.3)],
-                                            startPoint: .topLeading,
-                                            endPoint: .bottomTrailing
-                                        )
-                                    )
-                                    .overlay(Text(initial).font(.system(size: 8, weight: .semibold)).foregroundColor(.white))
+                                    Circle().fill(Color.white.opacity(0.2))
+                                    .overlay(Text(initial).font(.system(size: 8, weight: .semibold)).foregroundColor(.white.opacity(0.8)))
                                 }
                             }
                             .frame(width: 16, height: 16)
                             .clipShape(Circle())
-                            .overlay(Circle().stroke(Color.black.opacity(0.8), lineWidth: 1.5))
-                            .shadow(color: .black.opacity(0.2), radius: 1, x: 0, y: 0.5)
+                            .overlay(Circle().stroke(Color.black.opacity(0.5), lineWidth: 1))
                         }
                     }
                     .padding(.top, 3)
@@ -801,7 +1113,7 @@ private extension MessageBubbleView {
             .padding(12)
             .background(
                 RoundedRectangle(cornerRadius: 16, style: .continuous)
-                    .fill(LinearGradient(colors: [Color.purple.opacity(0.7), Color.pink.opacity(0.7)], startPoint: .topLeading, endPoint: .bottomTrailing))
+                    .fill(LinearGradient(colors: [Color.brandPurple.opacity(0.7), Color.brandPurple.opacity(0.45)], startPoint: .topLeading, endPoint: .bottomTrailing))
             )
             .overlay(
                 RoundedRectangle(cornerRadius: 16, style: .continuous)
@@ -918,32 +1230,47 @@ struct CreateGroupChatView: View {
     @State private var groupName = ""
     @State private var selectedFriends: Set<String> = []
     @State private var isCreating = false
+    @State private var searchText: String = ""
+
+    var preselectedIds: Set<String> = []
+    @State private var duplicateChat: Chat? = nil
+    @State private var showDuplicateDialog = false
     
     var body: some View {
         NavigationStack {
             VStack(spacing: 0) {
-                VStack(spacing: 16) {
-                    TextField("Group name", text: $groupName)
+                VStack(spacing: 12) {
+                    // Optional name
+                    TextField("Group name (optional)", text: $groupName)
                         .font(.headline).foregroundColor(.white)
-                        .padding(16)
-                        .background(Color.white.opacity(0.1))
+                        .padding(14)
+                        .background(Color.white.opacity(0.10))
                         .clipShape(RoundedRectangle(cornerRadius: 12))
+
+                    // Search bar
+                    HStack(spacing: 10) {
+                        Image(systemName: "magnifyingglass").foregroundColor(.white.opacity(0.7))
+                        TextField("Search friends", text: $searchText)
+                            .foregroundColor(.white)
+                            .textInputAutocapitalization(.never)
+                    }
+                    .padding(12)
+                    .background(Color.white.opacity(0.08), in: RoundedRectangle(cornerRadius: 12))
                 }
                 .padding(.horizontal, 20)
-                .padding(.top, 20)
-                
+                .padding(.top, 16)
+
+                // Friends list
                 VStack(alignment: .leading, spacing: 12) {
-                    Text("Add Friends")
-                        .font(.headline).foregroundColor(.white)
-                        .padding(.horizontal, 20)
                     if friendsService.friends.isEmpty {
                         Text("You need friends to create a group chat")
                             .font(.subheadline).foregroundColor(.white.opacity(0.7))
                             .padding(.horizontal, 20)
+                            .padding(.top, 10)
                     } else {
                         ScrollView {
                             LazyVStack(spacing: 8) {
-                                ForEach(friendsService.friends) { friend in
+                                ForEach(filteredGroupFriends) { friend in
                                     GroupMemberSelectionRow(
                                         user: friend,
                                         isSelected: selectedFriends.contains(friend.id ?? "")
@@ -951,20 +1278,16 @@ struct CreateGroupChatView: View {
                                 }
                             }
                             .padding(.horizontal, 20)
+                            .padding(.top, 6)
                         }
                     }
                 }
-                .padding(.top, 24)
+                .padding(.top, 8)
                 
                 Spacer()
             }
-            .background(
-                LinearGradient(
-                    gradient: Gradient(colors: [Color.black, Color.purple.opacity(0.3)]),
-                    startPoint: .topLeading, endPoint: .bottomTrailing
-                )
-            )
-            .navigationTitle("New Chat")
+            .background(BrandColors.appBackground)
+            .navigationTitle("New group chat")
             .navigationBarTitleDisplayMode(.inline)
             .toolbar {
                 ToolbarItem(placement: .topBarLeading) {
@@ -978,12 +1301,40 @@ struct CreateGroupChatView: View {
                     .disabled(!canCreateGroup)
                 }
             }
+            .onAppear { if !preselectedIds.isEmpty { selectedFriends.formUnion(preselectedIds) } }
+            .confirmationDialog(
+                "A group with the same members already exists.",
+                isPresented: $showDuplicateDialog,
+                titleVisibility: .visible
+            ) {
+                if let existing = duplicateChat, let cid = existing.id {
+                    Button("Open existing") {
+                        NotificationCenter.default.post(name: .openChat, object: nil, userInfo: ["chatId": cid])
+                        dismiss()
+                    }
+                    let typed = groupName.trimmingCharacters(in: .whitespacesAndNewlines)
+                    if !typed.isEmpty {
+                        Button("Rename existing to \(typed)") {
+                            Task {
+                                do { try await chatService.updateGroupName(chatId: cid, newName: typed) }
+                                catch { print("Rename existing failed: \(error)") }
+                                NotificationCenter.default.post(name: .openChat, object: nil, userInfo: ["chatId": cid])
+                                await MainActor.run { dismiss() }
+                            }
+                        }
+                    }
+                }
+                Button("Create new chat", role: .none) {
+                    Task { await actuallyCreateGroup() }
+                }
+                Button("Cancel", role: .cancel) { }
+            }
         }
         .preferredColorScheme(.dark)
     }
     
     private var canCreateGroup: Bool {
-        !groupName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty &&
+        // Group name optional; require at least 1 friend selected
         selectedFriends.count >= 1 && !isCreating
     }
     
@@ -996,15 +1347,52 @@ struct CreateGroupChatView: View {
         }
     }
     
+    private var filteredGroupFriends: [Friend] {
+        let q = searchText.trimmingCharacters(in: .whitespacesAndNewlines)
+        guard !q.isEmpty else { return friendsService.friends }
+        return friendsService.friends.filter { $0.name.localizedCaseInsensitiveContains(q) }
+    }
+
     private func createGroup() async {
         guard canCreateGroup else { return }
+
+        // Duplicate detection using locally loaded chat list
+        let selected = Set(selectedFriends)
+        let me = Auth.auth().currentUser?.uid ?? ""
+        let participantSet = selected.union([me])
+        let candidates = chatService.chats.filter { c in
+            guard c.type == .group else { return false }
+            return Set(c.participants) == participantSet
+        }
+
+        if let existing = candidates.sorted(by: { $0.lastMessageAt > $1.lastMessageAt }).first {
+            await MainActor.run {
+                duplicateChat = existing
+                showDuplicateDialog = true
+            }
+            return
+        }
+
+        await actuallyCreateGroup()
+    }
+
+    private func actuallyCreateGroup(overrideName: String? = nil) async {
         isCreating = true
         defer { isCreating = false }
-        
+
         do {
-            let chatId = try await chatService.createGroupChat(name: groupName, participantIds: Array(selectedFriends))
-            print("Created group chat: \(chatId)")
-            await MainActor.run { dismiss() }
+            let typed = (overrideName ?? groupName).trimmingCharacters(in: .whitespacesAndNewlines)
+            let fallback = friendsService.friends
+                .filter { f in if let fid = f.id { return selectedFriends.contains(fid) } else { return false } }
+                .map(\.name)
+                .prefix(3)
+                .joined(separator: ", ")
+            let finalName = typed.isEmpty ? (fallback.isEmpty ? "Group" : fallback) : typed
+            let chatId = try await chatService.createGroupChat(name: finalName, participantIds: Array(selectedFriends))
+            await MainActor.run {
+                NotificationCenter.default.post(name: .openChat, object: nil, userInfo: ["chatId": chatId])
+                dismiss()
+            }
         } catch {
             print("Error creating group: \(error)")
         }
@@ -1037,10 +1425,52 @@ struct GroupMemberSelectionRow: View {
                 Spacer()
                 Image(systemName: isSelected ? "checkmark.circle.fill" : "circle")
                     .font(.system(size: 20))
-                    .foregroundColor(isSelected ? .purple : .white.opacity(0.4))
+                    .foregroundColor(isSelected ? .brandPurple : .white.opacity(0.4))
             }
             .padding(.vertical, 8)
         }
         .buttonStyle(.plain)
     }
 }
+
+// MARK: - Edit Group Name Sheet
+
+private struct EditGroupNameSheet: View {
+    @State var name: String
+    var onCancel: () -> Void
+    var onSave: (String) -> Void
+
+    init(currentName: String, onCancel: @escaping () -> Void, onSave: @escaping (String) -> Void) {
+        self._name = State(initialValue: currentName)
+        self.onCancel = onCancel
+        self.onSave = onSave
+    }
+
+    var body: some View {
+        VStack(alignment: .leading, spacing: 16) {
+            Text("Edit group name").font(.headline).foregroundColor(.white)
+            TextField("Group name", text: $name)
+                .foregroundColor(.white)
+                .padding(12)
+                .background(Color.white.opacity(0.12), in: RoundedRectangle(cornerRadius: 10))
+
+            HStack {
+                Button("Cancel", action: onCancel)
+                    .foregroundColor(.white.opacity(0.8))
+                Spacer()
+                Button("Save") {
+                    let trimmed = name.trimmingCharacters(in: .whitespacesAndNewlines)
+                    guard !trimmed.isEmpty else { return }
+                    onSave(trimmed)
+                }
+                .foregroundColor(.white)
+                .padding(.horizontal, 16)
+                .padding(.vertical, 8)
+                .background(Color.brandPurple, in: Capsule())
+            }
+        }
+        .padding(20)
+        .background(BrandColors.appBackground)
+        .preferredColorScheme(.dark)
+    }
+}
diff --git a/Buzzd/Features/Social/Views/FriendsHomeView.swift b/Buzzd/Features/Social/Views/FriendsHomeView.swift
index 8e92fde1..69acec4b 100644
--- a/Buzzd/Features/Social/Views/FriendsHomeView.swift
+++ b/Buzzd/Features/Social/Views/FriendsHomeView.swift
@@ -4,6 +4,7 @@ struct FriendsHomeView: View {
     @ObservedObject private var friendsService = FriendsService.shared
     @State private var activeTab: Tab = .requests
     @State private var showingSearch = false
+    @State private var showingAddFriends = false
 
     enum Tab: String, CaseIterable { case requests = "Requests", friends = "Friends" }
 
@@ -11,13 +12,35 @@ struct FriendsHomeView: View {
         NavigationStack {
             ZStack {
                 LinearGradient(
-                    gradient: Gradient(colors: [Color.black, Color.purple.opacity(0.3)]),
-                    startPoint: .topLeading,
-                    endPoint: .bottomTrailing
+                    gradient: Gradient(colors: [
+                        Color(red: 0.05, green: 0.02, blue: 0.12),
+                        Color.black
+                    ]),
+                    startPoint: .top,
+                    endPoint: .bottom
                 )
                 .ignoresSafeArea()
 
                 VStack(spacing: 16) {
+                    HStack {
+                        Button {
+                            showingAddFriends = true
+                        } label: {
+                            HStack(spacing: 8) {
+                                Image(systemName: "person.badge.plus")
+                                    .font(.system(size: 16, weight: .semibold))
+                                Text("Add Friends")
+                                    .font(.system(size: 15, weight: .medium))
+                            }
+                            .foregroundColor(.white)
+                            .padding(.horizontal, 16)
+                            .padding(.vertical, 12)
+                            .frame(maxWidth: .infinity)
+                            .background(Color.purple.opacity(0.25), in: RoundedRectangle(cornerRadius: 12, style: .continuous))
+                        }
+                        .buttonStyle(.plain)
+                    }
+                    .padding(.horizontal, 16)
                     segmentedPills
                         .padding(.horizontal, 16)
 
@@ -38,6 +61,7 @@ struct FriendsHomeView: View {
                 }
             }
             .sheet(isPresented: $showingSearch) { UserSearchView() }
+            .sheet(isPresented: $showingAddFriends) { AddFriendsView() }
         }
         .preferredColorScheme(.dark)
         .onAppear { friendsService.startListening() }
@@ -58,20 +82,11 @@ struct FriendsHomeView: View {
     private func pill(title: String, isActive: Bool, action: @escaping () -> Void) -> some View {
         Button(action: action) {
             Text(title)
-                .font(.subheadline.weight(.semibold))
+                .font(.system(size: 15, weight: .medium))
                 .foregroundColor(.white)
-                .padding(.horizontal, 18).padding(.vertical, 10)
-                .background {
-                    if isActive {
-                        LinearGradient(colors: [Color.purple, Color.pink], startPoint: .leading, endPoint: .trailing)
-                    } else {
-                        Color.white.opacity(0.12)
-                    }
-                }
+                .padding(.horizontal, 20).padding(.vertical, 9)
+                .background(isActive ? Color.purple.opacity(0.4) : Color.white.opacity(0.08))
                 .clipShape(Capsule())
-                .overlay(
-                    Capsule().stroke(Color.white.opacity(0.18), lineWidth: 1)
-                )
         }
         .buttonStyle(.plain)
     }
@@ -81,10 +96,9 @@ struct FriendsHomeView: View {
             VStack(spacing: 16) {
                 // Outgoing (sent) requests section
                 VStack(alignment: .leading, spacing: 8) {
-                    Text("Outgoing")
-                        .font(.headline)
-                        .fontWeight(.bold)
-                        .foregroundColor(.white)
+                    Text("SENT")
+                        .font(.system(size: 12, weight: .semibold))
+                        .foregroundColor(.white.opacity(0.5))
 
                     if friendsService.sentRequests.isEmpty {
                         VStack(spacing: 8) {
@@ -119,10 +133,9 @@ struct FriendsHomeView: View {
 
                 // Incoming requests section
                 VStack(alignment: .leading, spacing: 8) {
-                    Text("Incoming")
-                        .font(.headline)
-                        .fontWeight(.bold)
-                        .foregroundColor(.white)
+                    Text("RECEIVED")
+                        .font(.system(size: 12, weight: .semibold))
+                        .foregroundColor(.white.opacity(0.5))
 
                     if friendsService.friendRequests.isEmpty {
                         VStack(spacing: 8) {
@@ -239,33 +252,33 @@ private struct FriendRequestRow: View {
         HStack(spacing: 12) {
             AsyncImage(url: URL(string: request.senderAvatarURL ?? "")) { phase in
                 if case .success(let image) = phase { image.resizable().scaledToFill() }
-                else { Circle().fill(Color.purple.opacity(0.35)) }
+                else { Circle().fill(Color.white.opacity(0.15)) }
             }
-            .frame(width: 48, height: 48)
+            .frame(width: 44, height: 44)
             .clipShape(Circle())
 
             VStack(alignment: .leading, spacing: 2) {
-                Text(request.senderName).font(.subheadline.weight(.semibold)).foregroundColor(.white)
+                Text(request.senderName).font(.system(size: 15, weight: .medium)).foregroundColor(.white)
                 Text("@\(usernameFromEmail(request.senderEmail))")
-                    .font(.caption).foregroundColor(.white.opacity(0.7))
+                    .font(.system(size: 13)).foregroundColor(.white.opacity(0.5))
             }
             Spacer()
             if isProcessing { ProgressView().tint(.white) } else {
                 HStack(spacing: 8) {
-                    Button { accept() } label: { labelButton("Accept", color: .green) }
-                    Button { decline() } label: { labelButton("Delete", color: .red) }
+                    Button { accept() } label: { labelButton("Accept", color: .white) }
+                    Button { decline() } label: { labelButton("Decline", color: .white.opacity(0.6)) }
                 }
             }
         }
         .padding(12)
-        .background(Color.white.opacity(0.08))
-        .clipShape(RoundedRectangle(cornerRadius: 12))
+        .background(Color.white.opacity(0.05))
+        .clipShape(RoundedRectangle(cornerRadius: 10))
     }
 
     private func labelButton(_ title: String, color: Color) -> some View {
-        Text(title).font(.caption.weight(.semibold)).foregroundColor(.white)
-            .padding(.horizontal, 10).padding(.vertical, 6)
-            .background(color.opacity(0.8))
+        Text(title).font(.system(size: 13, weight: .medium)).foregroundColor(.white)
+            .padding(.horizontal, 12).padding(.vertical, 6)
+            .background(title == "Accept" ? Color.purple.opacity(0.6) : Color.white.opacity(0.1))
             .clipShape(Capsule())
     }
 
@@ -296,22 +309,22 @@ private struct FriendRowCompact: View {
         HStack(spacing: 12) {
             AsyncImage(url: URL(string: friend.avatarURL ?? "")) { phase in
                 if case .success(let img) = phase { img.resizable().scaledToFill() }
-                else { Circle().fill(Color.purple.opacity(0.35)) }
+                else { Circle().fill(Color.white.opacity(0.15)) }
             }
             .frame(width: 44, height: 44)
             .clipShape(Circle())
 
             VStack(alignment: .leading, spacing: 2) {
-                Text(friend.name).font(.subheadline.weight(.semibold)).foregroundColor(.white)
+                Text(friend.name).font(.system(size: 15, weight: .medium)).foregroundColor(.white)
                 if let email = friend.email.split(separator: "@").first {
-                    Text("@\(email)").font(.caption).foregroundColor(.white.opacity(0.7))
+                    Text("@\(email)").font(.system(size: 13)).foregroundColor(.white.opacity(0.5))
                 }
             }
             Spacer()
         }
         .padding(12)
-        .background(Color.white.opacity(0.08))
-        .clipShape(RoundedRectangle(cornerRadius: 12))
+        .background(Color.white.opacity(0.05))
+        .clipShape(RoundedRectangle(cornerRadius: 10))
         .contextMenu {
             Button {
                 onViewProfile?()
diff --git a/Buzzd/Features/Social/Views/FriendsViews.swift b/Buzzd/Features/Social/Views/FriendsViews.swift
index 9e37dd86..cb27ec10 100644
--- a/Buzzd/Features/Social/Views/FriendsViews.swift
+++ b/Buzzd/Features/Social/Views/FriendsViews.swift
@@ -62,7 +62,7 @@ struct FriendsListView: View {
                         showingFriendRequests = true
                     }
                     .font(.subheadline)
-                    .foregroundColor(.purple)
+                    .foregroundStyle(BrandColors.neonGradient)
                 }
                 
                 // Show first 2 requests
@@ -89,7 +89,7 @@ struct FriendsListView: View {
                         showingSentRequests = true
                     }
                     .font(.subheadline)
-                    .foregroundColor(.purple)
+                    .foregroundStyle(BrandColors.neonGradient)
                 }
 
                 ForEach(friendsService.sentRequests.prefix(2)) { request in
@@ -170,14 +170,14 @@ struct FriendRequestCard: View {
                 image.resizable().scaledToFill()
             }, placeholder: {
                 Circle()
-                    .fill(Color.purple.opacity(0.3))
+                    .fill(Color.white.opacity(0.15))
                     .overlay(
                         Text(NameInitials.initials(for: request.senderName))
-                            .font(.headline)
-                            .foregroundColor(.white)
+                            .font(.system(size: 16, weight: .medium))
+                            .foregroundColor(.white.opacity(0.8))
                     )
             })
-            .frame(width: 50, height: 50)
+            .frame(width: 48, height: 48)
             .clipShape(Circle())
             
             VStack(alignment: .leading, spacing: 4) {
@@ -205,6 +205,10 @@ struct FriendRequestCard: View {
                 Text("Accepted")
                     .font(.caption.weight(.semibold))
                     .foregroundColor(.green)
+            } else if request.status == .declined {
+                Text("Declined")
+                    .font(.caption.weight(.semibold))
+                    .foregroundColor(.red.opacity(0.8))
             } else {
                 HStack(spacing: 8) {
                     Button {
@@ -217,7 +221,7 @@ struct FriendRequestCard: View {
                             .background(Color.green.opacity(0.8))
                             .clipShape(Circle())
                     }
-                    
+
                     Button {
                         declineRequest()
                     } label: {
@@ -232,8 +236,9 @@ struct FriendRequestCard: View {
             }
         }
         .padding(12)
-        .background(Color.white.opacity(0.08))
+        .background(Color.black.opacity(0.6))
         .clipShape(RoundedRectangle(cornerRadius: 12))
+        .neonBorder(cornerRadius: 12, lineWidth: 1)
     }
     
     private func acceptRequest() {
@@ -300,14 +305,14 @@ struct SentRequestRow: View {
                 image.resizable().scaledToFill()
             }, placeholder: {
                 Circle()
-                    .fill(Color.orange.opacity(0.25))
+                    .fill(Color.white.opacity(0.15))
                     .overlay(
                         Text(NameInitials.initials(for: request.recipientName ?? ""))
-                            .font(.headline)
-                            .foregroundColor(.orange)
+                            .font(.system(size: 16, weight: .medium))
+                            .foregroundColor(.white.opacity(0.8))
                     )
             })
-            .frame(width: 50, height: 50)
+            .frame(width: 48, height: 48)
             .clipShape(Circle())
 
             VStack(alignment: .leading, spacing: 4) {
@@ -340,8 +345,9 @@ struct SentRequestRow: View {
             }
         }
         .padding(12)
-        .background(Color.white.opacity(0.08))
+        .background(Color.black.opacity(0.6))
         .clipShape(RoundedRectangle(cornerRadius: 12))
+        .neonBorder(cornerRadius: 12, lineWidth: 1)
     }
 
     private func cancel() {
@@ -371,12 +377,8 @@ struct SentRequestsView: View {
 
     var body: some View {
         ZStack {
-            LinearGradient(
-                gradient: Gradient(colors: [Color.black, Color.purple.opacity(0.3)]),
-                startPoint: .topLeading,
-                endPoint: .bottomTrailing
-            )
-            .ignoresSafeArea()
+            BrandColors.appBackground
+                .ignoresSafeArea()
 
             VStack(spacing: 0) {
                 // Custom Header
@@ -429,11 +431,11 @@ struct FriendCard: View {
                 image.resizable().scaledToFill()
             }, placeholder: {
                 Circle()
-                    .fill(Color.purple.opacity(0.3))
+                    .fill(Color.white.opacity(0.15))
                     .overlay(
                         Text(NameInitials.initials(for: friend.name))
-                            .font(.headline)
-                            .foregroundColor(.white)
+                            .font(.system(size: 16, weight: .medium))
+                            .foregroundColor(.white.opacity(0.8))
                     )
             })
             .frame(width: 44, height: 44)
@@ -547,12 +549,8 @@ struct FriendRequestsView: View {
 
     var body: some View {
         ZStack {
-            LinearGradient(
-                gradient: Gradient(colors: [Color.black, Color.purple.opacity(0.3)]),
-                startPoint: .topLeading,
-                endPoint: .bottomTrailing
-            )
-            .ignoresSafeArea()
+            BrandColors.appBackground
+                .ignoresSafeArea()
 
             VStack(spacing: 0) {
                 // Custom Header
diff --git a/Buzzd/Features/Social/Views/SocialView.swift b/Buzzd/Features/Social/Views/SocialView.swift
index 2d8129cb..ced8bf0d 100644
--- a/Buzzd/Features/Social/Views/SocialView.swift
+++ b/Buzzd/Features/Social/Views/SocialView.swift
@@ -14,27 +14,24 @@ struct SocialView: View {
 
     @State private var showingUserSearch = false
     @State private var showingCreateGroup = false
+    @State private var showingAddFriends = false
     @State private var showingNotifications = false
     @State private var showingFriends = false
     @State private var searchText = ""
     @State private var startingChat = false
     @State private var selectedChat: Chat?
     @State private var showingChatView = false
+    @State private var lastOpenedChatId: String? = nil
 
     private let bottomSafeGap: CGFloat = 94
 
     var body: some View {
         NavigationStack {
             ZStack {
-                LinearGradient(
-                    gradient: Gradient(colors: [Color(red: 10/255, green: 2/255, blue: 26/255),
-                                                Color(red: 46/255, green: 9/255, blue: 64/255)]),
-                    startPoint: .topLeading,
-                    endPoint: .bottomTrailing
-                )
-                .ignoresSafeArea()
+                BrandColors.appBackground
+                    .ignoresSafeArea()
 
-                VStack(spacing: 20) {
+                VStack(spacing: 16) {
                     header
                     searchBar
                     actionRow
@@ -42,12 +39,13 @@ struct SocialView: View {
                         .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .top)
                     Spacer(minLength: bottomSafeGap)
                 }
-                .padding(.horizontal, 20)
+                .padding(.horizontal, 16)
                 .padding(.top, 12)
             }
             .sheet(isPresented: $showingUserSearch) { UserSearchView() }
             .sheet(isPresented: $showingFriends) { FriendsHomeView() }
-            .sheet(isPresented: $showingCreateGroup) { CreateGroupChatView() }
+            .sheet(isPresented: $showingCreateGroup) { NewMessageView() }
+            .sheet(isPresented: $showingAddFriends) { AddFriendsView() }
             .sheet(isPresented: $showingNotifications) { NotificationsView() }
             .onAppear { startAllServices() }
             .onDisappear { stopAllServices() }
@@ -61,11 +59,14 @@ struct SocialView: View {
         .preferredColorScheme(.dark)
         .onReceive(NotificationCenter.default.publisher(for: .openChat)) { note in
             guard let chatId = (note.userInfo?["chatId"] as? String)?.trimmingCharacters(in: .whitespacesAndNewlines), !chatId.isEmpty else { return }
+            if lastOpenedChatId == chatId { return }
             Task { @MainActor in
                 do {
                     let chat = try await ChatService.shared.fetchChat(withId: chatId)
                     selectedChat = chat
                     showingChatView = true
+                    lastOpenedChatId = chatId
+                    DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) { lastOpenedChatId = nil }
                 } catch {
                     print("Failed to open chat for id \(chatId): \(error)")
                 }
@@ -82,13 +83,13 @@ struct SocialView: View {
     // MARK: - Header
     private var header: some View {
         HStack(alignment: .center) {
-            Text("Social")
-                .font(.system(size: 34, weight: .bold, design: .rounded))
+            Text("Messages")
+                .font(.system(size: 28, weight: .semibold))
                 .foregroundColor(.white)
 
             Spacer()
 
-            HStack(spacing: 12) {
+            HStack(spacing: 16) {
                 ZStack(alignment: .topTrailing) {
                     headerButton(icon: "bell") {
                         showingNotifications = true
@@ -96,12 +97,16 @@ struct SocialView: View {
                     if notificationService.unreadCount > 0 {
                         Circle()
                             .fill(Color.red)
-                            .frame(width: 10, height: 10)
-                            .offset(x: -6, y: 6)
+                            .frame(width: 8, height: 8)
+                            .offset(x: -4, y: 4)
                     }
                 }
 
-                headerButton(icon: "person.2.fill") {
+                headerButton(icon: "person.badge.plus") {
+                    showingAddFriends = true
+                }
+
+                headerButton(icon: "person.2") {
                     showingFriends = true
                 }
             }
@@ -109,11 +114,12 @@ struct SocialView: View {
     }
 
     private var searchBar: some View {
-        HStack(spacing: 12) {
+        HStack(spacing: 10) {
             Image(systemName: "magnifyingglass")
-                .foregroundColor(.white.opacity(0.7))
+                .foregroundColor(.white.opacity(0.5))
+                .font(.system(size: 16))
 
-            TextField("Search", text: $searchText)
+            TextField("Search messages", text: $searchText)
                 .textInputAutocapitalization(.never)
                 .disableAutocorrection(true)
                 .foregroundColor(.white)
@@ -123,23 +129,24 @@ struct SocialView: View {
                     searchText = ""
                 } label: {
                     Image(systemName: "xmark.circle.fill")
-                        .foregroundColor(.white.opacity(0.6))
+                        .foregroundColor(.white.opacity(0.4))
                 }
                 .buttonStyle(.plain)
             }
         }
-        .padding(.horizontal, 16)
-        .padding(.vertical, 14)
-        .background(Color.white.opacity(0.12), in: RoundedRectangle(cornerRadius: 18, style: .continuous))
+        .padding(.horizontal, 14)
+        .padding(.vertical, 10)
+        .background(Color.white.opacity(0.08), in: RoundedRectangle(cornerRadius: 12, style: .continuous))
+        .neonBorder(cornerRadius: 12, lineWidth: 1)
     }
 
     private func headerButton(icon: String, action: @escaping () -> Void) -> some View {
         Button(action: action) {
             Image(systemName: icon)
-                .font(.system(size: 20, weight: .semibold))
+                .font(.system(size: 18, weight: .medium))
                 .foregroundColor(.white)
-                .frame(width: 48, height: 48)
-                .background(Color.white.opacity(0.12), in: RoundedRectangle(cornerRadius: 16, style: .continuous))
+                .frame(width: 36, height: 36)
+                .background(Color.white.opacity(0.1), in: Circle())
         }
         .buttonStyle(.plain)
     }
@@ -166,35 +173,22 @@ struct SocialView: View {
 private extension SocialView {
     // Simple actions row: New Group under the search bar
     var actionRow: some View {
-        HStack(spacing: 0) {
-            Button {
-                showingCreateGroup = true
-            } label: {
-                HStack(spacing: 10) {
-                    Image(systemName: "message.fill")
-                        .font(.system(size: 18, weight: .bold))
-                    Text("New Chat")
-                        .font(.subheadline.weight(.semibold))
-                }
-                .foregroundColor(.white)
-                .padding(.horizontal, 16)
-                .padding(.vertical, 12)
-                .frame(maxWidth: .infinity)
-                .background(
-                    LinearGradient(colors: [Color.purple, Color.pink], startPoint: .leading, endPoint: .trailing),
-                    in: RoundedRectangle(cornerRadius: 16, style: .continuous)
-                )
-                .overlay(
-                    RoundedRectangle(cornerRadius: 16, style: .continuous)
-                        .stroke(Color.white.opacity(0.18), lineWidth: 1)
-                )
-                .shadow(color: Color.purple.opacity(0.22), radius: 10, y: 8)
-                .accessibilityLabel("Start a new chat")
+        Button {
+            showingCreateGroup = true
+        } label: {
+            HStack(spacing: 8) {
+                Image(systemName: "plus.circle.fill")
+                    .font(.system(size: 16, weight: .semibold))
+                Text("New Message")
+                    .font(.subheadline.weight(.medium))
             }
-            .buttonStyle(.plain)
+            .foregroundColor(.white)
+            .frame(maxWidth: .infinity)
+            .padding(.vertical, 12)
+            .background(Color.white.opacity(0.06), in: RoundedRectangle(cornerRadius: 12, style: .continuous))
+            .neonBorder(cornerRadius: 12, lineWidth: 1)
         }
-        .lineLimit(1)
-        .minimumScaleFactor(0.9)
+        .buttonStyle(.plain)
     }
 
     func startChat(with friend: Friend) {
diff --git a/Buzzd/Features/Social/Views/SubscriptionsandNotifications.swift b/Buzzd/Features/Social/Views/SubscriptionsandNotifications.swift
index b76d763b..091c541e 100644
--- a/Buzzd/Features/Social/Views/SubscriptionsandNotifications.swift
+++ b/Buzzd/Features/Social/Views/SubscriptionsandNotifications.swift
@@ -240,11 +240,15 @@ struct NotificationsView: View {
         NavigationStack {
             ZStack {
                 LinearGradient(
-                    gradient: Gradient(colors: [Color.black, Color.purple.opacity(0.3)]),
-                    startPoint: .topLeading, endPoint: .bottomTrailing
+                    gradient: Gradient(colors: [
+                        Color(red: 0.05, green: 0.02, blue: 0.12),
+                        Color.black
+                    ]),
+                    startPoint: .top,
+                    endPoint: .bottom
                 )
                 .ignoresSafeArea()
-                
+
                 VStack(spacing: 0) {
                     if notificationService.notifications.isEmpty {
                         emptyStateView
@@ -287,37 +291,18 @@ struct NotificationsView: View {
     }
     
     private var emptyStateView: some View {
-        VStack(spacing: 20) {
-            ZStack {
-                Circle()
-                    .fill(
-                        LinearGradient(
-                            colors: [Color.purple.opacity(0.2), Color.pink.opacity(0.15)],
-                            startPoint: .topLeading,
-                            endPoint: .bottomTrailing
-                        )
-                    )
-                    .frame(width: 120, height: 120)
-                    .blur(radius: 20)
+        VStack(spacing: 16) {
+            Image(systemName: "bell.slash")
+                .font(.system(size: 56, weight: .light))
+                .foregroundColor(.white.opacity(0.4))
 
-                Image(systemName: "bell.slash.fill")
-                    .font(.system(size: 56, weight: .light))
-                    .foregroundStyle(
-                        LinearGradient(
-                            colors: [.white.opacity(0.8), .white.opacity(0.5)],
-                            startPoint: .topLeading,
-                            endPoint: .bottomTrailing
-                        )
-                    )
-            }
-
-            VStack(spacing: 8) {
+            VStack(spacing: 6) {
                 Text("No Notifications")
-                    .font(.title3.weight(.semibold))
+                    .font(.system(size: 20, weight: .semibold))
                     .foregroundColor(.white)
-                Text("You're all caught up!")
-                    .font(.subheadline)
-                    .foregroundColor(.white.opacity(0.7))
+                Text("You're all caught up")
+                    .font(.system(size: 15))
+                    .foregroundColor(.white.opacity(0.5))
             }
         }
         .frame(maxWidth: .infinity, maxHeight: .infinity)
@@ -377,34 +362,26 @@ struct NotificationRowView: View {
                 Button {
                     onTap()
                 } label: {
-                    HStack(spacing: 14) {
+                    HStack(spacing: 12) {
                         notificationIcon
-                        VStack(alignment: .leading, spacing: 5) {
+                        VStack(alignment: .leading, spacing: 4) {
                             Text(notification.title)
-                                .font(.subheadline)
-                                .fontWeight(notification.isRead ? .medium : .semibold)
+                                .font(.system(size: 15, weight: notification.isRead ? .medium : .semibold))
                                 .foregroundColor(.white)
                                 .lineLimit(2)
                             Text(notification.body)
-                                .font(.caption)
-                                .foregroundColor(.white.opacity(notification.isRead ? 0.65 : 0.85))
-                                .lineLimit(3)
+                                .font(.system(size: 14))
+                                .foregroundColor(.white.opacity(notification.isRead ? 0.5 : 0.7))
+                                .lineLimit(2)
                             Text(timeAgoString(from: notification.createdAt))
-                                .font(.caption2)
-                                .foregroundColor(.white.opacity(0.5))
+                                .font(.system(size: 12))
+                                .foregroundColor(.white.opacity(0.4))
                         }
                         Spacer(minLength: 8)
                         if !notification.isRead {
                             Circle()
-                                .fill(
-                                    LinearGradient(
-                                        colors: [Color.purple, Color.pink],
-                                        startPoint: .topLeading,
-                                        endPoint: .bottomTrailing
-                                    )
-                                )
-                                .frame(width: 10, height: 10)
-                                .shadow(color: .purple.opacity(0.5), radius: 3, x: 0, y: 0)
+                                .fill(Color.purple.opacity(0.9))
+                                .frame(width: 8, height: 8)
                         }
                     }
                 }
@@ -477,45 +454,11 @@ struct NotificationRowView: View {
                     .foregroundColor(.green)
                 }
             }
-            .padding(14)
+            .padding(12)
             .background(
-                Group {
-                    if notification.isRead {
-                        Color.white.opacity(0.04)
-                    } else {
-                        LinearGradient(
-                            colors: [Color.white.opacity(0.12), Color.white.opacity(0.08)],
-                            startPoint: .topLeading,
-                            endPoint: .bottomTrailing
-                        )
-                    }
-                }
-            )
-            .clipShape(RoundedRectangle(cornerRadius: 16, style: .continuous))
-            .overlay(
-                Group {
-                    if notification.isRead {
-                        RoundedRectangle(cornerRadius: 16, style: .continuous)
-                            .stroke(Color.white.opacity(0.06), lineWidth: 0.5)
-                    } else {
-                        RoundedRectangle(cornerRadius: 16, style: .continuous)
-                            .stroke(
-                                LinearGradient(
-                                    colors: [Color.purple.opacity(0.3), Color.pink.opacity(0.2)],
-                                    startPoint: .topLeading,
-                                    endPoint: .bottomTrailing
-                                ),
-                                lineWidth: 1
-                            )
-                    }
-                }
-            )
-            .shadow(
-                color: notification.isRead ? .clear : .purple.opacity(0.1),
-                radius: notification.isRead ? 0 : 8,
-                x: 0,
-                y: notification.isRead ? 0 : 4
+                Color.white.opacity(notification.isRead ? 0.04 : 0.08)
             )
+            .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
             .opacity(appeared ? 1 : 0)
             .offset(x: appeared ? 0 : 20)
             .scaleEffect(appeared ? 1 : 0.95, anchor: .leading)
@@ -534,43 +477,36 @@ struct NotificationRowView: View {
 
         @ViewBuilder
         private var notificationIcon: some View {
-            let iconData = getIconData(for: notification.type)
+            let iconName = getIconName(for: notification.type)
             ZStack {
                 Circle()
-                    .fill(
-                        LinearGradient(
-                            colors: iconData.gradientColors,
-                            startPoint: .topLeading,
-                            endPoint: .bottomTrailing
-                        )
-                    )
-                    .frame(width: 44, height: 44)
-                    .shadow(color: iconData.gradientColors[0].opacity(0.4), radius: 6, x: 0, y: 3)
+                    .fill(Color.white.opacity(0.15))
+                    .frame(width: 40, height: 40)
 
-                Image(systemName: iconData.iconName)
-                    .font(.system(size: 18, weight: .semibold))
-                    .foregroundColor(.white)
-                    .shadow(color: .black.opacity(0.2), radius: 1, x: 0, y: 1)
+                Image(systemName: iconName)
+                    .font(.system(size: 16, weight: .medium))
+                    .foregroundColor(.white.opacity(0.8))
             }
         }
 
-        private func getIconData(for type: NotificationType)
-        -> (iconName: String, gradientColors: [Color]) {
+        private func getIconName(for type: NotificationType) -> String {
             switch type {
             case .friendRequest:
-                return ("person.badge.plus", [Color.blue.opacity(0.9), Color.blue.opacity(0.6)])
+                return "person.badge.plus"
             case .friendAccepted:
-                return ("person.2.fill", [Color.green.opacity(0.9), Color.green.opacity(0.6)])
+                return "person.2"
             case .newMessage:
-                return ("message.fill", [Color.purple.opacity(0.9), Color.pink.opacity(0.7)])
+                return "message"
             case .hostEvent:
-                return ("calendar.badge.plus", [Color.orange.opacity(0.9), Color.orange.opacity(0.6)])
+                return "calendar.badge.plus"
             case .hostPosted:
-                return ("sparkles", [Color.orange.opacity(0.9), Color.yellow.opacity(0.7)])
+                return "sparkles"
+            case .hostUpdated:
+                return "pencil"
             case .eventReminder:
-                return ("clock.fill", [Color.yellow.opacity(0.9), Color.orange.opacity(0.6)])
+                return "clock"
             case .groupInvite:
-                return ("person.3.fill", [Color.teal.opacity(0.9), Color.cyan.opacity(0.6)])
+                return "person.3"
             }
         }
         
@@ -614,12 +550,23 @@ extension NotificationRowView {
      
     func resolveRequestIdIfNeededAsync() async {
         guard notification.type == .friendRequest,
-              notification.actionId == nil,
-              resolvedRequestId == nil,
               let uid = Auth.auth().currentUser?.uid else { return }
 
         let db = Firestore.firestore()
         do {
+            // If we have an actionId (friend request id), resolve its status directly
+            if let reqId = notification.actionId, !reqId.isEmpty {
+                let doc = try await db.collection("friendRequests").document(reqId).getDocument()
+                if let data = doc.data(), let status = data["status"] as? String {
+                    await MainActor.run {
+                        resolvedRequestId = reqId
+                        accepted = (status.lowercased() == "accepted")
+                    }
+                    return
+                }
+            }
+
+            // Otherwise, try to infer from actor/sender
             if let senderId = notification.actorId, !senderId.isEmpty {
                 // First, check for pending
                 let snap = try await db.collection("friendRequests")
@@ -631,7 +578,7 @@ extension NotificationRowView {
                 if let doc = snap.documents.first {
                     await MainActor.run { resolvedRequestId = doc.documentID }
                 } else {
-                    // If not pending, see if it's already accepted ‚Äì persist accepted UI state
+                    // If not pending, check accepted
                     let acceptedSnap = try await db.collection("friendRequests")
                         .whereField("senderId", isEqualTo: senderId)
                         .whereField("recipientId", isEqualTo: uid)
@@ -656,6 +603,14 @@ extension NotificationRowView {
                     await MainActor.run { resolvedRequestId = snap.documents[0].documentID }
                 }
             }
+
+            // Final guard: if we can read a friend-link for sender -> me, treat as accepted
+            if let senderId = notification.actorId, !senderId.isEmpty {
+                let link = try await db.collection("users").document(uid).collection("friends").document(senderId).getDocument()
+                if link.exists {
+                    await MainActor.run { accepted = true }
+                }
+            }
         } catch {
             // Silent: failing to resolve id should not impact UI
         }
diff --git a/Buzzd/Features/Social/Views/UserSearchView.swift b/Buzzd/Features/Social/Views/UserSearchView.swift
index 8ad415a8..fd74d5ec 100644
--- a/Buzzd/Features/Social/Views/UserSearchView.swift
+++ b/Buzzd/Features/Social/Views/UserSearchView.swift
@@ -8,6 +8,9 @@
 import SwiftUI
 
 struct UserSearchView: View {
+    // When embedded inside another container (e.g., Add Friends),
+    // render without our own background and navigation chrome.
+    var embedded: Bool = false
     @StateObject private var friendsService = FriendsService.shared
     @Environment(\.dismiss) private var dismiss
     
@@ -19,50 +22,51 @@ struct UserSearchView: View {
     @State private var isAlertPresented = false
     
     var body: some View {
-        NavigationStack {
-            ZStack {
-                // Background gradient
-                LinearGradient(
-                    gradient: Gradient(colors: [Color.black, Color.purple.opacity(0.3)]),
-                    startPoint: .topLeading,
-                    endPoint: .bottomTrailing
-                )
-                .ignoresSafeArea()
-                
+        Group {
+            if embedded {
                 VStack(spacing: 0) {
                     searchBar
-                    
-                    if isSearching {
-                        loadingView
-                    } else if searchResults.isEmpty && !searchText.isEmpty {
-                        emptyStateView
-                    } else {
-                        searchResultsList
+                    if isSearching { loadingView }
+                    else if searchResults.isEmpty && !searchText.isEmpty { emptyStateView }
+                    else { searchResultsList }
+                }
+                .preferredColorScheme(.dark)
+            } else {
+                NavigationStack {
+                    ZStack {
+                        // Background gradient
+                        LinearGradient(
+                            gradient: Gradient(colors: [Color.black, Color.purple.opacity(0.3)]),
+                            startPoint: .topLeading,
+                            endPoint: .bottomTrailing
+                        )
+                        .ignoresSafeArea()
+
+                        VStack(spacing: 0) {
+                            searchBar
+                            if isSearching { loadingView }
+                            else if searchResults.isEmpty && !searchText.isEmpty { emptyStateView }
+                            else { searchResultsList }
+                        }
                     }
                 }
+                .navigationTitle("Find Friends")
+                .navigationBarTitleDisplayMode(.inline)
+                .toolbar {
+                    ToolbarItem(placement: .topBarTrailing) {
+                        Button("Done") { dismiss() }
+                            .foregroundColor(.white)
+                    }
+                }
+                .preferredColorScheme(.dark)
             }
         }
-        .navigationTitle("Find Friends")
-        .navigationBarTitleDisplayMode(.inline)
-        .toolbar {
-            ToolbarItem(placement: .topBarTrailing) {
-                Button("Done") { dismiss() }
-                    .foregroundColor(.white)
-            }
-        }
-        .preferredColorScheme(.dark)
         .onChange(of: searchText) { newValue in
             searchTask?.cancel()
-            searchTask = Task {
-                await performSearch(query: newValue)
-            }
+            searchTask = Task { await performSearch(query: newValue) }
         }
-        .onDisappear {
-            searchTask?.cancel()
-        }
-        .alert(alertMessage ?? "", isPresented: $isAlertPresented, actions: {
-            Button("OK", role: .cancel) {}
-        })
+        .onDisappear { searchTask?.cancel() }
+        .alert(alertMessage ?? "", isPresented: $isAlertPresented, actions: { Button("OK", role: .cancel) {} })
     }
     
     // MARK: - Search Bar
@@ -72,7 +76,7 @@ struct UserSearchView: View {
             Image(systemName: "magnifyingglass")
                 .foregroundColor(.white.opacity(0.6))
             
-            TextField("Search by username...", text: $searchText)
+            TextField("Search by @username or name", text: $searchText)
                 .foregroundColor(.white)
                 .keyboardType(.asciiCapable)
                 .textInputAutocapitalization(.never)
@@ -154,12 +158,14 @@ struct UserSearchView: View {
         await MainActor.run {
             isSearching = true
         }
-        
-        // Add small delay to debounce
-        try? await Task.sleep(nanoseconds: 300_000_000) // 0.3 seconds
+
+        // Snappy debounce for typeahead (~Instagram-like)
+        try? await Task.sleep(nanoseconds: 150_000_000) // 0.15 seconds
+        if Task.isCancelled { return }
         
         do {
             let results = try await friendsService.searchUsers(query: trimmedQuery)
+            if Task.isCancelled { return }
             
             await MainActor.run {
                 searchResults = results
@@ -268,12 +274,17 @@ struct UserSearchResultRow: View {
         switch result.friendshipStatus {
         case .none:
             Button { onSendRequest() } label: {
-                Image(systemName: "person.badge.plus")
-                    .font(.system(size: 16))
-                    .foregroundColor(.white)
-                    .padding(8)
-                    .background(Color.purple.opacity(0.8))
-                    .clipShape(Circle())
+                HStack(spacing: 6) {
+                    Image(systemName: "person.badge.plus")
+                        .font(.system(size: 14, weight: .semibold))
+                    Text("Add Friend")
+                        .font(.caption.weight(.semibold))
+                }
+                .foregroundColor(.white)
+                .padding(.horizontal, 12)
+                .padding(.vertical, 8)
+                .background(LinearGradient(colors: [Color.purple, Color.pink], startPoint: .leading, endPoint: .trailing))
+                .clipShape(Capsule())
             }
 
         case .pending:
diff --git a/Buzzd/Info.plist b/Buzzd/Info.plist
index f526c83f..f1156df2 100644
--- a/Buzzd/Info.plist
+++ b/Buzzd/Info.plist
@@ -21,12 +21,14 @@
 	<true/>
 	<key>FirebaseAppDelegateProxyEnabled</key>
 	<false/>
-    <key>ITSAppUsesNonExemptEncryption</key>
-    <false/>
+	<key>ITSAppUsesNonExemptEncryption</key>
+	<false/>
 	<key>GOOGLE_PLACES_API_KEY</key>
 	<string>$(GOOGLE_PLACES_API_KEY)</string>
 	<key>MAPBOX_ACCESS_TOKEN</key>
 	<string>$(MAPBOX_ACCESS_TOKEN)</string>
+	<key>PLACES_BACKEND_URL</key>
+	<string>https://us-central1-buzzd-app-170b4.cloudfunctions.net</string>
 	<key>MERCHANT_COUNTRY_CODE</key>
 	<string>US</string>
 	<key>NSLocationWhenInUseUsageDescription</key>
@@ -43,3 +45,4 @@
 	</array>
 </dict>
 </plist>
+
diff --git a/Buzzd/Utils/AppConfiguration.swift b/Buzzd/Utils/AppConfiguration.swift
index 6255648f..423cb202 100644
--- a/Buzzd/Utils/AppConfiguration.swift
+++ b/Buzzd/Utils/AppConfiguration.swift
@@ -137,6 +137,13 @@ struct AppConfiguration {
             return 15
         }
     }
+
+    /// Optional: when set, the app will route Places "nearby" requests to this backend
+    /// Cloud Function endpoint instead of Google directly. Example:
+    /// https://us-central1-<project>.cloudfunctions.net/getNearby
+    var placesBackendURL: String {
+        ((Bundle.main.object(forInfoDictionaryKey: "PLACES_BACKEND_URL") as? String) ?? "").trimmingCharacters(in: .whitespacesAndNewlines)
+    }
     
     var maxRetryAttempts: Int {
         3
diff --git a/Buzzd/Utils/BrandColors.swift b/Buzzd/Utils/BrandColors.swift
index b54f3557..506a48d8 100644
--- a/Buzzd/Utils/BrandColors.swift
+++ b/Buzzd/Utils/BrandColors.swift
@@ -1,19 +1,26 @@
 import SwiftUI
 
+// Centralized brand palette for the Buzzd neon redesign.
 enum BrandColors {
-    // Primary accent (from asset to be consistent across devices)
+    // Primary accent (kept for compatibility with existing .tint calls)
     static var purple: Color { Color("AccentPurple") }
 
-    // App background ‚Äî deep, consistent dark purple gradient (sRGB)
-    static var bgTop: Color { Color(red: 12/255, green: 0/255, blue: 20/255) }
-    static var bgBottom: Color { Color(red: 32/255, green: 0/255, blue: 55/255) }
+    // App background ‚Äî now pure black per redesign brief
+    // Keep type LinearGradient to avoid call-site breakage.
     static var appBackground: LinearGradient {
-        LinearGradient(colors: [bgTop, bgBottom], startPoint: .top, endPoint: .bottom)
+        LinearGradient(colors: [.black, .black], startPoint: .top, endPoint: .bottom)
     }
 
-    static var gradient: LinearGradient {
-        LinearGradient(colors: [purple, purple.opacity(0.7)], startPoint: .leading, endPoint: .trailing)
+    // Buzzd neon gradient (approx from logo: magenta -> violet)
+    // These stops are tuned for a crisp, high-contrast glow.
+    static var neonPink: Color { Color(red: 1.00, green: 0.36, blue: 0.95) }   // ~#FF5AF2
+    static var neonViolet: Color { Color(red: 0.49, green: 0.25, blue: 1.00) } // ~#7D40FF
+    static var neonGradient: LinearGradient {
+        LinearGradient(colors: [neonPink, neonViolet], startPoint: .leading, endPoint: .trailing)
     }
+
+    // Soft purple glow used instead of harsh drop shadows
+    static var glow: Color { neonViolet.opacity(0.45) }
 }
 
 extension Color {
diff --git a/Buzzd/Utils/ImageCache.swift b/Buzzd/Utils/ImageCache.swift
index d7a5df21..cc202d62 100644
--- a/Buzzd/Utils/ImageCache.swift
+++ b/Buzzd/Utils/ImageCache.swift
@@ -1,6 +1,7 @@
 import UIKit
 import SwiftUI
 import CryptoKit
+import FirebaseAppCheck
 
 // MARK: - Shared in-process memory cache (synchronous peek for UI)
 
@@ -32,9 +33,18 @@ public final actor ImageCache {
         memoryCache.totalCostLimit = 50 * 1024 * 1024 // 50 MB
 
         let config = URLSessionConfiguration.default
-        config.timeoutIntervalForRequest = 10
-        config.timeoutIntervalForResource = 30
+        // Photos can be slow on mobile networks; be a bit more patient
+        config.timeoutIntervalForRequest = 25
+        config.timeoutIntervalForResource = 60
         config.requestCachePolicy = .useProtocolCachePolicy // safer than .returnCacheDataElseLoad for photos
+        // Keep concurrency modest to avoid timeouts and radio contention
+        config.httpMaximumConnectionsPerHost = 4
+        config.waitsForConnectivity = false
+        if #available(iOS 13.0, *) {
+            config.allowsConstrainedNetworkAccess = true
+            config.allowsExpensiveNetworkAccess = true
+        }
+        config.urlCache = URLCache.shared
         session = URLSession(configuration: config)
     }
 
@@ -63,19 +73,27 @@ public final actor ImageCache {
                 return img
             }
 
-            // Network
-            do {
-                let (data, response) = try await self.session.data(from: url)
-                guard let http = response as? HTTPURLResponse, http.statusCode == 200,
-                      let img = UIImage(data: data) else {
+            // Network with a simple retry for transient failures
+            let transientCodes: Set<URLError.Code> = [.timedOut, .networkConnectionLost, .cannotFindHost, .cannotConnectToHost]
+            for attempt in 0..<2 {
+                do {
+                    let (data, response) = try await self.fetch(url: url)
+                    guard let http = response as? HTTPURLResponse, http.statusCode == 200,
+                          let img = UIImage(data: data) else {
+                        return nil
+                    }
+                    await self.setMemory(img, forKey: key, cost: data.count)
+                    await self.diskCache.store(data, for: url)
+                    return img
+                } catch {
+                    if let err = error as? URLError, transientCodes.contains(err.code), attempt == 0 {
+                        try? await Task.sleep(nanoseconds: 350_000_000)
+                        continue
+                    }
                     return nil
                 }
-                await self.setMemory(img, forKey: key, cost: data.count)
-                await self.diskCache.store(data, for: url)
-                return img
-            } catch {
-                return nil
             }
+            return nil
         }
 
         activeDownloads[url] = task
@@ -87,7 +105,7 @@ public final actor ImageCache {
     public func prefetch(_ urls: [URL]) {
         Task {
             await withTaskGroup(of: Void.self) { group in
-                for url in urls.prefix(10) {
+                for url in urls.prefix(6) {
                     group.addTask { [weak self] in
                         _ = await self?.image(for: url)
                     }
@@ -108,6 +126,24 @@ public final actor ImageCache {
         // Runs on the actor; NSCache is thread-safe, but we still centralize here.
         memoryCache.setObject(image, forKey: key, cost: cost)
     }
+
+    // Use App Check header when requesting Firebase-hosted endpoints (e.g., Cloud Functions)
+    private func fetch(url: URL) async throws -> (Data, URLResponse) {
+        let host = url.host ?? ""
+        let isFunctions = host.contains("cloudfunctions.net") || host.contains("run.app")
+        guard isFunctions else {
+            return try await session.data(from: url)
+        }
+        // Build a request with App Check header if possible
+        var req = URLRequest(url: url)
+        // Copy standard method/headers
+        req.httpMethod = "GET"
+        // Obtain App Check token (best-effort)
+        if let token = try? await AppCheck.appCheck().token(forcingRefresh: false).token, !token.isEmpty {
+            req.setValue(token, forHTTPHeaderField: "X-Firebase-AppCheck")
+        }
+        return try await session.data(for: req)
+    }
 }
 
 // MARK: - Disk Cache (actor)
diff --git a/Buzzd/Utils/LocationManager.swift b/Buzzd/Utils/LocationManager.swift
index de312656..4abcda28 100644
--- a/Buzzd/Utils/LocationManager.swift
+++ b/Buzzd/Utils/LocationManager.swift
@@ -19,6 +19,7 @@ import Combine
 
 class LocationManager: NSObject, ObservableObject {
     private let locationManager = CLLocationManager()
+    private let appleGeocoder = CLGeocoder()
 
     @Published var location: CLLocation?
     @Published var currentCity: String = "Loading..."
@@ -69,13 +70,11 @@ class LocationManager: NSObject, ObservableObject {
             print("‚è≥ Geocoding already in progress, skipping duplicate request")
             return
         }
-        // Use Google Geocoding API directly
+        // Prefer Google Geocoding API; fall back to Apple if unavailable or failing
         let apiKey = AppConfiguration.shared.googlePlacesAPIKey
         guard !apiKey.isEmpty else {
-            print("‚ö†Ô∏è No Google API key available")
-            DispatchQueue.main.async {
-                self.currentCity = "Location Found"
-            }
+            print("‚ö†Ô∏è No Google API key available ‚Äî falling back to Apple CLGeocoder")
+            reverseGeocodeWithApple(location: location)
             return
         }
 
@@ -99,14 +98,14 @@ class LocationManager: NSObject, ObservableObject {
                 self.geocodingInProgress = false
 
                 if let error = error {
-                    print("‚ö†Ô∏è Google geocoding error: \(error.localizedDescription)")
-                    self.currentCity = "Location Found"
+                    print("‚ö†Ô∏è Google geocoding error: \(error.localizedDescription); falling back to Apple CLGeocoder")
+                    self.reverseGeocodeWithApple(location: location)
                     return
                 }
 
                 guard let data = data else {
-                    print("‚ö†Ô∏è No data from Google geocoding")
-                    self.currentCity = "Location Found"
+                    print("‚ö†Ô∏è No data from Google geocoding; falling back to Apple CLGeocoder")
+                    self.reverseGeocodeWithApple(location: location)
                     return
                 }
 
@@ -137,17 +136,43 @@ class LocationManager: NSObject, ObservableObject {
                             self.currentCity = city
                             print("‚úÖ Google geocoding success: \(self.currentCity)")
                         } else {
-                            self.currentCity = "Location Found"
-                            print("‚ö†Ô∏è Could not extract city/state from Google response")
+                            print("‚ö†Ô∏è Could not extract city/state from Google response; falling back to Apple CLGeocoder")
+                            self.reverseGeocodeWithApple(location: location)
                         }
                     }
                 } catch {
-                    print("‚ö†Ô∏è Failed to parse Google geocoding response: \(error)")
-                    self.currentCity = "Location Found"
+                    print("‚ö†Ô∏è Failed to parse Google geocoding response: \(error); falling back to Apple CLGeocoder")
+                    self.reverseGeocodeWithApple(location: location)
                 }
             }
         }.resume()
     }
+
+    private func reverseGeocodeWithApple(location: CLLocation) {
+        appleGeocoder.reverseGeocodeLocation(location) { [weak self] placemarks, error in
+            DispatchQueue.main.async {
+                guard let self = self else { return }
+                if let error = error {
+                    print("‚ö†Ô∏è Apple reverse geocode error: \(error.localizedDescription)")
+                    self.currentCity = "Location Found"
+                    return
+                }
+                if let pm = placemarks?.first {
+                    let city = pm.locality ?? pm.subLocality
+                    let state = pm.administrativeArea
+                    if let city = city, let state = state {
+                        self.currentCity = "\(city), \(state)"
+                    } else if let city = city {
+                        self.currentCity = city
+                    } else {
+                        self.currentCity = "Location Found"
+                    }
+                } else {
+                    self.currentCity = "Location Found"
+                }
+            }
+        }
+    }
 }
 
 // MARK: - CLLocationManagerDelegate
diff --git a/Buzzd/ViewModels/PlacesViewModel.swift b/Buzzd/ViewModels/PlacesViewModel.swift
index b768a516..3b9a5369 100644
--- a/Buzzd/ViewModels/PlacesViewModel.swift
+++ b/Buzzd/ViewModels/PlacesViewModel.swift
@@ -17,11 +17,14 @@ final class PlacesViewModel: ObservableObject {
     @Published var isLoading = false
     @Published var errorMessage: String?
     @Published var query: String = ""
+    @Published var hasMoreVenues = false
+    @Published var isLoadingMore = false
 
     private let placesService = GooglePlacesService()
     private let venueDataService = VenueDataService.shared
     private var cancellables = Set<AnyCancellable>()
     private var searchCancellable: AnyCancellable?
+    private var loadMoreCancellable: AnyCancellable?
     private var allVenues: [NightlifeVenue] = []
     var hiddenVenueIds: Set<String> = []
     private var lastLocation: CLLocation?
@@ -29,11 +32,14 @@ final class PlacesViewModel: ObservableObject {
     private var lastSearchAt: Date?
     private let minRefetchDistanceMeters: CLLocationDistance = 200 // ~0.12 miles
     private let minRefetchInterval: TimeInterval = 6 // seconds
+    private var totalAvailableVenues = 0
     private var enhancementTask: Task<Void, Never>?
     private var enhancementGeneration = UUID()
     private var lastDisplayModeIsPlan = VenueDisplayHelper.currentDisplayInfo.isPlanMode
     private var statsListeners: [String: ListenerRegistration] = [:]
     private var venueDocListeners: [String: ListenerRegistration] = [:]
+    private var openStatusTimer: AnyCancellable?
+    private var hydratingPhotos: Set<String> = []
 
     // Store reference to session for admin filtering
     weak var userSession: UserSession?
@@ -41,6 +47,7 @@ final class PlacesViewModel: ObservableObject {
     private init() {
         setupQueryDebounce()
         setupDisplayModeObserver()
+        setupOpenStatusTimer()
     }
 
     deinit {
@@ -71,6 +78,15 @@ final class PlacesViewModel: ObservableObject {
             }
             .store(in: &cancellables)
     }
+
+    private func setupOpenStatusTimer() {
+        openStatusTimer = Timer.publish(every: 60, on: .main, in: .common)
+            .autoconnect()
+            .sink { [weak self] _ in
+                guard let self = self else { return }
+                Task { await self.refreshLiveOpenStatus() }
+            }
+    }
     
     func searchNearbyVenues(location: CLLocation, radiusMiles: Double = 10, replace: Bool = false) {
         // Gate refetches: skip if user hasn't moved enough, radius hasn't expanded,
@@ -116,6 +132,51 @@ final class PlacesViewModel: ObservableObject {
         guard let location = lastLocation, newMiles > loadedRadiusMiles else { return }
         searchNearbyVenues(location: location, radiusMiles: newMiles, replace: false)
     }
+
+    // MARK: - Load More Venues
+    func loadMoreVenues() {
+        guard let location = lastLocation, !isLoadingMore, hasMoreVenues else { return }
+
+        isLoadingMore = true
+
+        loadMoreCancellable?.cancel()
+        loadMoreCancellable = placesService
+            .loadMoreVenues(location: location, currentCount: allVenues.count, batchSize: 20)
+            .receive(on: DispatchQueue.main)
+            .sink(
+                receiveCompletion: { [weak self] completion in
+                    self?.isLoadingMore = false
+                    if case .failure(let error) = completion {
+                        print("Error loading more venues: \(error)")
+                    }
+                },
+                receiveValue: { [weak self] newVenues in
+                    guard let strongSelf = self else { return }
+                    Task {
+                        await strongSelf.handleLoadMoreResults(newVenues)
+                    }
+                }
+            )
+    }
+
+    private func handleLoadMoreResults(_ newVenues: [NightlifeVenue]) async {
+        let filteredVenues = NightlifeFilter.apply(newVenues)
+
+        if filteredVenues.isEmpty {
+            hasMoreVenues = false
+        } else {
+            mergeVenues(with: filteredVenues)
+            totalAvailableVenues = allVenues.count
+
+            // Continue enhancement
+            let enhancedVenues = await enhanceVenuesWithDatabaseInfo(filteredVenues)
+            mergeVenues(with: enhancedVenues)
+        }
+
+        applyFilter(query: query)
+        prefetchImages()
+        await attachStatsListenersIfNeeded()
+    }
     
     // MARK: - Private Methods
     
@@ -135,6 +196,10 @@ final class PlacesViewModel: ObservableObject {
             mergeVenues(with: filteredVenues)
         }
 
+        // Check if there are more venues available
+        totalAvailableVenues = allVenues.count
+        hasMoreVenues = allVenues.count >= 40 // If we got 40, there might be more
+
         applyFilter(query: query)
         prefetchImages()
 
@@ -234,6 +299,14 @@ final class PlacesViewModel: ObservableObject {
             let rating = venueData?.averageRating ?? (venue.rating == 0 ? 2.5 : venue.rating)
             let coverCharge = venueData?.coverCharge ?? venue.coverCharge
             let resolvedType = venueData?.venueType ?? venue.type
+            
+            // Prefer DB-hosted photo, but gracefully fall back to the
+            // already-computed venue.photoURL (built from photo_reference)
+            // so images don't disappear during enhancement.
+            let dbPhoto = venueData?.photoURL?.trimmingCharacters(in: .whitespacesAndNewlines)
+            let candidatePhoto = (dbPhoto?.isEmpty == false) ? dbPhoto : venue.photoURL
+            let resolvedPhoto = normalizePhotoURL(candidatePhoto)
+
             let latitude = venue.latitude ?? venueData?.latitude
             let longitude = venue.longitude ?? venueData?.longitude
 
@@ -243,7 +316,7 @@ final class PlacesViewModel: ObservableObject {
                 address: venue.address,
                 type: resolvedType,
                 rating: rating,
-                photoURL: venue.photoURL,
+                photoURL: resolvedPhoto,
                 distance: venue.distance,
                 currentCapacity: displayCount,
                 coverCharge: coverCharge,
@@ -258,6 +331,21 @@ final class PlacesViewModel: ObservableObject {
         }
     }
 
+    private func normalizePhotoURL(_ s: String?) -> String? {
+        guard var raw = s?.trimmingCharacters(in: .whitespacesAndNewlines), !raw.isEmpty else { return nil }
+        raw = raw.replacingOccurrences(of: " ", with: "%20")
+        if !raw.contains("://") { raw = "https://" + raw }
+        if raw.hasPrefix("gs://") {
+            let without = String(raw.dropFirst("gs://".count))
+            if let slash = without.firstIndex(of: "/") {
+                let bucket = String(without[..<slash])
+                let path = String(without[slash...]).addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? String(without[slash...])
+                raw = "https://storage.googleapis.com/\(bucket)\(path)"
+            }
+        }
+        return raw
+    }
+
     private func defaultEnhancedVenue(from venue: NightlifeVenue) -> NightlifeVenue {
         NightlifeVenue(
             placeId: venue.placeId,
@@ -276,6 +364,46 @@ final class PlacesViewModel: ObservableObject {
         )
     }
     
+    /// Recompute live open/closed for visible venues from cached hours (no network),
+    /// then re-apply filters so "Open now" lists update in place.
+    private func refreshLiveOpenStatus() async {
+        guard !allVenues.isEmpty else { return }
+        let cache = PlacesCache.shared
+
+        var changed = false
+        // Limit to top 60 venues to bound work
+        for i in allVenues.indices.prefix(60) {
+            guard let pid = allVenues[i].placeId,
+                  let details = cache.loadDetails(placeId: pid) else { continue }
+            let hours = details.currentOpeningHours ?? details.openingHours
+            let computed = GooglePlacesService.computeIsOpenNow(hours)
+            if allVenues[i].isOpen != computed {
+                var v = allVenues[i]
+                v = NightlifeVenue(
+                    placeId: v.placeId,
+                    name: v.name,
+                    address: v.address,
+                    type: v.type,
+                    rating: v.rating,
+                    photoURL: v.photoURL,
+                    distance: v.distance,
+                    currentCapacity: v.currentCapacity,
+                    coverCharge: v.coverCharge,
+                    isOpen: computed,
+                    priceLevel: v.priceLevel,
+                    latitude: v.latitude,
+                    longitude: v.longitude
+                )
+                allVenues[i] = v
+                changed = true
+            }
+        }
+
+        if changed {
+            applyFilter(query: query)
+        }
+    }
+    
     private func mergeVenues(with newVenues: [NightlifeVenue]) {
         var venueDict = Dictionary(uniqueKeysWithValues: allVenues.map { ($0.id, $0) })
         newVenues.forEach { venueDict[$0.id] = $0 }
@@ -295,17 +423,24 @@ final class PlacesViewModel: ObservableObject {
         // Filter out hidden venues for non-admin users ONLY
         let isAdmin = userSession?.adminMode ?? false
         if !isAdmin {
-            let beforeCount = filtered.count
-            filtered = filtered.filter { venue in
+            let before = filtered
+            let filteredHidden = filtered.filter { venue in
                 guard let placeId = venue.placeId else { return true }
                 return !hiddenVenueIds.contains(placeId)
             }
-            #if DEBUG
-            let hiddenCount = beforeCount - filtered.count
-            if hiddenCount > 0 {
-                print("üîí Filtered out \(hiddenCount) hidden venues (admin mode: \(isAdmin))")
+            // If filtering hidden leaves us with a nearly empty list, ignore hidden for now.
+            if filteredHidden.count >= 6 || hiddenVenueIds.isEmpty {
+                #if DEBUG
+                let hiddenCount = before.count - filteredHidden.count
+                if hiddenCount > 0 { print("üîí Filtered out \(hiddenCount) hidden venues (admin mode: false)") }
+                #endif
+                filtered = filteredHidden
+            } else {
+                #if DEBUG
+                print("‚ö†Ô∏è Ignoring hidden filter due to scarcity (kept \(before.count) vs \(filteredHidden.count) after hide)")
+                #endif
+                filtered = before
             }
-            #endif
         } else {
             #if DEBUG
             print("üëë Admin mode: Showing all venues including \(hiddenVenueIds.count) hidden")
@@ -325,6 +460,86 @@ final class PlacesViewModel: ObservableObject {
     private func prefetchImages() {
         let imageURLs = allVenues.compactMap { URL(string: $0.photoURL ?? "") }
         Task { await ImageCache.shared.prefetch(imageURLs) }
+
+        // Opportunistically hydrate missing photos for the first page of venues.
+        // This covers cases where Nearby didn't include photos and the backend
+        // hasn't mirrored a hosted photo_url yet.
+        hydrateMissingPhotosForVisibleVenues(limit: 16)
+    }
+
+    private func hydrateMissingPhotosForVisibleVenues(limit: Int) {
+        // Pick the first N venues lacking a photoURL
+        let candidates = allVenues.prefix(max(0, limit)).filter { ($0.photoURL ?? "").trimmingCharacters(in: .whitespacesAndNewlines).isEmpty }
+        guard !candidates.isEmpty else { return }
+
+        for v in candidates {
+            guard let pid = v.placeId, !hydratingPhotos.contains(pid) else { continue }
+            hydratingPhotos.insert(pid)
+
+            Task.detached { [weak self] in
+                guard let self else { return }
+                do {
+                    let details = try await self.placesService.fetchDetailsCachedAsync(placeId: pid)
+                    guard let ref = details.photos?.first?.photoReference else { return }
+                    // Build the most appropriate photo URL
+                    let url: String = {
+                        // Prefer direct Google photo when key is available; fallback to backend proxy.
+                        let key = AppConfiguration.shared.googlePlacesAPIKey
+                        if !key.isEmpty {
+                            var c = URLComponents(string: "https://maps.googleapis.com/maps/api/place/photo")!
+                            c.queryItems = [
+                                URLQueryItem(name: "maxwidth", value: "800"),
+                                URLQueryItem(name: "photoreference", value: ref),
+                                URLQueryItem(name: "key", value: key)
+                            ]
+                            return c.url?.absoluteString ?? ""
+                        }
+                        let base = AppConfiguration.shared.placesBackendURL
+                        if !base.isEmpty, var comps = URLComponents(string: base) {
+                            if comps.path.isEmpty || comps.path == "/" { comps.path = "/getPlacePhoto" }
+                            else if !comps.path.contains("/getPlacePhoto") {
+                                comps.path = comps.path.replacingOccurrences(of: "/getNearby", with: "/getPlacePhoto")
+                            }
+                            comps.queryItems = [
+                                URLQueryItem(name: "ref", value: ref),
+                                URLQueryItem(name: "maxwidth", value: "600")
+                            ]
+                            if let u = comps.url?.absoluteString { return u }
+                        }
+                        return ""
+                    }()
+
+                    await MainActor.run {
+                        if let idx = self.allVenues.firstIndex(where: { $0.placeId == pid }) {
+                            var cur = self.allVenues[idx]
+                            if (cur.photoURL ?? "").isEmpty {
+                                cur = NightlifeVenue(
+                                    placeId: cur.placeId,
+                                    name: cur.name,
+                                    address: cur.address,
+                                    type: cur.type,
+                                    rating: cur.rating,
+                                    photoURL: url,
+                                    distance: cur.distance,
+                                    currentCapacity: cur.currentCapacity,
+                                    coverCharge: cur.coverCharge,
+                                    isOpen: cur.isOpen,
+                                    priceLevel: cur.priceLevel,
+                                    latitude: cur.latitude,
+                                    longitude: cur.longitude
+                                )
+                                self.allVenues[idx] = cur
+                                self.applyFilter(query: self.query)
+                                Task { await ImageCache.shared.prefetch([URL(string: url)!]) }
+                            }
+                        }
+                    }
+                } catch {
+                    // Silent: not all venues have photos
+                }
+                await MainActor.run { self.hydratingPhotos.remove(pid) }
+            }
+        }
     }
     
     // MARK: - Real-time Updates
@@ -512,6 +727,7 @@ final class PlacesViewModel: ObservableObject {
                 guard let self else { return }
                 guard let data = snap?.data() else { return }
                 let newCover = (data["coverCharge"] as? Int) ?? 0
+                let newPhoto = data["photoURL"] as? String
                 let isHidden = (data["isHidden"] as? Bool) ?? false
 
                 // Update hidden set
@@ -529,6 +745,7 @@ final class PlacesViewModel: ObservableObject {
 
                 if let idx = self.allVenues.firstIndex(where: { $0.placeId == vid }) {
                     var v = self.allVenues[idx]
+                    var changed = false
                     if v.coverCharge != newCover {
                         v = NightlifeVenue(
                             placeId: v.placeId,
@@ -546,6 +763,26 @@ final class PlacesViewModel: ObservableObject {
                             longitude: v.longitude
                         )
                         self.allVenues[idx] = v
+                        changed = true
+                    }
+                    if let np = newPhoto, !np.isEmpty, v.photoURL != np {
+                        v = NightlifeVenue(
+                            placeId: v.placeId,
+                            name: v.name,
+                            address: v.address,
+                            type: v.type,
+                            rating: v.rating,
+                            photoURL: np,
+                            distance: v.distance,
+                            currentCapacity: v.currentCapacity,
+                            coverCharge: v.coverCharge,
+                            isOpen: v.isOpen,
+                            priceLevel: v.priceLevel,
+                            latitude: v.latitude,
+                            longitude: v.longitude
+                        )
+                        self.allVenues[idx] = v
+                        changed = true
                     }
                 }
 
diff --git a/firebase.json b/firebase.json
index 0cd018f4..a10c2168 100644
--- a/firebase.json
+++ b/firebase.json
@@ -23,5 +23,19 @@
   },
   "storage": {
     "rules": "storage.rules"
+  },
+  "hosting": {
+    "public": "public",
+    "ignore": [
+      "firebase.json",
+      "**/.*",
+      "**/node_modules/**"
+    ],
+    "rewrites": [
+      {
+        "source": "/event/**",
+        "function": "renderEventPage"
+      }
+    ]
   }
 }
diff --git a/firestore.rules b/firestore.rules
index 1a16bbd3..d5e87453 100644
--- a/firestore.rules
+++ b/firestore.rules
@@ -8,15 +8,17 @@ service cloud.firestore {
       allow write: if false;
     }
 
+    // Leaderboards removed
+
     // ===== CHATS =====
     match /chats/{chatId} {
-      // Per-doc read: only participants
-      allow get: if isAuthenticated() && request.auth.uid in resource.data.participants;
+      // Per-doc read: only participants, and only verified users
+      allow get: if hasValidEmail() && request.auth.uid in resource.data.participants;
       // Query/list allowed; per-doc get above filters results
-      allow list: if isAuthenticated();
+      allow list: if hasValidEmail();
 
-      // Create
-      allow create: if isAuthenticated()
+      // Create (only approved users)
+      allow create: if isApprovedUser()
         && request.resource.data.type in ['direct','group']
         && request.resource.data.participants is list
         && request.resource.data.participants.size() >= 2
@@ -43,8 +45,8 @@ service cloud.firestore {
         && (!('lastMessageSenderId' in request.resource.data) || request.resource.data.lastMessageSenderId is string || request.resource.data.lastMessageSenderId == null)
         && request.resource.data.participantNames is map;
 
-      // Update (immutable + safe fields)
-      allow update: if isAuthenticated()
+      // Update (immutable + safe fields) ‚Äî approved users only
+      allow update: if isApprovedUser()
         && request.auth.uid in resource.data.participants
         && request.resource.data.participants == resource.data.participants
         && request.resource.data.createdBy == resource.data.createdBy
@@ -74,18 +76,20 @@ service cloud.firestore {
         && request.resource.data.participantNames is map;
 
       match /messages/{msgId} {
-        allow get, list: if isAuthenticated()
+        // Only verified participants may read messages
+        allow get, list: if hasValidEmail()
           && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
 
-        allow create: if isAuthenticated()
+        // Only approved participants may create messages
+        allow create: if isApprovedUser()
           && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants
           && request.resource.data.keys().hasOnly(['senderId','senderName','text','type','createdAt','venueSnapshot'])
           && request.resource.data.senderId == request.auth.uid
           && request.resource.data.createdAt is timestamp
           && (!('venueSnapshot' in request.resource.data) || isValidVenueSnapshot(request.resource.data.venueSnapshot));
 
-        // Allow participants to mark messages as read. Only 'readBy' may change.
-        allow update: if isAuthenticated()
+        // Allow approved participants to mark messages as read. Only 'readBy' may change.
+        allow update: if isApprovedUser()
           && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants
           && request.resource.data.keys().hasOnly(['senderId','senderName','text','type','createdAt','readBy','venueSnapshot'])
           && request.resource.data.senderId == resource.data.senderId
@@ -101,15 +105,17 @@ service cloud.firestore {
         allow delete: if false;
       }
 
-      // Allow a participant to delete the chat (leave).
-      allow delete: if isAuthenticated() && request.auth.uid in resource.data.participants;
+      // Allow a participant to delete the chat (leave) ‚Äî approved only.
+      allow delete: if isApprovedUser() && request.auth.uid in resource.data.participants;
 
       // Typing indicators (ephemeral, per-user docs)
       match /typing/{uid} {
-        allow get, list: if isAuthenticated()
+        // Verified participants may read typing indicators
+        allow get, list: if hasValidEmail()
           && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
 
-        allow create, update: if isAuthenticated()
+        // Approved participants may write typing indicators
+        allow create, update: if isApprovedUser()
           && request.auth.uid == uid
           && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants
           && request.resource.data.keys().hasOnly(['uid','isTyping','updatedAt'])
@@ -117,15 +123,15 @@ service cloud.firestore {
           && request.resource.data.isTyping is bool
           && request.resource.data.updatedAt is timestamp;
 
-        allow delete: if isAuthenticated() && request.auth.uid == uid;
+        allow delete: if isApprovedUser() && request.auth.uid == uid;
       }
     }
 
     // === Hosts: Subscriptions ===
     match /hostSubscriptions/{subId} {
-      allow get: if isAuthenticated() && resource.data.subscriberId == request.auth.uid;
-      allow list: if isAuthenticated();
-      allow create: if isAuthenticated()
+      allow get: if hasValidEmail() && resource.data.subscriberId == request.auth.uid;
+      allow list: if hasValidEmail();
+      allow create: if isApprovedUser()
         && request.resource.data.keys().hasOnly(['subscriberId','hostId','hostName','hostAvatarURL','subscribedAt'])
         && request.resource.data.subscriberId == request.auth.uid
         && request.resource.data.hostId is string
@@ -133,7 +139,7 @@ service cloud.firestore {
         && (!('hostName' in request.resource.data) || request.resource.data.hostName is string)
         && (!('hostAvatarURL' in request.resource.data) || request.resource.data.hostAvatarURL is string);
       allow update: if false;
-      allow delete: if isAuthenticated() && resource.data.subscriberId == request.auth.uid;
+      allow delete: if isApprovedUser() && resource.data.subscriberId == request.auth.uid;
     }
     // ===== Helper functions (unchanged) =====
     function isValidDukesEmail(email) {
@@ -269,8 +275,8 @@ service cloud.firestore {
 
     // ===== USERS =====
     match /users/{uid} {
-      // Users can always read their own profile (even before verification)
-      // Others can read profiles only if they have verified email
+      // Allow the signed-in owner to read their own profile even before verification
+      // so the app can show the verification screen; everyone else requires verified email.
       allow read: if isOwner(uid) || hasValidEmail();
       // Allow collection queries for equality searches (rules still enforce per-doc read above).
       allow list: if hasValidEmail();
@@ -312,11 +318,11 @@ service cloud.firestore {
         (
           hasValidEmail()
           && (!('email' in resource.data) || request.resource.data.email == resource.data.email)
-          // Permit flipping approved from false -> true after verification
+          // Permit flipping approved from false -> true ONLY after email verification
           && (
             (!('approved' in resource.data)) ||
             (request.resource.data.approved == resource.data.approved) ||
-            (resource.data.approved == false && request.resource.data.approved == true)
+            (resource.data.approved == false && request.resource.data.approved == true && request.auth.token.email_verified == true)
           )
           && (!('createdAt' in resource.data) || request.resource.data.createdAt == resource.data.createdAt)
           && (!('username' in request.resource.data) || (
@@ -374,8 +380,9 @@ service cloud.firestore {
 
       // --- User-scoped FCM token subcollection: users/{uid}/fcmTokens/{tokenId}
       match /fcmTokens/{tokenId} {
-        // Simplified rule per request: owner may read/write their own token docs
-        allow read, write: if request.auth != null && request.auth.uid == uid;
+        // Relaxed: allow the authenticated owner to read/write regardless of email verification
+        // Rationale: devices must register tokens before verification/approval to receive push for flows like friend requests.
+        allow read, write: if isAuthenticated() && request.auth.uid == uid;
       }
 
       // --- User-scoped tickets (owner read-only)
@@ -387,16 +394,16 @@ service cloud.firestore {
 
       // --- Friend links (symmetric markers used by rules)
       match /friends/{friendId} {
-        // Owner can see their own friend links
-        allow get, list: if isOwner(uid);
-        // Either participant may create the link (client-side on accept)
-        allow create: if isAuthenticated()
+        // Owner can see their own friend links (only when verified)
+        allow get, list: if hasValidEmail() && isOwner(uid);
+        // Either participant may create the link (client-side on accept) ‚Äî approved only
+        allow create: if isApprovedUser()
           && (request.auth.uid == uid || request.auth.uid == friendId)
           && request.resource.data.keys().hasOnly(['uid','createdAt'])
           && request.resource.data.uid == friendId
           && request.resource.data.createdAt is timestamp;
-        // Only allow delete by owner (or friend to remove themselves)
-        allow delete: if isAuthenticated() && (request.auth.uid == uid || request.auth.uid == friendId);
+        // Only allow delete by owner (or friend to remove themselves) ‚Äî approved only
+        allow delete: if isApprovedUser() && (request.auth.uid == uid || request.auth.uid == friendId);
         allow update: if false;
       }
     }
@@ -406,7 +413,7 @@ service cloud.firestore {
       allow get: if true;
       allow list: if false;
 
-      allow create: if isAuthenticated()
+      allow create: if isApprovedUser()
         && !exists(/databases/$(database)/documents/usernames/$(usernameId))
         && request.resource.data.keys().hasOnly(['username','ownerId','email','createdAt'])
         && request.resource.data.username == usernameId
@@ -414,7 +421,7 @@ service cloud.firestore {
         && request.resource.data.email is string
         && request.resource.data.createdAt is timestamp;
 
-      allow update: if isAuthenticated()
+      allow update: if isApprovedUser()
         && request.resource.data.keys().hasOnly(['username','ownerId','email','createdAt'])
         && resource.data.ownerId == request.auth.uid
         && request.resource.data.username == resource.data.username
@@ -422,15 +429,15 @@ service cloud.firestore {
         && request.resource.data.email is string
         && request.resource.data.createdAt == resource.data.createdAt;
 
-      allow delete: if isAuthenticated() && resource.data.ownerId == request.auth.uid;
+      allow delete: if isApprovedUser() && resource.data.ownerId == request.auth.uid;
     }
 
     // ===== FRIEND REQUESTS =====
     match /friendRequests/{requestId} {
-      allow get, list: if isAuthenticated()
+      allow get, list: if hasValidEmail()
         && (request.auth.uid == resource.data.senderId || request.auth.uid == resource.data.recipientId);
 
-      allow create: if isAuthenticated()
+      allow create: if isApprovedUser()
         && request.resource.data.keys().hasOnly([
           'senderId','recipientId','senderName','senderEmail','senderAvatarURL',
           'recipientName','recipientEmail','recipientAvatarURL','status','createdAt'
@@ -448,7 +455,7 @@ service cloud.firestore {
         && request.resource.data.senderId != request.resource.data.recipientId
         && request.resource.data.createdAt is timestamp;
 
-      allow update: if isAuthenticated()
+      allow update: if isApprovedUser()
         && resource.data.recipientId == request.auth.uid
         && request.resource.data.keys().hasOnly([
           'senderId','recipientId','senderName','senderEmail','senderAvatarURL',
@@ -466,15 +473,15 @@ service cloud.firestore {
         && request.resource.data.status in ['accepted','declined']
         && request.resource.data.updatedAt is timestamp;
 
-      allow delete: if isAuthenticated()
+      allow delete: if isApprovedUser()
         && (resource.data.senderId == request.auth.uid || resource.data.recipientId == request.auth.uid);
     }
 
     // ===== FRIENDSHIPS =====
     match /friendships/{friendshipId} {
-      allow get, list: if isAuthenticated() && request.auth.uid in resource.data.participants;
+      allow get, list: if hasValidEmail() && request.auth.uid in resource.data.participants;
 
-      allow create: if isAuthenticated()
+      allow create: if isApprovedUser()
         && request.resource.data.keys().hasOnly(['participants','status','createdAt','pairKey'])
         && request.resource.data.participants is list
         && request.resource.data.participants.size() == 2
@@ -486,7 +493,7 @@ service cloud.firestore {
         && request.resource.data.createdAt is timestamp
         && request.resource.data.pairKey is string;
 
-      allow update: if isAuthenticated()
+      allow update: if isApprovedUser()
         && request.auth.uid in resource.data.participants
         && request.resource.data.keys().hasOnly(['participants','status','createdAt','pairKey'])
         && request.resource.data.participants == resource.data.participants
@@ -494,7 +501,7 @@ service cloud.firestore {
         && request.resource.data.pairKey == resource.data.pairKey
         && request.resource.data.status in ['accepted','friends'];
 
-      allow delete: if isAuthenticated() && request.auth.uid in resource.data.participants;
+      allow delete: if isApprovedUser() && request.auth.uid in resource.data.participants;
     }
 
     // ===== VENUES =====
@@ -533,9 +540,9 @@ service cloud.firestore {
 
     // ===== CHECK-INS =====
     match /checkIns/{checkInId} {
-      // Only allow authenticated users to read check-ins
-      allow read: if isAuthenticated();
-      allow list: if isAuthenticated();
+      // Only allow verified users to read check-ins
+      allow read: if hasValidEmail();
+      allow list: if hasValidEmail();
       allow create: if isApprovedUser()
         && request.resource.data.keys().hasOnly([
           'userId', 'userName', 'venueId', 'venueName', 'checkedInAt',
@@ -565,9 +572,9 @@ service cloud.firestore {
 
     // ===== PLAN TO GO =====
     match /planToGo/{planId} {
-      // Only allow authenticated users to read plan to go
-      allow read: if isAuthenticated();
-      allow list: if isAuthenticated();
+      // Only allow verified users to read plan to go
+      allow read: if hasValidEmail();
+      allow list: if hasValidEmail();
       allow create: if isApprovedUser()
         && request.resource.data.keys().hasOnly([
           'userId', 'userName', 'venueId', 'venueName', 'plannedAt'
@@ -584,8 +591,8 @@ service cloud.firestore {
 
     // ===== VENUE RATINGS =====
     match /venueRatings/{ratingId} {
-      allow read: if isAuthenticated();
-      allow list: if isAuthenticated();
+      allow read: if hasValidEmail();
+      allow list: if hasValidEmail();
       // Create a rating for self; only allowed fields
       allow create: if isApprovedUser()
         && request.resource.data.keys().hasOnly(['userId','venueId','rating','ratedAt'])
@@ -606,13 +613,13 @@ service cloud.firestore {
 
     // ===== TICKETS (server-managed) =====
     match /tickets/{ticketId} {
-      // Per-doc read rules: purchaser or event host
+      // Per-doc read rules: purchaser or event host (auth required; no email verification needed)
       allow get: if isAuthenticated() && (
         resource.data.purchaserId == request.auth.uid ||
         (resource.data.eventId is string &&
           get(/databases/$(database)/documents/events/$(resource.data.eventId)).data.hostUserId == request.auth.uid)
       );
-      // Allow list; per-doc get above filters results
+      // Allow queries for authenticated users; per-doc get above filters results
       allow list: if isAuthenticated();
       // Only server creates/updates/deletes
       allow create, update, delete: if false;
@@ -659,8 +666,8 @@ service cloud.firestore {
 
     // ===== ORG VERIFICATIONS =====
     match /org_verifications/{verificationId} {
-      // Owner can read their own doc; admins can read/list all
-      allow get: if isAdmin() || (isAuthenticated() && resource.data.user_id == request.auth.uid);
+      // Owner can read their own doc (verified); admins can read/list all
+      allow get: if isAdmin() || (hasValidEmail() && resource.data.user_id == request.auth.uid);
       allow list: if isAdmin();
 
       // Create by approved user for themselves; status must be 'pending'
diff --git a/functions/package-lock.json b/functions/package-lock.json
index df06ba8b..aecfb8cb 100644
--- a/functions/package-lock.json
+++ b/functions/package-lock.json
@@ -6,11 +6,11 @@
     "": {
       "name": "functions",
       "dependencies": {
-        "@sendgrid/mail": "^8.1.5",
+        "@sendgrid/mail": "^8.1.6",
         "@types/cors": "^2.8.19",
         "cors": "^2.8.5",
-        "firebase-admin": "^12.6.0",
-        "firebase-functions": "^6.0.1",
+        "firebase-admin": "^13.5.0",
+        "firebase-functions": "^6.6.0",
         "node-forge": "^1.3.1",
         "passkit-generator": "^3.3.2",
         "qrcode": "^1.5.3",
@@ -680,88 +680,104 @@
       "license": "MIT"
     },
     "node_modules/@firebase/app-check-interop-types": {
-      "version": "0.3.2",
-      "resolved": "https://registry.npmjs.org/@firebase/app-check-interop-types/-/app-check-interop-types-0.3.2.tgz",
-      "integrity": "sha512-LMs47Vinv2HBMZi49C09dJxp0QT5LwDzFaVGf/+ITHe3BlIhUiLNttkATSXplc89A2lAaeTqjgqVkiRfUGyQiQ==",
+      "version": "0.3.3",
+      "resolved": "https://registry.npmjs.org/@firebase/app-check-interop-types/-/app-check-interop-types-0.3.3.tgz",
+      "integrity": "sha512-gAlxfPLT2j8bTI/qfe3ahl2I2YcBQ8cFIBdhAQA4I2f3TndcO+22YizyGYuttLHPQEpWkhmpFW60VCFEPg4g5A==",
       "license": "Apache-2.0"
     },
     "node_modules/@firebase/app-types": {
-      "version": "0.9.2",
-      "resolved": "https://registry.npmjs.org/@firebase/app-types/-/app-types-0.9.2.tgz",
-      "integrity": "sha512-oMEZ1TDlBz479lmABwWsWjzHwheQKiAgnuKxE0pz0IXCVx7/rtlkx1fQ6GfgK24WCrxDKMplZrT50Kh04iMbXQ==",
+      "version": "0.9.3",
+      "resolved": "https://registry.npmjs.org/@firebase/app-types/-/app-types-0.9.3.tgz",
+      "integrity": "sha512-kRVpIl4vVGJ4baogMDINbyrIOtOxqhkZQg4jTq3l8Lw6WSk0xfpEYzezFu+Kl4ve4fbPl79dvwRtaFqAC/ucCw==",
       "license": "Apache-2.0"
     },
     "node_modules/@firebase/auth-interop-types": {
-      "version": "0.2.3",
-      "resolved": "https://registry.npmjs.org/@firebase/auth-interop-types/-/auth-interop-types-0.2.3.tgz",
-      "integrity": "sha512-Fc9wuJGgxoxQeavybiuwgyi+0rssr76b+nHpj+eGhXFYAdudMWyfBHvFL/I5fEHniUM/UQdFzi9VXJK2iZF7FQ==",
+      "version": "0.2.4",
+      "resolved": "https://registry.npmjs.org/@firebase/auth-interop-types/-/auth-interop-types-0.2.4.tgz",
+      "integrity": "sha512-JPgcXKCuO+CWqGDnigBtvo09HeBs5u/Ktc2GaFj2m01hLarbxthLNm7Fk8iOP1aqAtXV+fnnGj7U28xmk7IwVA==",
       "license": "Apache-2.0"
     },
     "node_modules/@firebase/component": {
-      "version": "0.6.9",
-      "resolved": "https://registry.npmjs.org/@firebase/component/-/component-0.6.9.tgz",
-      "integrity": "sha512-gm8EUEJE/fEac86AvHn8Z/QW8BvR56TBw3hMW0O838J/1mThYQXAIQBgUv75EqlCZfdawpWLrKt1uXvp9ciK3Q==",
+      "version": "0.7.0",
+      "resolved": "https://registry.npmjs.org/@firebase/component/-/component-0.7.0.tgz",
+      "integrity": "sha512-wR9En2A+WESUHexjmRHkqtaVH94WLNKt6rmeqZhSLBybg4Wyf0Umk04SZsS6sBq4102ZsDBFwoqMqJYj2IoDSg==",
       "license": "Apache-2.0",
       "dependencies": {
-        "@firebase/util": "1.10.0",
+        "@firebase/util": "1.13.0",
         "tslib": "^2.1.0"
+      },
+      "engines": {
+        "node": ">=20.0.0"
       }
     },
     "node_modules/@firebase/database": {
-      "version": "1.0.8",
-      "resolved": "https://registry.npmjs.org/@firebase/database/-/database-1.0.8.tgz",
-      "integrity": "sha512-dzXALZeBI1U5TXt6619cv0+tgEhJiwlUtQ55WNZY7vGAjv7Q1QioV969iYwt1AQQ0ovHnEW0YW9TiBfefLvErg==",
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/@firebase/database/-/database-1.1.0.tgz",
+      "integrity": "sha512-gM6MJFae3pTyNLoc9VcJNuaUDej0ctdjn3cVtILo3D5lpp0dmUHHLFN/pUKe7ImyeB1KAvRlEYxvIHNF04Filg==",
       "license": "Apache-2.0",
       "dependencies": {
-        "@firebase/app-check-interop-types": "0.3.2",
-        "@firebase/auth-interop-types": "0.2.3",
-        "@firebase/component": "0.6.9",
-        "@firebase/logger": "0.4.2",
-        "@firebase/util": "1.10.0",
+        "@firebase/app-check-interop-types": "0.3.3",
+        "@firebase/auth-interop-types": "0.2.4",
+        "@firebase/component": "0.7.0",
+        "@firebase/logger": "0.5.0",
+        "@firebase/util": "1.13.0",
         "faye-websocket": "0.11.4",
         "tslib": "^2.1.0"
+      },
+      "engines": {
+        "node": ">=20.0.0"
       }
     },
     "node_modules/@firebase/database-compat": {
-      "version": "1.0.8",
-      "resolved": "https://registry.npmjs.org/@firebase/database-compat/-/database-compat-1.0.8.tgz",
-      "integrity": "sha512-OpeWZoPE3sGIRPBKYnW9wLad25RaWbGyk7fFQe4xnJQKRzlynWeFBSRRAoLE2Old01WXwskUiucNqUUVlFsceg==",
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/@firebase/database-compat/-/database-compat-2.1.0.tgz",
+      "integrity": "sha512-8nYc43RqxScsePVd1qe1xxvWNf0OBnbwHxmXJ7MHSuuTVYFO3eLyLW3PiCKJ9fHnmIz4p4LbieXwz+qtr9PZDg==",
       "license": "Apache-2.0",
       "dependencies": {
-        "@firebase/component": "0.6.9",
-        "@firebase/database": "1.0.8",
-        "@firebase/database-types": "1.0.5",
-        "@firebase/logger": "0.4.2",
-        "@firebase/util": "1.10.0",
+        "@firebase/component": "0.7.0",
+        "@firebase/database": "1.1.0",
+        "@firebase/database-types": "1.0.16",
+        "@firebase/logger": "0.5.0",
+        "@firebase/util": "1.13.0",
         "tslib": "^2.1.0"
+      },
+      "engines": {
+        "node": ">=20.0.0"
       }
     },
     "node_modules/@firebase/database-types": {
-      "version": "1.0.5",
-      "resolved": "https://registry.npmjs.org/@firebase/database-types/-/database-types-1.0.5.tgz",
-      "integrity": "sha512-fTlqCNwFYyq/C6W7AJ5OCuq5CeZuBEsEwptnVxlNPkWCo5cTTyukzAHRSO/jaQcItz33FfYrrFk1SJofcu2AaQ==",
+      "version": "1.0.16",
+      "resolved": "https://registry.npmjs.org/@firebase/database-types/-/database-types-1.0.16.tgz",
+      "integrity": "sha512-xkQLQfU5De7+SPhEGAXFBnDryUWhhlFXelEg2YeZOQMCdoe7dL64DDAd77SQsR+6uoXIZY5MB4y/inCs4GTfcw==",
       "license": "Apache-2.0",
       "dependencies": {
-        "@firebase/app-types": "0.9.2",
-        "@firebase/util": "1.10.0"
+        "@firebase/app-types": "0.9.3",
+        "@firebase/util": "1.13.0"
       }
     },
     "node_modules/@firebase/logger": {
-      "version": "0.4.2",
-      "resolved": "https://registry.npmjs.org/@firebase/logger/-/logger-0.4.2.tgz",
-      "integrity": "sha512-Q1VuA5M1Gjqrwom6I6NUU4lQXdo9IAQieXlujeHZWvRt1b7qQ0KwBaNAjgxG27jgF9/mUwsNmO8ptBCGVYhB0A==",
+      "version": "0.5.0",
+      "resolved": "https://registry.npmjs.org/@firebase/logger/-/logger-0.5.0.tgz",
+      "integrity": "sha512-cGskaAvkrnh42b3BA3doDWeBmuHFO/Mx5A83rbRDYakPjO9bJtRL3dX7javzc2Rr/JHZf4HlterTW2lUkfeN4g==",
       "license": "Apache-2.0",
       "dependencies": {
         "tslib": "^2.1.0"
+      },
+      "engines": {
+        "node": ">=20.0.0"
       }
     },
     "node_modules/@firebase/util": {
-      "version": "1.10.0",
-      "resolved": "https://registry.npmjs.org/@firebase/util/-/util-1.10.0.tgz",
-      "integrity": "sha512-xKtx4A668icQqoANRxyDLBLz51TAbDP9KRfpbKGxiCAW346d0BeJe5vN6/hKxxmWwnZ0mautyv39JxviwwQMOQ==",
+      "version": "1.13.0",
+      "resolved": "https://registry.npmjs.org/@firebase/util/-/util-1.13.0.tgz",
+      "integrity": "sha512-0AZUyYUfpMNcztR5l09izHwXkZpghLgCUaAGjtMwXnCg3bj4ml5VgiwqOMOxJ+Nw4qN/zJAaOQBcJ7KGkWStqQ==",
+      "hasInstallScript": true,
       "license": "Apache-2.0",
       "dependencies": {
         "tslib": "^2.1.0"
+      },
+      "engines": {
+        "node": ">=20.0.0"
       }
     },
     "node_modules/@google-cloud/firestore": {
@@ -2023,13 +2039,13 @@
       "license": "MIT"
     },
     "node_modules/@sendgrid/client": {
-      "version": "8.1.5",
-      "resolved": "https://registry.npmjs.org/@sendgrid/client/-/client-8.1.5.tgz",
-      "integrity": "sha512-Jqt8aAuGIpWGa15ZorTWI46q9gbaIdQFA21HIPQQl60rCjzAko75l3D1z7EyjFrNr4MfQ0StusivWh8Rjh10Cg==",
+      "version": "8.1.6",
+      "resolved": "https://registry.npmjs.org/@sendgrid/client/-/client-8.1.6.tgz",
+      "integrity": "sha512-/BHu0hqwXNHr2aLhcXU7RmmlVqrdfrbY9KpaNj00KZHlVOVoRxRVrpOCabIB+91ISXJ6+mLM9vpaVUhK6TwBWA==",
       "license": "MIT",
       "dependencies": {
         "@sendgrid/helpers": "^8.0.0",
-        "axios": "^1.8.2"
+        "axios": "^1.12.0"
       },
       "engines": {
         "node": ">=12.*"
@@ -2048,9 +2064,9 @@
       }
     },
     "node_modules/@sendgrid/mail": {
-      "version": "8.1.5",
-      "resolved": "https://registry.npmjs.org/@sendgrid/mail/-/mail-8.1.5.tgz",
-      "integrity": "sha512-W+YuMnkVs4+HA/bgfto4VHKcPKLc7NiZ50/NH2pzO6UHCCFuq8/GNB98YJlLEr/ESDyzAaDr7lVE7hoBwFTT3Q==",
+      "version": "8.1.6",
+      "resolved": "https://registry.npmjs.org/@sendgrid/mail/-/mail-8.1.6.tgz",
+      "integrity": "sha512-/ZqxUvKeEztU9drOoPC/8opEPOk+jLlB2q4+xpx6HVLq6aFu3pMpalkTpAQz8XfRfpLp8O25bh6pGPcHDCYpqg==",
       "license": "MIT",
       "dependencies": {
         "@sendgrid/client": "^8.1.5",
@@ -2684,7 +2700,6 @@
       "resolved": "https://registry.npmjs.org/agent-base/-/agent-base-7.1.4.tgz",
       "integrity": "sha512-MnA+YT8fwfJPgBx3m60MNqakm30XOkyIoH1y6huTQvC0PwZG7ki8NacLBcrPbNoo8vEZy7Jpuk7+jMO+CUovTQ==",
       "license": "MIT",
-      "optional": true,
       "engines": {
         "node": ">= 14"
       }
@@ -2974,9 +2989,9 @@
       }
     },
     "node_modules/axios": {
-      "version": "1.12.2",
-      "resolved": "https://registry.npmjs.org/axios/-/axios-1.12.2.tgz",
-      "integrity": "sha512-vMJzPewAlRyOgxV2dU0Cuz2O8zzzx9VYtbJOaBgXFeLc4IV/Eg50n4LowmehOOR61S8ZMpc2K5Sa7g6A4jfkUw==",
+      "version": "1.13.0",
+      "resolved": "https://registry.npmjs.org/axios/-/axios-1.13.0.tgz",
+      "integrity": "sha512-zt40Pz4zcRXra9CVV31KeyofwiNvAbJ5B6YPz9pMJ+yOSLikvPT4Yi5LjfgjRa9CawVYBaD1JQzIVcIvBejKeA==",
       "license": "MIT",
       "dependencies": {
         "follow-redirects": "^1.15.6",
@@ -3128,15 +3143,13 @@
           "url": "https://feross.org/support"
         }
       ],
-      "license": "MIT",
-      "optional": true
+      "license": "MIT"
     },
     "node_modules/bignumber.js": {
       "version": "9.3.1",
       "resolved": "https://registry.npmjs.org/bignumber.js/-/bignumber.js-9.3.1.tgz",
       "integrity": "sha512-Ko0uX15oIUS7wJ3Rb30Fs6SkVbLmPBAKdlm7q9+ak9bbIeFf0MwuBsQV6z7+X768/cHsfg+WlysDWJcmthjsjQ==",
       "license": "MIT",
-      "optional": true,
       "engines": {
         "node": "*"
       }
@@ -4639,8 +4652,7 @@
       "version": "3.0.2",
       "resolved": "https://registry.npmjs.org/extend/-/extend-3.0.2.tgz",
       "integrity": "sha512-fjquC59cD7CyW6urNXK0FBufkZcoiGG80wTuPujX590cB5Ttln20E2UB4S/WARVqhXffZl2LNgS+gQdPIIim/g==",
-      "license": "MIT",
-      "optional": true
+      "license": "MIT"
     },
     "node_modules/farmhash-modern": {
       "version": "1.1.0",
@@ -4655,7 +4667,6 @@
       "version": "3.1.3",
       "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
       "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
-      "devOptional": true,
       "license": "MIT"
     },
     "node_modules/fast-glob": {
@@ -4837,33 +4848,48 @@
       }
     },
     "node_modules/firebase-admin": {
-      "version": "12.7.0",
-      "resolved": "https://registry.npmjs.org/firebase-admin/-/firebase-admin-12.7.0.tgz",
-      "integrity": "sha512-raFIrOyTqREbyXsNkSHyciQLfv8AUZazehPaQS1lZBSCDYW74FYXU0nQZa3qHI4K+hawohlDbywZ4+qce9YNxA==",
+      "version": "13.5.0",
+      "resolved": "https://registry.npmjs.org/firebase-admin/-/firebase-admin-13.5.0.tgz",
+      "integrity": "sha512-QZOpv1DJRJpH8NcWiL1xXE10tw3L/bdPFlgjcWrqU3ufyOJDYfxB1MMtxiVTwxK16NlybQbEM6ciSich2uWEIQ==",
       "license": "Apache-2.0",
       "dependencies": {
         "@fastify/busboy": "^3.0.0",
-        "@firebase/database-compat": "1.0.8",
-        "@firebase/database-types": "1.0.5",
-        "@types/node": "^22.0.1",
+        "@firebase/database-compat": "^2.0.0",
+        "@firebase/database-types": "^1.0.6",
+        "@types/node": "^22.8.7",
         "farmhash-modern": "^1.1.0",
+        "fast-deep-equal": "^3.1.1",
+        "google-auth-library": "^9.14.2",
         "jsonwebtoken": "^9.0.0",
         "jwks-rsa": "^3.1.0",
         "node-forge": "^1.3.1",
-        "uuid": "^10.0.0"
+        "uuid": "^11.0.2"
       },
       "engines": {
-        "node": ">=14"
+        "node": ">=18"
       },
       "optionalDependencies": {
-        "@google-cloud/firestore": "^7.7.0",
-        "@google-cloud/storage": "^7.7.0"
+        "@google-cloud/firestore": "^7.11.0",
+        "@google-cloud/storage": "^7.14.0"
+      }
+    },
+    "node_modules/firebase-admin/node_modules/uuid": {
+      "version": "11.1.0",
+      "resolved": "https://registry.npmjs.org/uuid/-/uuid-11.1.0.tgz",
+      "integrity": "sha512-0/A9rDy9P7cJ+8w1c9WD9V//9Wj15Ce2MPz8Ri6032usz+NfePxx5AcN3bN+r6ZL6jEo066/yNYB3tn4pQEx+A==",
+      "funding": [
+        "https://github.com/sponsors/broofa",
+        "https://github.com/sponsors/ctavan"
+      ],
+      "license": "MIT",
+      "bin": {
+        "uuid": "dist/esm/bin/uuid"
       }
     },
     "node_modules/firebase-functions": {
-      "version": "6.4.0",
-      "resolved": "https://registry.npmjs.org/firebase-functions/-/firebase-functions-6.4.0.tgz",
-      "integrity": "sha512-Q/LGhJrmJEhT0dbV60J4hCkVSeOM6/r7xJS/ccmkXzTWMjo+UPAYX9zlQmGlEjotstZ0U9GtQSJSgbB2Z+TJDg==",
+      "version": "6.6.0",
+      "resolved": "https://registry.npmjs.org/firebase-functions/-/firebase-functions-6.6.0.tgz",
+      "integrity": "sha512-wwfo6JF+N7HUExVs5gUFgkgVGHDEog9O+qtouh7IuJWk8TBQ+KwXEgRiXbatSj7EbTu3/yYnHuzh3XExbfF6wQ==",
       "license": "MIT",
       "dependencies": {
         "@types/cors": "^2.8.5",
@@ -5073,7 +5099,6 @@
       "resolved": "https://registry.npmjs.org/gaxios/-/gaxios-6.7.1.tgz",
       "integrity": "sha512-LDODD4TMYx7XXdpwxAVRAIAuB0bzv0s+ywFonY46k126qzQHT9ygyoa9tncmOiQmmDrik65UYsEkv3lbfqQ3yQ==",
       "license": "Apache-2.0",
-      "optional": true,
       "dependencies": {
         "extend": "^3.0.2",
         "https-proxy-agent": "^7.0.1",
@@ -5094,7 +5119,6 @@
         "https://github.com/sponsors/ctavan"
       ],
       "license": "MIT",
-      "optional": true,
       "bin": {
         "uuid": "dist/bin/uuid"
       }
@@ -5104,7 +5128,6 @@
       "resolved": "https://registry.npmjs.org/gcp-metadata/-/gcp-metadata-6.1.1.tgz",
       "integrity": "sha512-a4tiq7E0/5fTjxPAaH4jpjkSv/uCaU2p5KC6HVGrvl0cDjA8iBZv4vv1gyzlmK0ZUKqwpOyQMKzZQe3lTit77A==",
       "license": "Apache-2.0",
-      "optional": true,
       "dependencies": {
         "gaxios": "^6.1.1",
         "google-logging-utils": "^0.0.2",
@@ -5336,7 +5359,6 @@
       "resolved": "https://registry.npmjs.org/google-auth-library/-/google-auth-library-9.15.1.tgz",
       "integrity": "sha512-Jb6Z0+nvECVz+2lzSMt9u98UsoakXxA2HGHMCxh+so3n90XgYWkq5dur19JAJV7ONiJY22yBTyJB1TSkvPq9Ng==",
       "license": "Apache-2.0",
-      "optional": true,
       "dependencies": {
         "base64-js": "^1.3.0",
         "ecdsa-sig-formatter": "^1.0.11",
@@ -5392,7 +5414,6 @@
       "resolved": "https://registry.npmjs.org/google-logging-utils/-/google-logging-utils-0.0.2.tgz",
       "integrity": "sha512-NEgUnEcBiP5HrPzufUkBzJOD/Sxsco3rLNo1F1TNf7ieU8ryUzBhqba8r756CjLX7rn3fHl6iLEwPYuqpoKgQQ==",
       "license": "Apache-2.0",
-      "optional": true,
       "engines": {
         "node": ">=14"
       }
@@ -5429,7 +5450,6 @@
       "resolved": "https://registry.npmjs.org/gtoken/-/gtoken-7.1.0.tgz",
       "integrity": "sha512-pCcEwRi+TKpMlxAQObHDQ56KawURgyAf6jtIY046fJ5tIv3zDe/LEIubckAO8fj6JnAxLdmWkUfNyulQ2iKdEw==",
       "license": "MIT",
-      "optional": true,
       "dependencies": {
         "gaxios": "^6.0.0",
         "jws": "^4.0.0"
@@ -5609,7 +5629,6 @@
       "resolved": "https://registry.npmjs.org/https-proxy-agent/-/https-proxy-agent-7.0.6.tgz",
       "integrity": "sha512-vK9P5/iUfdl95AI+JVyUuIcVtd4ofvtrOr3HNtM2yxC9bnMbEdp3x01OhQNnjb8IJYi38VlTE3mBXwcfvywuSw==",
       "license": "MIT",
-      "optional": true,
       "dependencies": {
         "agent-base": "^7.1.2",
         "debug": "4"
@@ -6077,7 +6096,6 @@
       "version": "2.0.1",
       "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-2.0.1.tgz",
       "integrity": "sha512-hFoiJiTl63nn+kstHGBtewWSKnQLpyb155KHheA1l39uvtO9nWIop1p3udqPcUd/xbF1VLMO4n7OI6p7RbngDg==",
-      "devOptional": true,
       "license": "MIT",
       "engines": {
         "node": ">=8"
@@ -6973,7 +6991,6 @@
       "resolved": "https://registry.npmjs.org/json-bigint/-/json-bigint-1.0.0.tgz",
       "integrity": "sha512-SiPv/8VpZuWbvLSMtTDU8hEfrZWg/mH/nV/b4o0CYbSxu1UIQPLdwKOCIyLQX+VIPO5vrLX3i8qtqFyhdPSUSQ==",
       "license": "MIT",
-      "optional": true,
       "dependencies": {
         "bignumber.js": "^9.0.0"
       }
@@ -7069,7 +7086,6 @@
       "resolved": "https://registry.npmjs.org/jwa/-/jwa-2.0.1.tgz",
       "integrity": "sha512-hRF04fqJIP8Abbkq5NKGN0Bbr3JxlQ+qhZufXVr0DvujKy93ZCbXZMHDL4EOtodSbCWxOqR8MS1tXA5hwqCXDg==",
       "license": "MIT",
-      "optional": true,
       "dependencies": {
         "buffer-equal-constant-time": "^1.0.1",
         "ecdsa-sig-formatter": "1.0.11",
@@ -7098,7 +7114,6 @@
       "resolved": "https://registry.npmjs.org/jws/-/jws-4.0.0.tgz",
       "integrity": "sha512-KDncfTmOZoOMTFG4mBlG0qUIOlc03fmzH+ru6RgYVZhPkyiy/92Owlt/8UEN+a4TXR1FQetfIpJE8ApdvdVxTg==",
       "license": "MIT",
-      "optional": true,
       "dependencies": {
         "jwa": "^2.0.0",
         "safe-buffer": "^5.0.1"
@@ -7508,7 +7523,6 @@
       "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.7.0.tgz",
       "integrity": "sha512-c4FRfUm/dbcWZ7U+1Wq0AwCyFL+3nt2bEw05wfxSz+DWpWsitgmSgYmy2dQdWyKC1694ELPqMs/YzUSNozLt8A==",
       "license": "MIT",
-      "optional": true,
       "dependencies": {
         "whatwg-url": "^5.0.0"
       },
@@ -9635,8 +9649,7 @@
       "version": "0.0.3",
       "resolved": "https://registry.npmjs.org/tr46/-/tr46-0.0.3.tgz",
       "integrity": "sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw==",
-      "license": "MIT",
-      "optional": true
+      "license": "MIT"
     },
     "node_modules/ts-deepmerge": {
       "version": "2.0.7",
@@ -10043,8 +10056,7 @@
       "version": "3.0.1",
       "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-3.0.1.tgz",
       "integrity": "sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ==",
-      "license": "BSD-2-Clause",
-      "optional": true
+      "license": "BSD-2-Clause"
     },
     "node_modules/websocket-driver": {
       "version": "0.7.4",
@@ -10074,7 +10086,6 @@
       "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-5.0.0.tgz",
       "integrity": "sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==",
       "license": "MIT",
-      "optional": true,
       "dependencies": {
         "tr46": "~0.0.3",
         "webidl-conversions": "^3.0.0"
diff --git a/functions/package.json b/functions/package.json
index 28785a0c..d36ba4c5 100644
--- a/functions/package.json
+++ b/functions/package.json
@@ -15,11 +15,11 @@
   },
   "main": "lib/index.js",
   "dependencies": {
-    "@sendgrid/mail": "^8.1.5",
+    "@sendgrid/mail": "^8.1.6",
     "@types/cors": "^2.8.19",
     "cors": "^2.8.5",
-    "firebase-admin": "^12.6.0",
-    "firebase-functions": "^6.0.1",
+    "firebase-admin": "^13.5.0",
+    "firebase-functions": "^6.6.0",
     "node-forge": "^1.3.1",
     "passkit-generator": "^3.3.2",
     "qrcode": "^1.5.3",
diff --git a/functions/src/customEmailVerification.ts b/functions/src/customEmailVerification.ts
index ccb7e81e..07ca8283 100644
--- a/functions/src/customEmailVerification.ts
+++ b/functions/src/customEmailVerification.ts
@@ -2,11 +2,12 @@
 import * as admin from "firebase-admin";
 import {onRequest} from "firebase-functions/v2/https";
 import {defineSecret} from "firebase-functions/params";
-import sgMail, {MailDataRequired} from "@sendgrid/mail";
+// Send all mail via Resend
 import * as logger from "firebase-functions/logger";
 import cors from "cors";
 import type {Request, Response} from "express";
 import {Resend} from "resend";
+import sgMail from "@sendgrid/mail";
 
 if (admin.apps.length === 0) {
   admin.initializeApp();
@@ -14,64 +15,9 @@ if (admin.apps.length === 0) {
 
 const corsHandler = cors({origin: true});
 
-const SENDGRID_KEY = defineSecret("SENDGRID_KEY");
 const SENDGRID_FROM = defineSecret("SENDGRID_FROM");
 const RESEND_API_KEY = defineSecret("RESEND_API_KEY");
-// Dual-provider support: Resend (primary, fast) -> SendGrid (fallback)
-
-let sendgridReady = false;
-
-function ensureSendGrid(): void {
-  if (sendgridReady) return;
-  const key = process.env.SENDGRID_KEY || "";
-  if (!key || !key.startsWith("SG.")) {
-    throw new Error("Missing or invalid SENDGRID_KEY");
-  }
-  sgMail.setApiKey(key);
-  sendgridReady = true;
-}
-
-async function sendViaSendGrid(
-  to: string,
-  subject: string,
-  html: string,
-  text: string,
-): Promise<void> {
-  const startTime = Date.now();
-  ensureSendGrid();
-  const fromEmail = process.env.SENDGRID_FROM || "";
-  if (!fromEmail) throw new Error("Missing SENDGRID_FROM");
-
-  const msg: MailDataRequired = {
-    to,
-    from: {email: fromEmail, name: "Buzzd"},
-    subject,
-    html,
-    text,
-    trackingSettings: {
-      clickTracking: {enable: false, enableText: false},
-      openTracking: {enable: false},
-    },
-    mailSettings: {bypassListManagement: {enable: true}},
-  };
-
-  try {
-    // Hint to some clients (rarely used, harmless if ignored)
-    (msg as any).headers = {
-      "X-Priority": "1",
-      "Priority": "urgent",
-      "Importance": "high",
-    };
-    const sendStart = Date.now();
-    await sgMail.send(msg);
-    const sendDuration = Date.now() - sendStart;
-    const totalDuration = Date.now() - startTime;
-    logger.info(`‚úÖ SendGrid accepted email in ${sendDuration}ms (total: ${totalDuration}ms) ‚Üí ${to}: ${subject}`);
-  } catch (err) {
-    logger.error("SendGrid send error:", err as Error);
-    throw err;
-  }
-}
+const SENDGRID_KEY = defineSecret("SENDGRID_KEY");
 
 async function sendViaResend(
   to: string,
@@ -99,60 +45,81 @@ async function sendViaResend(
     const totalDuration = Date.now() - startTime;
     logger.info(`‚úÖ Resend delivered in ${sendDuration}ms (total: ${totalDuration}ms) ‚Üí ${to}: ${subject} [id: ${result.data?.id}]`);
   } catch (err) {
+    const msg = String((err as Error)?.message || err || "").toLowerCase();
+    const isDomainUnverified = msg.includes("domain") && (msg.includes("not verified") || msg.includes("unverified") || msg.includes("verify"));
+    // If domain isn't verified yet, retry using Resend's test sender so all recipients can get codes during setup
+    if (isDomainUnverified) {
+      try {
+        const fallbackFrom = "onboarding@resend.dev";
+        const retryStart = Date.now();
+        const result = await resend.emails.send({
+          from: `Buzzd <${fallbackFrom}>`,
+          to,
+          subject,
+          html,
+          text,
+        });
+        const retryDuration = Date.now() - retryStart;
+        const totalDuration = Date.now() - startTime;
+        logger.warn(`‚ö†Ô∏è Resend domain unverified. Retried with ${fallbackFrom} in ${retryDuration}ms (total: ${totalDuration}ms) ‚Üí ${to} [id: ${result.data?.id}]`);
+        return;
+      } catch (retryErr) {
+        logger.error("Resend retry (fallback sender) failed:", retryErr as Error);
+      }
+    }
     logger.error("Resend send error:", err as Error);
     throw err;
   }
 }
 
-export async function sendEmailFast(
+async function sendViaSendGrid(
   to: string,
   subject: string,
   html: string,
   text: string,
 ): Promise<void> {
-  const startTime = Date.now();
-
-  // Provider priority: Resend (fast, free) -> SendGrid (fallback)
-  const hasResend = !!(process.env.RESEND_API_KEY);
-  const hasSendGrid = !!(process.env.SENDGRID_KEY);
-
-  // Allow manual override via MAIL_PROVIDER env var
-  const preference = (process.env.MAIL_PROVIDER || "").toLowerCase();
-
-  // Try providers in order of preference
-  const providers = [];
-  if (preference === "sendgrid" && hasSendGrid) {
-    providers.push({name: "sendgrid", fn: sendViaSendGrid});
-  } else {
-    // Default priority: Resend -> SendGrid
-    if (hasResend) providers.push({name: "resend", fn: sendViaResend});
-    if (hasSendGrid) providers.push({name: "sendgrid", fn: sendViaSendGrid});
-  }
-
-  if (providers.length === 0) {
-    throw new Error("No email providers configured");
-  }
+  const token = process.env.SENDGRID_KEY || "";
+  if (!token) throw new Error("Missing SENDGRID_KEY");
+  const fromEmail = process.env.SENDGRID_FROM || "noreply@joinbuzzd.com";
+  sgMail.setApiKey(token);
+  const start = Date.now();
+  const msg: sgMail.MailDataRequired = {
+    to,
+    from: { email: fromEmail, name: "Buzzd" },
+    subject,
+    text,
+    html,
+    trackingSettings: {
+      clickTracking: { enable: false, enableText: false },
+      openTracking: { enable: false },
+      subscriptionTracking: { enable: false },
+    },
+    mailSettings: {
+      // ensure SendGrid doesn't sandbox these
+      sandboxMode: { enable: false },
+      bypassListManagement: { enable: true },
+    },
+  };
+  const sendStart = Date.now();
+  const [resp] = await sgMail.send(msg);
+  const sendDuration = Date.now() - sendStart;
+  const totalDuration = Date.now() - start;
+  logger.info(`‚úÖ SendGrid accepted in ${sendDuration}ms (total: ${totalDuration}ms) ‚Üí ${to}: ${subject} [status: ${resp.statusCode}]`);
+}
 
-  let lastError: Error | null = null;
-
-  for (let i = 0; i < providers.length; i++) {
-    const provider = providers[i];
-    try {
-      logger.info(`Attempting to send via ${provider.name} (attempt ${i + 1}/${providers.length})`);
-      await provider.fn(to, subject, html, text);
-      const totalDuration = Date.now() - startTime;
-      logger.info(`‚úÖ Email delivered successfully via ${provider.name} in ${totalDuration}ms total`);
-      return; // Success!
-    } catch (e) {
-      lastError = e as Error;
-      logger.warn(`Provider ${provider.name} failed:`, e as Error);
-      // Continue to next provider
-    }
+export async function sendEmailFast(
+  to: string,
+  subject: string,
+  html: string,
+  text: string,
+): Promise<void> {
+  try {
+    await sendViaSendGrid(to, subject, html, text);
+    return;
+  } catch (e) {
+    logger.error("SendGrid send error:", e as Error);
   }
-
-  // All providers failed
-  logger.error("All email providers failed", lastError);
-  throw lastError || new Error("All email providers failed");
+  await sendViaResend(to, subject, html, text);
 }
 
 function sleep(ms: number): Promise<void> {
@@ -160,13 +127,13 @@ function sleep(ms: number): Promise<void> {
 }
 
 /**
- * Sends a custom email verification link via SendGrid
+ * Sends a 6-digit verification code via email (no links)
  * Expected body: { idToken: string }
  * The idToken must be from a Firebase authenticated user
  */
 export const sendCustomVerificationEmail = onRequest(
   {
-    secrets: [SENDGRID_KEY, SENDGRID_FROM, RESEND_API_KEY],
+    secrets: [RESEND_API_KEY, SENDGRID_FROM, SENDGRID_KEY],
     region: "us-central1",
     memory: "256MiB",
     // Keep one warm instance to reduce email send latency
@@ -206,37 +173,51 @@ export const sendCustomVerificationEmail = onRequest(
           return;
         }
 
-        // Generate Firebase email verification link (to obtain the oobCode)
-        const verificationLink = await admin.auth().generateEmailVerificationLink(
-          user.email,
-          {
-            url: `https://joinbuzzd.app/verification?email=${encodeURIComponent(user.email)}`,
-            handleCodeInApp: true,
-          }
-        );
+        // Check rate limiting: max 3 emails per hour
+        const db = admin.firestore();
+        const userDoc = await db.collection("users").doc(uid).get();
+        const userData = userDoc.data();
+        const lastSentAt = userData?.verificationCodeSentAt?.toMillis() || 0;
+        const sendCount = userData?.verificationCodeSendCount || 0;
+        const hourAgo = Date.now() - 60 * 60 * 1000;
+
+        // Reset counter if more than an hour has passed
+        let newSendCount = sendCount;
+        if (lastSentAt < hourAgo) {
+          newSendCount = 0;
+        }
+
+        if (newSendCount >= 3) {
+          res.status(429).json({error: "Too many verification emails. Please wait an hour."});
+          return;
+        }
+
+        // Generate 6-digit verification code
+        const code = Math.floor(100000 + Math.random() * 900000).toString();
 
-        // Extract oobCode and apiKey, and craft a user-facing link on our domain
-        let customLink = verificationLink; // default to Firebase link if we cannot craft our own
+        // Store code in Firestore with 15-minute expiration
+        const expiresAt = admin.firestore.Timestamp.fromMillis(Date.now() + 15 * 60 * 1000);
         try {
-          const u = new URL(verificationLink);
-          const oob = u.searchParams.get("oobCode");
-          const key = u.searchParams.get("apiKey");
-          const lang = u.searchParams.get("lang") || "en";
-          if (oob && key) {
-            customLink = `https://joinbuzzd.app/verification?mode=verifyEmail&oobCode=${encodeURIComponent(oob)}&apiKey=${encodeURIComponent(key)}&lang=${encodeURIComponent(lang)}&email=${encodeURIComponent(user.email)}`;
-          }
-        } catch (e) {
-          logger.warn("Failed to parse verificationLink; using Firebase link", e as Error);
+          await db.collection("users").doc(uid).set({
+            verificationCode: code,
+            verificationCodeExpiresAt: expiresAt,
+            verificationCodeSentAt: admin.firestore.FieldValue.serverTimestamp(),
+            verificationCodeSendCount: newSendCount + 1,
+          }, { merge: true });
+          logger.info(`‚úÖ Stored code in Firestore for uid=${uid}, email=${user.email}`);
+        } catch (firestoreErr) {
+          logger.error("Failed to store verification code in Firestore", firestoreErr as Error, { uid, email: user.email });
+          throw new Error("Failed to store verification code");
         }
 
-        // Create email HTML
+        // Create simple email with code (no links)
         const html = `
 <!DOCTYPE html>
 <html>
 <head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
-  <title>Verify Your Email - Buzzd</title>
+  <title>Your Buzzd verification code</title>
 </head>
 <body style="margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; background-color: #f5f5f7;">
   <table width="100%" cellpadding="0" cellspacing="0" style="background-color: #f5f5f7; padding: 40px 0;">
@@ -258,31 +239,25 @@ export const sendCustomVerificationEmail = onRequest(
                 Hi there!
               </p>
               <p style="color: #333; font-size: 16px; line-height: 1.6; margin: 0 0 20px 0;">
-                Thanks for signing up for Buzzd with your JMU email. To complete your registration and access the app, please verify your email address by clicking the button below:
+                Your Buzzd verification code is:
               </p>
 
-              <!-- Button (bulletproof) -->
+              <!-- Code Display -->
               <table role="presentation" cellspacing="0" cellpadding="0" border="0" align="center" style="margin: 30px 0;">
                 <tr>
-                  <td align="center">
-                    <!--[if mso]>
-                    <v:roundrect xmlns:v="urn:schemas-microsoft-com:vml" xmlns:w="urn:schemas-microsoft-com:office:word"
-                      href="${customLink}"
-                      style="height:48px;v-text-anchor:middle;width:320px;" arcsize="12%" stroke="f" fillcolor="#667eea">
-                      <w:anchorlock/>
-                      <center style="color:#ffffff;font-family:Arial,sans-serif;font-size:16px;font-weight:700;">Click here to be verified</center>
-                    </v:roundrect>
-                    <![endif]-->
-                    <a href="${customLink}"
-                      style="background-color:#667eea;border-radius:8px;color:#ffffff;display:inline-block;font-family:-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;font-size:16px;font-weight:700;line-height:48px;text-align:center;text-decoration:none;width:320px;-webkit-text-size-adjust:none;mso-hide:all;">
-                      Click here to be verified
-                    </a>
+                  <td align="center" style="background-color: #f5f5f7; border-radius: 12px; padding: 24px 40px;">
+                    <p style="font-size: 40px; font-weight: 700; letter-spacing: 8px; color: #667eea; margin: 0; font-family: 'Courier New', monospace;">
+                      ${code}
+                    </p>
                   </td>
                 </tr>
               </table>
 
-              <p style="color: #666; font-size: 14px; line-height: 1.6; margin: 20px 0 0 0;">
-                After clicking the button, return to the Buzzd app and tap <strong>"I Verified"</strong> to continue.
+              <p style="color: #333; font-size: 16px; line-height: 1.6; margin: 20px 0 0 0;">
+                Open the Buzzd app and enter this code to verify your account.
+              </p>
+              <p style="color: #666; font-size: 14px; line-height: 1.6; margin: 12px 0 0 0;">
+                This code will expire in <strong>15 minutes</strong>.
               </p>
             </td>
           </tr>
@@ -290,12 +265,8 @@ export const sendCustomVerificationEmail = onRequest(
           <!-- Footer -->
           <tr>
             <td style="background-color: #f9f9f9; padding: 30px 40px; border-top: 1px solid #e5e5e5;">
-              <p style="color: #999; font-size: 12px; line-height: 1.6; margin: 0 0 8px 0;">
-                If you didn't create an account with Buzzd, you can safely ignore this email.
-              </p>
               <p style="color: #999; font-size: 12px; line-height: 1.6; margin: 0;">
-                If the button doesn't work, copy and paste this link into your browser:<br>
-                <a href="${customLink}" style="color: #667eea; word-break: break-all;">${customLink}</a>
+                Didn't create an account? You can safely ignore this email.
               </p>
             </td>
           </tr>
@@ -317,35 +288,36 @@ export const sendCustomVerificationEmail = onRequest(
 </html>
         `;
 
-        const text = `
-Verify Your Email - Buzzd
+        const text = `Your Buzzd verification code
 
 Hi there!
 
-Thanks for signing up for Buzzd with your JMU email. To complete your registration and access the app, please verify your email address by clicking the link below:
+Your Buzzd verification code is:
 
-${customLink}
+${code}
 
-After clicking the link, return to the Buzzd app and tap "I Verified" to continue.
+Open the Buzzd app and enter this code to verify your account.
 
-If you didn't create an account with Buzzd, you can safely ignore this email.
+This code will expire in 15 minutes.
+
+Didn't create an account? You can safely ignore this email.
 
 ¬© ${new Date().getFullYear()} Buzzd. All rights reserved.
         `;
 
-        // Send via SendGrid only (single branded sender noreply@joinbuzzd.com)
-        await sendViaSendGrid(
+        // Send email via Resend
+        await sendEmailFast(
           user.email,
-          "Verify Your Email - Buzzd",
+          "Your Buzzd verification code",
           html,
           text
         );
 
-        logger.info(`Custom verification email sent to ${user.email}`);
-        res.json({success: true, message: "Verification email sent"});
+        logger.info(`Verification code sent to ${user.email} (code: ${code}, expires: ${expiresAt.toDate().toISOString()})`);
+        res.json({success: true, message: "Verification code sent"});
       } catch (error) {
-        logger.error("Error sending custom verification email", error as Error);
-        res.status(500).json({error: "Failed to send verification email"});
+        logger.error("Error sending verification code", error as Error);
+        res.status(500).json({error: "Failed to send verification code"});
       }
     });
   }
@@ -414,6 +386,20 @@ export const verifyEmailOobCode = onRequest(
           res.status(resp.status).json({error: code || text || "Unknown error"});
           return;
         }
+
+        // SECURITY: DO NOT auto-approve here to prevent email client auto-click bypass
+        // The mobile app will call UsersService.recordEmailVerification after user confirmation
+        // This prevents Gmail/Apple Mail from auto-verifying by pre-fetching the link
+        if (email) {
+          try {
+            const urec = await admin.auth().getUserByEmail(email);
+            if (urec.emailVerified) {
+              logger.info(`Email verified via oobCode: ${urec.uid} (${email}) - waiting for user confirmation to approve`);
+            }
+          } catch (e) {
+            logger.warn("verifyEmailOobCode: user lookup failed", e as Error, { email });
+          }
+        }
         res.json({success: true});
       } catch (e) {
         logger.error("verifyEmailOobCode exception", e as Error);
@@ -432,7 +418,7 @@ export async function sendViaFirebaseDefault(idToken: string, apiKey: string, em
     canHandleCodeInApp: true,
   };
   if (email) {
-    body.continueUrl = `https://joinbuzzd.app/verification?email=${encodeURIComponent(email)}`;
+    body.continueUrl = `https://joinbuzzd.com/verify?email=${encodeURIComponent(email)}`;
   }
   const resp = await fetch(url, {
     method: "POST",
@@ -478,3 +464,125 @@ export const checkEmailVerified = onRequest(
     });
   }
 );
+
+/**
+ * Verifies a 6-digit email verification code
+ * Expected body: { email: string, code: string }
+ * Returns: { success: boolean, reason?: string }
+ */
+export const verifyEmailCode = onRequest(
+  {
+    region: "us-central1",
+    memory: "256MiB",
+    minInstances: 1,
+    invoker: "public",
+  },
+  async (req: Request, res: Response) => {
+    corsHandler(req, res, async () => {
+      try {
+        if (req.method !== "POST") {
+          res.status(405).json({error: "Method Not Allowed"});
+          return;
+        }
+
+        const email = (req.body?.email as string)?.trim();
+        const code = (req.body?.code as string)?.trim();
+
+        if (!email || !code) {
+          res.status(400).json({success: false, reason: "Missing email or code"});
+          return;
+        }
+
+        // Look up user by email
+        let user;
+        try {
+          user = await admin.auth().getUserByEmail(email);
+          logger.info(`verifyEmailCode: found user uid=${user.uid} for email=${email}`);
+        } catch (e) {
+          logger.warn(`verifyEmailCode: user not found for email ${email}`);
+          res.status(400).json({success: false, reason: "Invalid code"});
+          return;
+        }
+
+        // Check if already verified
+        if (user.emailVerified) {
+          logger.info(`verifyEmailCode: user ${user.uid} already verified`);
+          res.json({success: true, alreadyVerified: true});
+          return;
+        }
+
+        // Get user document from Firestore
+        const db = admin.firestore();
+        const userDoc = await db.collection("users").doc(user.uid).get();
+        const userData = userDoc.data();
+
+        if (!userData) {
+          logger.warn(`verifyEmailCode: no user document found for ${user.uid}`);
+          res.status(400).json({success: false, reason: "Invalid code"});
+          return;
+        }
+
+        const storedCode = userData.verificationCode;
+        const expiresAt = userData.verificationCodeExpiresAt;
+
+        logger.info(`verifyEmailCode: checking code for uid=${user.uid}, storedCode=${storedCode || 'NONE'}, submittedCode=${code}`);
+
+        // Check if code exists
+        if (!storedCode) {
+          logger.warn(`verifyEmailCode: no code stored for ${user.uid}, userData keys: ${Object.keys(userData).join(', ')}`);
+          res.status(400).json({success: false, reason: "No verification code found. Please request a new one."});
+          return;
+        }
+
+        // Check if code has expired
+        if (!expiresAt || expiresAt.toMillis() < Date.now()) {
+          logger.warn(`verifyEmailCode: code expired for ${user.uid}`);
+          // Clear expired code
+          await db.collection("users").doc(user.uid).update({
+            verificationCode: admin.firestore.FieldValue.delete(),
+            verificationCodeExpiresAt: admin.firestore.FieldValue.delete(),
+          });
+          res.status(400).json({success: false, reason: "Code expired. Please request a new one."});
+          return;
+        }
+
+        // Check if code matches
+        if (storedCode !== code) {
+          logger.warn(`verifyEmailCode: invalid code for ${user.uid} (expected: ${storedCode}, got: ${code})`);
+          res.status(400).json({success: false, reason: "Invalid code"});
+          return;
+        }
+
+        // Code is valid! Update Firebase Auth and Firestore
+        try {
+          // Update Firebase Auth (mark email as verified)
+          await admin.auth().updateUser(user.uid, {
+            emailVerified: true,
+          });
+
+          // Update Firestore (approve user and record verification)
+          await db.collection("users").doc(user.uid).set({
+            emailVerified: true,
+            emailVerifiedAt: admin.firestore.FieldValue.serverTimestamp(),
+            approved: true,
+            updatedAt: admin.firestore.FieldValue.serverTimestamp(),
+            // Clear the verification code fields
+            verificationCode: admin.firestore.FieldValue.delete(),
+            verificationCodeExpiresAt: admin.firestore.FieldValue.delete(),
+            verificationCodeSentAt: admin.firestore.FieldValue.delete(),
+            verificationCodeSendCount: admin.firestore.FieldValue.delete(),
+          }, { merge: true });
+
+          logger.info(`‚úÖ Email verified successfully for ${user.uid} (${email})`);
+          res.json({success: true});
+        } catch (updateError) {
+          logger.error("verifyEmailCode: failed to update user", updateError as Error);
+          res.status(500).json({success: false, reason: "Failed to verify email. Please try again."});
+        }
+      } catch (e) {
+        logger.error("verifyEmailCode exception", e as Error);
+        res.status(500).json({success: false, reason: "Internal error"});
+      }
+    });
+  }
+);
diff --git a/functions/src/events.ts b/functions/src/events.ts
index 87718f00..09cc1bfc 100644
--- a/functions/src/events.ts
+++ b/functions/src/events.ts
@@ -1,5 +1,5 @@
 import * as admin from "firebase-admin";
-import {onDocumentCreated} from "firebase-functions/v2/firestore";
+import {onDocumentCreated, onDocumentUpdated} from "firebase-functions/v2/firestore";
 
 if (admin.apps.length === 0) {
   admin.initializeApp();
@@ -9,10 +9,45 @@ type EventDoc = {
   hostUserId?: string;
   hostName?: string;
   title?: string;
+  // Org-hosting fields
+  is_host_org?: boolean;
+  org_hosting_pending?: boolean;
+  host_display_name?: string;
+  // Fields we might monitor for updates
+  address?: string;
+  latitude?: number;
+  longitude?: number;
+  startsAt?: FirebaseFirestore.Timestamp;
+  endsAt?: FirebaseFirestore.Timestamp;
+  description?: string;
 };
 
 const db = admin.firestore();
 
+// Load all known tokens for a user, supporting both the subcollection and
+// legacy top-level array. Includes tokens with active === true or missing.
+async function getUserTokens(uid: string): Promise<string[]> {
+  const uref = db.collection("users").doc(uid);
+  const tokens: string[] = [];
+  // subcollection tokens (preferred source of truth)
+  try {
+    const snap = await uref.collection("fcmTokens").get();
+    snap.docs.forEach((d) => {
+      const active = d.get("active");
+      if (active === undefined || active === true) tokens.push(d.id);
+    });
+  } catch {/* ignore */}
+  // legacy top-level array if present
+  try {
+    const doc = await uref.get();
+    if (doc.exists) {
+      const arr = (doc.get("fcmTokens") || []) as unknown[];
+      arr.forEach((t) => { if (typeof t === "string" && t) tokens.push(t); });
+    }
+  } catch {/* ignore */}
+  return Array.from(new Set(tokens));
+}
+
 /**
  * Creates a user-scoped notification document AND sends FCM push.
  * @param {string} userId Target user ID.
@@ -24,7 +59,7 @@ const db = admin.firestore();
  */
 async function createNotification(
   userId: string,
-  type: "host_posted",
+  type: "host_posted" | "host_updated",
   title: string,
   body: string,
   data: Record<string, string> = {}
@@ -45,14 +80,7 @@ async function createNotification(
 
   // Send FCM push notification
   try {
-    const tokensSnap = await db
-      .collection("users")
-      .doc(userId)
-      .collection("fcmTokens")
-      .where("active", "==", true)
-      .get();
-
-    const tokens = tokensSnap.docs.map((doc) => doc.id);
+    const tokens = await getUserTokens(userId);
 
     if (tokens.length > 0) {
       const message: admin.messaging.MulticastMessage = {
@@ -85,7 +113,7 @@ async function createNotification(
 
       // Clean up invalid tokens
       if (response.failureCount > 0) {
-        const batch = db.batch();
+        const invalid: string[] = [];
         response.responses.forEach((resp, idx) => {
           if (!resp.success && resp.error) {
             const errorCode = resp.error.code;
@@ -93,16 +121,22 @@ async function createNotification(
               errorCode === "messaging/registration-token-not-registered" ||
               errorCode === "messaging/invalid-registration-token"
             ) {
-              const tokenRef = db
-                .collection("users")
-                .doc(userId)
-                .collection("fcmTokens")
-                .doc(tokens[idx]);
-              batch.delete(tokenRef);
+              invalid.push(tokens[idx]);
             }
           }
         });
-        await batch.commit();
+        if (invalid.length) {
+          const uref = db.collection("users").doc(userId);
+          try {
+            await uref.update({
+              fcmTokens: admin.firestore.FieldValue.arrayRemove(...invalid),
+              updatedAt: admin.firestore.FieldValue.serverTimestamp(),
+            });
+          } catch {/* ignore */}
+          await Promise.all(invalid.map(async (tok) => {
+            try { await uref.collection("fcmTokens").doc(tok).delete(); } catch {/* ignore */}
+          }));
+        }
       }
     }
   } catch (err) {
@@ -122,7 +156,11 @@ export const onEventCreated = onDocumentCreated(
     const hostId = String(data.hostUserId || "");
     if (!hostId) return;
 
-    const hostName = String(data.hostName || "A host");
+    const isOrg = Boolean(data.is_host_org);
+    const pending = Boolean(data.org_hosting_pending);
+    const hostDisplayName = String(data.host_display_name || "").trim();
+    const defaultHostName = String(data.hostName || "A host");
+    const hostName = (isOrg && !pending && hostDisplayName) ? hostDisplayName : defaultHostName;
     const eventTitle = String(data.title || "an event");
 
     const subs = await db
@@ -147,3 +185,58 @@ export const onEventCreated = onDocumentCreated(
     await Promise.all(batches);
   }
 );
+
+/**
+ * When an event is updated (address/time/etc.), notify all subscribers of the host.
+ * Only fires for meaningful changes to avoid spam.
+ */
+export const onEventUpdated = onDocumentUpdated(
+  "events/{eventId}",
+  async (event) => {
+    const before = (event.data?.before.data() as EventDoc) || {};
+    const after = (event.data?.after.data() as EventDoc) || {};
+
+    const hostId = String(after.hostUserId || before.hostUserId || "");
+    if (!hostId) return;
+
+    // Detect meaningful changes
+    const changed = (key: keyof EventDoc) => JSON.stringify(before[key]) !== JSON.stringify(after[key]);
+    const importantKeys: (keyof EventDoc)[] = [
+      "address", "latitude", "longitude", "startsAt", "endsAt", "title", "description",
+    ];
+    const anyImportantChanged = importantKeys.some(changed);
+    if (!anyImportantChanged) return;
+
+    // Prefer org display name when approved
+    const isOrg = Boolean(after.is_host_org);
+    const pending = Boolean(after.org_hosting_pending);
+    const hostDisplayName = String(after.host_display_name || "").trim();
+    const defaultHostName = String(after.hostName || before.hostName || "A host");
+    const hostName = (isOrg && !pending && hostDisplayName) ? hostDisplayName : defaultHostName;
+
+    const eventTitle = String(after.title || before.title || "an event");
+    // If address changed, tailor the copy; otherwise generic update
+    const addressChanged = changed("address") || changed("latitude") || changed("longitude");
+    const title = addressChanged ? `Address Updated: ${eventTitle}` : `Event Updated: ${eventTitle}`;
+    const body = addressChanged ? `${hostName} updated the location for ${eventTitle}` : `${hostName} updated ${eventTitle}`;
+
+    // Fan out to subscribers
+    const subs = await db
+      .collection("hostSubscriptions")
+      .where("hostId", "==", hostId)
+      .get();
+
+    if (subs.empty) return;
+
+    const eid = String(event.params.eventId || "");
+    const dataPayload = { eventId: eid, hostId, type: "host_updated", deeplink: eid ? `buzzd://event/${eid}` : "buzzd://notifications" };
+    const batches: Promise<void>[] = [];
+    subs.docs.forEach((doc) => {
+      const subscriberId = String((doc.data() || {}).subscriberId || "");
+      if (!subscriberId) return;
+      batches.push(createNotification(subscriberId, "host_updated", title, body, dataPayload));
+    });
+
+    await Promise.all(batches);
+  }
+);
diff --git a/functions/src/friends.ts b/functions/src/friends.ts
index d3437738..31f45ee8 100644
--- a/functions/src/friends.ts
+++ b/functions/src/friends.ts
@@ -20,6 +20,30 @@ type FriendRequest = {
 
 const db = admin.firestore();
 
+// Load all known tokens for a user, supporting both the subcollection and
+// legacy top-level array. Includes tokens with active === true or missing.
+async function getUserTokens(uid: string): Promise<string[]> {
+  const uref = db.collection("users").doc(uid);
+  const tokens: string[] = [];
+  // subcollection tokens (preferred source of truth)
+  try {
+    const snap = await uref.collection("fcmTokens").get();
+    snap.docs.forEach((d) => {
+      const active = d.get("active");
+      if (active === undefined || active === true) tokens.push(d.id);
+    });
+  } catch {/* ignore */}
+  // legacy top-level array if present
+  try {
+    const doc = await uref.get();
+    if (doc.exists) {
+      const arr = (doc.get("fcmTokens") || []) as unknown[];
+      arr.forEach((t) => { if (typeof t === "string" && t) tokens.push(t); });
+    }
+  } catch {/* ignore */}
+  return Array.from(new Set(tokens));
+}
+
 /**
  * Creates a user-scoped notification document AND sends FCM push.
  *
@@ -58,14 +82,7 @@ async function createNotification(
 
   // Send FCM push notification
   try {
-    const tokensSnap = await db
-      .collection("users")
-      .doc(userId)
-      .collection("fcmTokens")
-      .where("active", "==", true)
-      .get();
-
-    const tokens = tokensSnap.docs.map((doc) => doc.id);
+    const tokens = await getUserTokens(userId);
 
     if (tokens.length > 0) {
       const message: admin.messaging.MulticastMessage = {
@@ -107,7 +124,7 @@ async function createNotification(
 
       // Clean up invalid tokens
       if (response.failureCount > 0) {
-        const batch = db.batch();
+        const invalid: string[] = [];
         response.responses.forEach((resp, idx) => {
           if (!resp.success && resp.error) {
             const errorCode = resp.error.code;
@@ -115,16 +132,23 @@ async function createNotification(
               errorCode === "messaging/registration-token-not-registered" ||
               errorCode === "messaging/invalid-registration-token"
             ) {
-              const tokenRef = db
-                .collection("users")
-                .doc(userId)
-                .collection("fcmTokens")
-                .doc(tokens[idx]);
-              batch.delete(tokenRef);
+              invalid.push(tokens[idx]);
             }
           }
         });
-        await batch.commit();
+        if (invalid.length) {
+          const uref = db.collection("users").doc(userId);
+          try {
+            await uref.update({
+              fcmTokens: admin.firestore.FieldValue.arrayRemove(...invalid),
+              updatedAt: admin.firestore.FieldValue.serverTimestamp(),
+            });
+          } catch {/* ignore */}
+          // Delete subcollection docs
+          await Promise.all(invalid.map(async (tok) => {
+            try { await uref.collection("fcmTokens").doc(tok).delete(); } catch {/* ignore */}
+          }));
+        }
       }
     }
   } catch (err) {
diff --git a/functions/src/index.ts b/functions/src/index.ts
index b5be5f88..4e80579d 100644
--- a/functions/src/index.ts
+++ b/functions/src/index.ts
@@ -1,2406 +1,26 @@
-/* eslint-disable require-jsdoc, max-len */
-import * as admin from "firebase-admin";
-import sgMail, {MailDataRequired} from "@sendgrid/mail";
-import * as QRCode from "qrcode";
-// Use require to avoid needing type declarations locally
-// eslint-disable-next-line @typescript-eslint/no-var-requires
-const sharp = require("sharp");
-import {defineSecret} from "firebase-functions/params";
-import {
-  onDocumentCreated,
-  onDocumentUpdated,
-  onDocumentDeleted,
-} from "firebase-functions/v2/firestore";
-import * as logger from "firebase-functions/logger";
-import {onRequest} from "firebase-functions/v2/https";
-import {authEmailExists} from "./authExists";
-import cors = require("cors");
-import Stripe from "stripe";
-import type {Request, Response} from "express";
-import * as crypto from "crypto";
-import {
-  onPlanToGoCreated,
-  onPlanToGoDeleted,
-  onCheckInCreated,
-  onCheckInUpdated,
-  resetVenueStatsNow,
-  resetPlanCountsAt7pm,
-  resetCheckInsAt7am,
-  resetCoverAt7am,
-  resetRatingsAt7am,
-} from "./venueStats";
-import {onFriendRequestCreated, onFriendRequestUpdated} from "./friends";
-import {onEventCreated} from "./events";
-import {testPushWithToken} from "./testPush";
-export {deleteMyAccount} from "./account";
-// Enable Apple Wallet endpoints (getTicketPass, verifyTicketV2, stripeCheckoutWebhook)
+export * from "./account";
+export * from "./adminClaims";
+export * from "./adminTools";
+export * from "./approveVerifiedUsers";
+export * from "./authExists";
+export * from "./autoApproveVerified";
+export * from "./cleanup";
+export * from "./customEmailVerification";
+export * from "./deleteUserAccount";
+export * from "./event-ssr";
+export * from "./events";
+export * from "./findUsername";
+export * from "./fixUserProfile";
+export * from "./friends";
+export * from "./inputValidator";
+export * from "./messages";
+export * from "./nightlife";
+export * from "./passService";
+export * from "./places";
+export * from "./publicStats";
+export * from "./push";
 export * from "./styledTickets";
-// Custom email verification via SendGrid + server-side OOB apply
-export {sendCustomVerificationEmail, verifyEmailOobCode} from "./customEmailVerification";
-// One-time function to approve verified users (fixes bug where approved wasn't set)
-export {approveVerifiedUsers} from "./approveVerifiedUsers";
-// Automatically approve users when they verify their email
-export {autoApproveVerified} from "./autoApproveVerified";
-// Debug function to check and fix a specific user's profile
-export {fixUserProfile} from "./fixUserProfile";
-export {findUsername} from "./findUsername";
-export {deleteUserAccount} from "./deleteUserAccount";
-// PassKit Web Service + push helper
-export { passService, walletPushUpdate, onTicketStatusPush } from "./passService";
-export {selfElevateAdmin, adminHideVenue, adminUnhideVenue} from "./adminClaims";
-import {
-  cleanupMessageIds,
-  cleanupFriendRequestIds,
-  cleanupFriendshipIds,
-  cleanupNotificationIds,
-  backfillFriendLinks,
-} from "./cleanup";
-
-if (admin.apps.length === 0) {
-  admin.initializeApp();
-}
-
-const WAITLIST = "waitlist";
-
-/* ----------------------------- Secrets (v2) ------------------------------ */
-
-const SENDGRID_KEY = defineSecret("SENDGRID_KEY");
-const SENDGRID_FROM = defineSecret("SENDGRID_FROM");
-const ADMIN_EMAILS = defineSecret("ADMIN_EMAILS");
-const STRIPE_SECRET_KEY = defineSecret("STRIPE_SECRET_KEY");
-const STRIPE_PUBLISHABLE_KEY = defineSecret("STRIPE_PUBLISHABLE_KEY");
-const STRIPE_WEBHOOK_SECRET = defineSecret("STRIPE_WEBHOOK_SECRET");
-const TICKET_SIGNING_KEY = defineSecret("TICKET_SIGNING_KEY");
-const APP_BASE_URL = defineSecret("APP_BASE_URL");
-
-/* ------------------------------- Constants ------------------------------- */
-
-const STRIPE_API_VERSION =
-  "2024-06-20" as Stripe.LatestApiVersion;
-
-/* --------------------------------- CORS ---------------------------------- */
-
-const corsHandler = cors({origin: true});
-
-/* --------------------------- SendGrid utilities -------------------------- */
-
-let sendgridReady = false;
-
-function ensureSendGrid(): void {
-  if (sendgridReady) return;
-  const key = process.env.SENDGRID_KEY || "";
-  if (!key || !key.startsWith("SG.")) {
-    throw new Error("Missing or invalid SENDGRID_KEY");
-  }
-  sgMail.setApiKey(key);
-  sendgridReady = true;
-}
-
-function isEmail(s: string): boolean {
-  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(s);
-}
-
-function deriveEmail(
-  data: Record<string, unknown>,
-  params: Record<string, unknown>
-): string | null {
-  const id = String(params.emailDocId || "").toLowerCase();
-  const field = String((data.email as string) || "").toLowerCase();
-  if (field && isEmail(field)) return field;
-  if (id && isEmail(id)) return id;
-  return null;
-}
-
-type AttachmentLike = { content: string; filename: string; type: string; disposition?: string; content_id?: string };
-
-async function sendEmail(
-  to: string,
-  subject: string,
-  html: string,
-  text: string,
-  attachments?: AttachmentLike[]
-): Promise<void> {
-  ensureSendGrid();
-  const fromEmail = process.env.SENDGRID_FROM || "";
-  if (!fromEmail) throw new Error("Missing SENDGRID_FROM");
-
-  const msg: MailDataRequired = {
-    to,
-    from: {email: fromEmail, name: "Buzzd"},
-    subject,
-    html,
-    text,
-    attachments: attachments && attachments.length ? attachments as any : undefined,
-    trackingSettings: {
-      clickTracking: {enable: false, enableText: false},
-      openTracking: {enable: false},
-    },
-    mailSettings: {bypassListManagement: {enable: true}},
-  };
-
-  try {
-    await sgMail.send(msg);
-    logger.info(`Email sent to ${to}: ${subject}`);
-  } catch (err) {
-    logger.error("SendGrid send error:", err as Error);
-  }
-}
-
-/* ------------------------- Firestore: on create -------------------------- */
-
-export const onWaitlistCreate = onDocumentCreated(
-  {
-    document: `${WAITLIST}/{emailDocId}`,
-    secrets: [SENDGRID_KEY, SENDGRID_FROM],
-  },
-  async (event) => {
-    const snap = event.data;
-    if (!snap) return;
-
-    const data = (snap.data() as Record<string, unknown>) || {};
-    const email = deriveEmail(data, event.params);
-
-    if (!email) {
-      logger.error("No valid email on create", {
-        docId: event.params.emailDocId,
-        dataKeys: Object.keys(data),
-      });
-      return;
-    }
-
-    /* eslint-disable max-len */
-    const htmlParts: string[] = [
-      "<div style=\"font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,sans-serif;max-width:640px;margin:0 auto;background:#0d0b10;border-radius:18px;overflow:hidden;box-shadow:0 14px 40px rgba(0,0,0,0.35);\">",
-      "<div style=\"background:radial-gradient(1200px 400px at 50% -100%,#8b5fbf 0%,rgba(139,95,191,0) 60%),linear-gradient(135deg,#6a0dad 0%,#8b5fbf 100%);padding:40px 32px;text-align:center;\">",
-      "<h1 style=\"color:#ffffff;margin:0;font-size:28px;font-weight:900;letter-spacing:-0.3px;\">You're on the Buzzd Waitlist! üéâ</h1>",
-      "</div>",
-      "<div style=\"padding:30px;background:#0d0b10;\">",
-      "<p style=\"font-size:16px;line-height:1.7;color:#e7e3ee;margin:0 0 18px 0;\">Hey there! üëã</p>",
-      `<p style="font-size:16px;line-height:1.7;color:#cfc8db;margin:0 0 22px 0;">Thanks for signing up with <strong style="color:#b993ff;text-decoration:underline;">${email}</strong>. You've officially joined the Buzzd community!</p>`,
-      "<div style=\"background:#20182a;border:1px solid #5f2e9a;padding:18px 20px;margin:22px 0;border-radius:14px;box-shadow:0 0 0 3px rgba(111,50,180,0.18) inset;text-align:center;\">",
-      "<p style=\"margin:0;font-size:18px;font-weight:800;letter-spacing:0.2px;color:#edd9ff;\">\"Stop Guessing. Start Going.\"</p>",
-      "</div>",
-      "<p style=\"font-size:16px;line-height:1.6;color:#e7e3ee;margin:24px 0 8px 0;font-weight:700;\">What's coming:</p>",
-      "<ul style=\"padding-left:20px;margin:10px 0 0 0;color:#cfc8db;font-size:16px;line-height:1.8;\">",
-      "<li>Exclusive JMU access to the hottest spots</li>",
-      "<li>Real-time crowd levels and wait times</li>",
-      "<li>Early access to special events and offers</li>",
-      "</ul>",
-      "<div style=\"text-align:center;margin:34px 0 8px 0;\">",
-      "<a href=\"https://joinbuzzd.app\" style=\"display:inline-block;background:linear-gradient(135deg,#6a0dad 0%,#8b5fbf 100%);color:#ffffff;padding:15px 28px;border-radius:999px;text-decoration:none;font-size:16px;font-weight:800;box-shadow:0 14px 38px rgba(106,13,173,0.45);\">Learn More About Buzzd ‚Üí</a>",
-      "</div>",
-      "<p style=\"margin:18px 0 4px 0;font-size:14px;color:#b4abc3;text-align:center;\">We'll email you when your invite is ready. ü•Ç</p>",
-      "</div>",
-      "</div>",
-    ];
-
-
-    const html = htmlParts.join("");
-
-    const text = [
-      "Hey there,",
-      "",
-      `Thanks for signing up with ${email}.`,
-      "You're on the Buzzd waitlist!",
-      "",
-      "Stop Guessing. Start Going.",
-      "",
-      "What's coming:",
-      "‚Ä¢ Exclusive JMU access",
-      "‚Ä¢ Real-time crowd updates",
-      "‚Ä¢ Early events & offers",
-      "",
-      "Learn more: https://joinbuzzd.app",
-      "",
-      "We'll email you when your invite is ready. ü•Ç",
-    ].join("\n");
-
-    await sendEmail(
-      email,
-      "Welcome to the Buzzd waitlist üéâ",
-      html,
-      text
-    );
-  }
-);
-
-/* ------------------------ Firestore: on approved ------------------------- */
-
-export const onWaitlistApproved = onDocumentUpdated(
-  {
-    document: `${WAITLIST}/{emailDocId}`,
-    secrets: [SENDGRID_KEY, SENDGRID_FROM],
-  },
-  async (event) => {
-    const before =
-      (event.data?.before.data() as Record<string, unknown>) || {};
-    const after =
-      (event.data?.after.data() as Record<string, unknown>) || {};
-    const prev = String(before.status || "").toLowerCase();
-    const curr = String(after.status || "").toLowerCase();
-    if (prev === "approved" || curr !== "approved") return;
-
-    const email = deriveEmail(after, event.params);
-    if (!email) {
-      logger.error("No valid email on approve", {
-        docId: event.params.emailDocId,
-        dataKeys: Object.keys(after),
-      });
-      return;
-    }
-
-    /* eslint-disable max-len */
-    const htmlParts: string[] = [
-      "<div style=\"font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,sans-serif;max-width:640px;margin:0 auto;background:#0d0b10;border-radius:18px;overflow:hidden;box-shadow:0 14px 40px rgba(0,0,0,0.35);\">",
-      "<div style=\"background:radial-gradient(1200px 400px at 50% -100%,#8b5fbf 0%,rgba(139,95,191,0) 60%),linear-gradient(135deg,#6a0dad 0%,#8b5fbf 100%);padding:40px 32px;text-align:center;\">",
-      "<h1 style=\"color:#ffffff;margin:0;font-size:28px;font-weight:900;letter-spacing:-0.3px;\">You're In! üöÄ</h1>",
-      "</div>",
-      "<div style=\"padding:30px;background:#0d0b10;\">",
-      "<p style=\"font-size:16px;line-height:1.7;color:#e7e3ee;margin:0 0 18px 0;\">Hey there! üëã</p>",
-      "<p style=\"font-size:16px;line-height:1.7;color:#cfc8db;margin:0 0 22px 0;\">You've been approved for access to Buzzd ‚Äî your all-in-one nightlife guide at JMU.</p>",
-      "<div style=\"background:#20182a;border:1px solid #5f2e9a;padding:16px 18px;margin:12px 0 22px 0;border-radius:14px;box-shadow:0 0 0 3px rgba(111,50,180,0.18) inset;text-align:center;\">",
-      "<p style=\"margin:0;font-size:16px;font-weight:800;letter-spacing:0.2px;color:#edd9ff;\">\"Stop Guessing. Start Going.\"</p>",
-      "</div>",
-      "<ol style=\"font-size:16px;line-height:1.8;margin:0 0 22px 18px;color:#cfc8db;\">",
-      "<li>Download and open the Buzzd app</li>",
-      `<li>Sign up with this same .edu email: <strong style="color:#b993ff;">${email}</strong></li>`,
-      "<li>Verify your email if prompted</li>",
-      "</ol>",
-      "<div style=\"text-align:center;margin:6px 0 8px 0;\">",
-      "<a href=\"https://joinbuzzd.app/download\" style=\"display:inline-block;background:linear-gradient(135deg,#6a0dad 0%,#8b5fbf 100%);color:#ffffff;padding:15px 28px;border-radius:999px;text-decoration:none;font-size:16px;font-weight:800;box-shadow:0 14px 38px rgba(106,13,173,0.45);\">Get Started Now</a>",
-      "</div>",
-      "<p style=\"margin:18px 0 4px 0;font-size:14px;color:#b4abc3;text-align:center;\">See you inside ü•≥</p>",
-      "</div>",
-      "</div>",
-    ];
-
-
-    const html = htmlParts.join("");
-
-    const text = [
-      "Hey there,",
-      "",
-      "You've been approved for Buzzd!",
-      "Stop Guessing. Start Going.",
-      "",
-      "Steps:",
-      "1) Download/open the app",
-      `2) Sign up with this .edu email: ${email}`,
-      "3) Verify your email if prompted",
-      "",
-      "Get started: https://joinbuzzd.app/download",
-      "",
-      "See you inside!",
-    ].join("\n");
-
-    await sendEmail(
-      email,
-      "Your Buzzd invite is ready üöÄ",
-      html,
-      text
-    );
-  }
-);
-
-/* ------------------------------ Maintenance ------------------------------ */
-export {
-  cleanupMessageIds,
-  cleanupFriendRequestIds,
-  cleanupFriendshipIds,
-  cleanupNotificationIds,
-  backfillFriendLinks,
-};
-
-/* ------------------------------ Messaging Push --------------------------- */
-export {testPushWithToken};
-export {testPushWithTokenRaw} from "./testPushDebug";
-export {pushToToken, pushToUser} from "./push";
-export {pushOnChatMessage} from "./messages";
-function adminEmails(): string[] {
-  const raw = (process.env.ADMIN_EMAILS || "").trim();
-  const arr = raw.split(/[ ,\s]+/).map((s) => s.trim()).filter(isEmail);
-  const from = (process.env.SENDGRID_FROM || "").trim();
-  if (arr.length === 0 && isEmail(from)) return [from];
-  return arr;
-}
-export {
-  computeNightlifeConfidence,
-  recomputeNightlifeScoreNow,
-  seedNightlifeOverrides,
-} from "./nightlife";
-
-/* --------------------- Org verification: notify + approve ----------------- */
-
-export const notifyOrgVerification = onDocumentCreated(
-  {
-    document: "org_verifications/{verificationId}",
-    secrets: [SENDGRID_KEY, SENDGRID_FROM, ADMIN_EMAILS],
-    region: "us-central1",
-    memory: "256MiB",
-    timeoutSeconds: 30,
-    concurrency: 10,
-  },
-  async (event) => {
-    const data = (event.data?.data() as Record<string, unknown>) || {};
-    const org = String(data.organization_name || "");
-    const userId = String(data.user_id || "");
-    const proof = String(data.proof_url || "");
-    if (!org || !userId) return;
-
-    const recipients = adminEmails();
-    if (!recipients.length) return;
-
-    const subject = `Org Verification Request: ${org}`;
-    const text = [
-      "A user has requested to host as an organization.",
-      "",
-      `Organization: ${org}`,
-      `User ID: ${userId}`,
-      `Proof: ${proof || "(no proof url)"}`,
-      "",
-      "Please review in the Firebase Console under 'org_verifications'.",
-    ].join("\n");
-    const html = [
-      `<h2>Org Verification Request: ${org}</h2>`,
-      `<p><strong>User ID:</strong> ${userId}</p>`,
-      proof ? `<p><strong>Proof:</strong> <a href="${proof}">${proof}</a></p>` : "",
-      `<p>Please review in the Firebase Console under <code>org_verifications</code>.</p>`,
-    ].join("");
-
-    for (const to of recipients) {
-      try {
-        await sendEmail(to, subject, html, text);
-      } catch (e) {
-        logger.error("notifyOrgVerification email failed", e as Error, {to});
-      }
-    }
-  }
-);
-
-export const approveOrganization = onDocumentUpdated(
-  {
-    document: "org_verifications/{requestId}",
-    region: "us-central1",
-    memory: "256MiB",
-    timeoutSeconds: 30,
-    concurrency: 20,
-  },
-  async (event) => {
-    const before = (event.data?.before.data() as Record<string, unknown>) || {};
-    const after = (event.data?.after.data() as Record<string, unknown>) || {};
-    const prev = String(before.status || "");
-    const curr = String(after.status || "");
-    if (prev === curr) return;
-
-    const userId = String(after.user_id || "");
-    const org = String(after.organization_name || "");
-    if (!userId || !org) return;
-
-    const status = curr.toLowerCase();
-
-    try {
-      const db = admin.firestore();
-      if (status === "approved") {
-        await db.collection("users").doc(userId).update({
-          org_verified: true,
-          org_name: org,
-          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
-        });
-        // Un-pause any pending org-hosted events for this user
-        const evSnap = await db.collection("events")
-          .where("hostUserId", "==", userId)
-          .where("is_host_org", "==", true)
-          .get();
-        const batch = db.batch();
-        evSnap.docs.forEach((d) => {
-          const data = d.data() as Record<string, unknown>;
-          const isPending = Boolean(data["org_hosting_pending"]);
-          if (isPending) {
-            batch.update(d.ref, { org_hosting_pending: false, updatedAt: admin.firestore.FieldValue.serverTimestamp() });
-          }
-        });
-        await batch.commit();
-        // In-app notification for user
-        await createUserNotification(
-          userId,
-          "org_verification",
-          "Organization Verified",
-          `Your request to host as ${org} was approved.`,
-          { status: "approved", organization: org }
-        );
-        // Optional email to user
-        try {
-          const uDoc = await db.collection("users").doc(userId).get();
-          const email = String((uDoc.data() || {}).email || "");
-          if (email) {
-            const html = `<p>Your organization verification for <strong>${org}</strong> has been approved. You can now host events as your organization.</p>`;
-            const text = `Your organization verification for ${org} has been approved.`;
-            await sendEmail(email, "Buzzd: Organization Verified", html, text);
-          }
-        } catch (e) {
-          logger.warn("email to user on approved failed", e as Error, { userId });
-        }
-      } else if (status === "denied") {
-        // Mark org-hosted events as denied (remain hidden for others)
-        const evSnap = await db.collection("events")
-          .where("hostUserId", "==", userId)
-          .where("is_host_org", "==", true)
-          .get();
-        const batch = db.batch();
-        evSnap.docs.forEach((d) => {
-          const data = d.data() as Record<string, unknown>;
-          const isPending = Boolean(data["org_hosting_pending"]);
-          const alreadyDenied = Boolean(data["org_hosting_denied"]);
-          if (isPending || !alreadyDenied) {
-            batch.update(d.ref, {
-              org_hosting_pending: false,
-              org_hosting_denied: true,
-              updatedAt: admin.firestore.FieldValue.serverTimestamp(),
-            });
-          }
-        });
-        await batch.commit();
-        // In-app notification for denial
-        await createUserNotification(
-          userId,
-          "org_verification",
-          "Organization Verification Denied",
-          `Your organization verification for ${org} was not approved.`,
-          { status: "denied", organization: org }
-        );
-        // Optional email to user
-        try {
-          const uDoc = await db.collection("users").doc(userId).get();
-          const email = String((uDoc.data() || {}).email || "");
-          if (email) {
-            const html = `<p>Your organization verification for <strong>${org}</strong> was not approved. Please check your submission and try again.</p>`;
-            const text = `Your organization verification for ${org} was not approved.`;
-            await sendEmail(email, "Buzzd: Organization Verification Denied", html, text);
-          }
-        } catch (e) {
-          logger.warn("email to user on denied failed", e as Error, { userId });
-        }
-      }
-    } catch (e) {
-      logger.error("approveOrganization update failed", e as Error, {userId, org});
-    }
-  }
-);
-
-/* ------------------------------ Stripe utils ----------------------------- */
-
-let stripeClient: Stripe | null = null;
-
-function ensureStripe(): Stripe {
-  if (stripeClient) return stripeClient;
-  const sk = (process.env.STRIPE_SECRET_KEY || "").trim();
-  if (!sk || !sk.startsWith("sk_")) {
-    throw new Error("Missing STRIPE_SECRET_KEY");
-  }
-  stripeClient = new Stripe(sk, {apiVersion: STRIPE_API_VERSION});
-  return stripeClient;
-}
-
-/* --------------------- Stripe account status cache ----------------------- */
-
-type StripeAcctStatus = {
-  accountId: string;
-  detailsSubmitted: boolean;
-  chargesEnabled: boolean;
-  payoutsEnabled: boolean;
-  createdSec: number;
-  updatedAt: FirebaseFirestore.Timestamp;
-};
-
-const STRIPE_STATUS_TTL_MS = 60_000; // 60 seconds
-
-async function getStripeAccountStatusCached(accountId: string): Promise<StripeAcctStatus | null> {
-  if (!accountId || !accountId.startsWith("acct_")) return null;
-  const db = admin.firestore();
-  const ref = db.collection("stripeAccountStatus").doc(accountId);
-  const now = Date.now();
-
-  try {
-    const snap = await ref.get();
-    if (snap.exists) {
-      const data = snap.data() as Partial<StripeAcctStatus>;
-      const ts = data.updatedAt?.toMillis?.() ?? 0;
-      if (now - ts < STRIPE_STATUS_TTL_MS) {
-        return {
-          accountId,
-          detailsSubmitted: Boolean(data.detailsSubmitted),
-          chargesEnabled: Boolean(data.chargesEnabled),
-          payoutsEnabled: Boolean(data.payoutsEnabled),
-          createdSec: Number(data.createdSec || 0),
-          updatedAt: data.updatedAt as FirebaseFirestore.Timestamp,
-        };
-      }
-    }
-  } catch {
-    // ignore cache read errors
-  }
-
-  // Refresh from Stripe
-  try {
-    const stripe = ensureStripe();
-    const acct = await stripe.accounts.retrieve(accountId);
-    const payload = {
-      detailsSubmitted: Boolean(acct.details_submitted),
-      chargesEnabled: Boolean(acct.charges_enabled),
-      payoutsEnabled: Boolean(acct.payouts_enabled),
-      createdSec: Number(acct.created || 0),
-      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
-    };
-    await ref.set(payload, {merge: true});
-    const out: StripeAcctStatus = {
-      accountId,
-      detailsSubmitted: payload.detailsSubmitted,
-      chargesEnabled: payload.chargesEnabled,
-      payoutsEnabled: payload.payoutsEnabled,
-      createdSec: payload.createdSec,
-      updatedAt: admin.firestore.Timestamp.now(),
-    };
-    return out;
-  } catch (e) {
-    // If Stripe lookup fails, return stale cache if present
-    try {
-      const snap = await ref.get();
-      if (snap.exists) {
-        const data = snap.data() as Partial<StripeAcctStatus>;
-        return {
-          accountId,
-          detailsSubmitted: Boolean(data.detailsSubmitted),
-          chargesEnabled: Boolean(data.chargesEnabled),
-          payoutsEnabled: Boolean(data.payoutsEnabled),
-          createdSec: Number(data.createdSec || 0),
-          updatedAt: (data.updatedAt as FirebaseFirestore.Timestamp),
-        };
-      }
-    } catch {
-      // ignore
-    }
-    logger.warn("Stripe status fetch failed", e as Error);
-    return null;
-  }
-}
-
-async function verifyAuth(req: Request): Promise<string> {
-  const hdr = req.headers.authorization || "";
-  const token = hdr.startsWith("Bearer ") ? hdr.split(" ")[1] : "";
-  if (!token) throw new Error("Unauthorized");
-  const decoded = await admin.auth().verifyIdToken(token);
-  return decoded.uid as string;
-}
-
-/* (Wallet pass endpoint temporarily removed to unblock deployment) */
-
-/* ----------------------- HTTPS: createStripeAccount ----------------------- */
-/* ------------------------- HTTPS: reportEvent ---------------------------- */
-
-export const reportEvent = onRequest(
-  {
-    secrets: [SENDGRID_KEY, SENDGRID_FROM, ADMIN_EMAILS],
-    region: "us-central1",
-    memory: "256MiB",
-    timeoutSeconds: 30,
-    concurrency: 20,
-    invoker: "public",
-  },
-  async (req: Request, res: Response) => {
-    corsHandler(req, res, async () => {
-      try {
-        const uid = await verifyAuth(req);
-        const body = typeof req.body === "string" ? JSON.parse(req.body) : (req.body || {});
-        const eventId = String(body.eventId || "").trim();
-        const reason = String(body.reason || "").trim().slice(0, 200);
-        const details = String(body.details || "").trim().slice(0, 1000);
-        if (!eventId || !reason) {
-          res.status(400).json({error: "Missing eventId or reason"});
-          return;
-        }
-        const db = admin.firestore();
-        const evSnap = await db.collection("events").doc(eventId).get();
-        if (!evSnap.exists) {
-          res.status(404).json({error: "Event not found"});
-          return;
-        }
-        const ev = evSnap.data() as Record<string, unknown>;
-        if (String(ev.hostUserId || "") === uid) {
-          res.status(400).json({error: "You cannot report your own event"});
-          return;
-        }
-        const reporter = await admin.auth().getUser(uid);
-        const reportDoc = {
-          type: "event",
-          status: "open",
-          eventId,
-          eventTitle: String(ev.title || ""),
-          hostUserId: String(ev.hostUserId || ""),
-          reporterId: uid,
-          reporterEmail: reporter.email || "",
-          reason,
-          details,
-          createdAt: admin.firestore.FieldValue.serverTimestamp(),
-        } as const;
-        const ref = await db.collection("reports").add(reportDoc);
-        try {
-          await evSnap.ref.set(
-            {reportCount: admin.firestore.FieldValue.increment(1)},
-            {merge: true},
-          );
-        } catch (incErr) {
-          logger.warn("reportEvent: increment reportCount failed", incErr as Error);
-        }
-
-        const admins = adminEmails();
-        if (admins.length) {
-          const subject = `Buzzd report: ${reportDoc.eventTitle || reportDoc.eventId}`;
-          const html = [
-            "<h3>New Event Report</h3>",
-            `<p><b>Event:</b> ${escapeHtml(reportDoc.eventTitle || "(untitled)")} (${eventId})</p>`,
-            `<p><b>Reason:</b> ${escapeHtml(reason)}</p>`,
-            details ? `<p><b>Details:</b> ${escapeHtml(details)}</p>` : "",
-            `<p><b>Reporter:</b> ${escapeHtml(reportDoc.reporterEmail || uid)}</p>`,
-            `<p><b>Report id:</b> ${ref.id}</p>`,
-          ].join("");
-          const text = (
-            "New Event Report\n" +
-            `Event: ${reportDoc.eventTitle || "(untitled)"} (${eventId})\n` +
-            `Reason: ${reason}\n` +
-            (details ? `Details: ${details}\n` : "") +
-            `Reporter: ${reportDoc.reporterEmail || uid}\n` +
-            `Report id: ${ref.id}\n`
-          );
-          for (const to of admins) {
-            try {
-              await sendEmail(to, subject, html, text);
-            } catch (mailErr) {
-              logger.warn("reportEvent: admin email send failed", mailErr as Error);
-            }
-          }
-        }
-        res.json({ok: true, reportId: ref.id});
-      } catch (e) {
-        logger.error("reportEvent error", e as Error);
-        const msg = (e as Error).message || "Internal error";
-        const code = msg === "Unauthorized" ? 401 : 500;
-        res.status(code).json({error: msg});
-      }
-    });
-  }
-);
-
-function escapeHtml(s: string): string {
-  return s.replace(/[&<>"']/g, (c) => ({
-    "&": "&amp;",
-    "<": "&lt;",
-    ">": "&gt;",
-    "\"": "&quot;",
-    "'": "&#39;",
-  } as Record<string, string>)[c] || c);
-}
-
-export const createStripeAccount = onRequest(
-  {
-    secrets: [STRIPE_SECRET_KEY, APP_BASE_URL],
-    region: "us-central1",
-    memory: "256MiB",
-    timeoutSeconds: 60,
-    concurrency: 20,
-    invoker: "public",
-  },
-  async (req: Request, res: Response) => {
-    corsHandler(req, res, async () => {
-      let uid = "";
-      let uref: FirebaseFirestore.DocumentReference | null = null;
-      try {
-        uid = await verifyAuth(req);
-        const db = admin.firestore();
-        uref = db.collection("users").doc(uid);
-        const udoc = await uref.get();
-        let user = udoc.data() || {};
-        if (!udoc.exists) {
-          // Auto-create a minimal user profile so onboarding can continue
-          const authUser = await admin.auth().getUser(uid);
-          const email = authUser.email || "";
-          const name = authUser.displayName || email || "";
-          await uref.set({
-            email,
-            name,
-            createdAt: admin.firestore.FieldValue.serverTimestamp(),
-            status: "active",
-            approved: true,
-            updatedAt: admin.firestore.FieldValue.serverTimestamp(),
-          }, {merge: true});
-          user = {email, name};
-        }
-        const sk = (process.env.STRIPE_SECRET_KEY || "").trim();
-
-        // Always use HTTPS return/refresh URLs derived from APP_BASE_URL
-        const safeReturn = safeHttpsUrl("/stripe-return");
-        const safeRefresh = safeHttpsUrl("/stripe-refresh");
-
-        // Placeholder path when secrets are not configured
-        if (!sk) {
-          const accountId = `acct_placeholder_${uid}`;
-          await uref.set(
-            {
-              stripeAccountId: accountId,
-              stripeAccountCreatedAt:
-                admin.firestore.FieldValue.serverTimestamp(),
-              updatedAt:
-                admin.firestore.FieldValue.serverTimestamp(),
-            },
-            {merge: true}
-          );
-          res.json({
-            accountId,
-            onboardingUrl: `${safeReturn}?account_id=${accountId}`,
-            refreshUrl: safeRefresh,
-            returnUrl: safeReturn,
-          });
-          return;
-        }
-
-        const stripe = ensureStripe();
-
-        const account = await stripe.accounts.create({
-          type: "express",
-          country: "US",
-          email: user.email,
-          capabilities: {
-            card_payments: {requested: true},
-            transfers: {requested: true},
-          },
-          business_type: "individual",
-          individual: {
-            email: user.email,
-            first_name: String(user.name || "").split(" ")[0] || "",
-            last_name: String(user.name || "")
-              .split(" ")
-              .slice(1)
-              .join(" ") || "",
-          },
-          settings: {payouts: {schedule: {interval: "daily"}}},
-        });
-
-        const link = await stripe.accountLinks.create({
-          account: account.id,
-          refresh_url: safeRefresh,
-          return_url: safeReturn,
-          type: "account_onboarding",
-        });
-
-        await uref.update({
-          stripeAccountId: account.id,
-          stripeAccountCreatedAt:
-            admin.firestore.FieldValue.serverTimestamp(),
-          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
-        });
-
-        res.json({
-          accountId: account.id,
-          onboardingUrl: link.url,
-          refreshUrl: safeRefresh,
-          returnUrl: safeReturn,
-        });
-      } catch (e) {
-        logger.error("createStripeAccount error", e as Error);
-        const msg = (e as Error).message || "Internal error";
-        const code = msg === "Unauthorized" ? 401 : 500;
-        const userMsg = msg.includes("signed up for Connect") ?
-          "Stripe Connect is not enabled for this platform." :
-          msg;
-        res.status(code).json({error: userMsg});
-      }
-    });
-  }
-);
-
-/* ------------------------- HTTPS: getAccountStatus ------------------------ */
-
-export const getAccountStatus = onRequest(
-  {
-    secrets: [STRIPE_SECRET_KEY],
-    region: "us-central1",
-    memory: "256MiB",
-    timeoutSeconds: 30,
-    concurrency: 40,
-    invoker: "public",
-  },
-  async (req: Request, res: Response) => {
-    corsHandler(req, res, async () => {
-      try {
-        const uid = await verifyAuth(req);
-        const {accountId} = req.body || {};
-        if (!accountId) {
-          res.status(400).json({error: "Missing accountId"});
-          return;
-        }
-        const db = admin.firestore();
-        const udoc = await db.collection("users").doc(uid).get();
-        if (!udoc.exists) {
-          // Graceful fallback: treat as not configured
-          res.json({
-            accountId: String(accountId),
-            isActive: false,
-            detailsSubmitted: false,
-            chargesEnabled: false,
-            payoutsEnabled: false,
-            createdAt: new Date(0),
-            updatedAt: new Date(),
-          });
-          return;
-        }
-        // If mismatch, still answer gracefully as "not active"
-        // to avoid blocking the UI unnecessarily.
-        // The caller should update their profile first.
-        const sk = (process.env.STRIPE_SECRET_KEY || "").trim();
-        if (!sk) {
-          // Placeholder status without Stripe API available
-          res.json({
-            accountId: String(accountId),
-            isActive: false,
-            detailsSubmitted: false,
-            chargesEnabled: false,
-            payoutsEnabled: false,
-            createdAt: new Date(0),
-            updatedAt: new Date(),
-          });
-          return;
-        }
-        // If the accountId isn't a valid Stripe ID yet, respond with
-        // a non-active placeholder to keep the UI flowing.
-        if (!String(accountId).startsWith("acct_")) {
-          res.json({
-            accountId: String(accountId),
-            isActive: false,
-            detailsSubmitted: false,
-            chargesEnabled: false,
-            payoutsEnabled: false,
-            createdAt: new Date(0),
-            updatedAt: new Date(),
-          });
-          return;
-        }
-        const status = await getStripeAccountStatusCached(accountId);
-        if (!status) {
-          // Fallback placeholder if no cache and lookup failed
-          res.json({
-            accountId: String(accountId),
-            isActive: false,
-            detailsSubmitted: false,
-            chargesEnabled: false,
-            payoutsEnabled: false,
-            createdAt: new Date(0),
-            updatedAt: new Date(),
-          });
-          return;
-        }
-        res.json({
-          accountId: status.accountId,
-          isActive: status.detailsSubmitted && status.chargesEnabled,
-          detailsSubmitted: status.detailsSubmitted,
-          chargesEnabled: status.chargesEnabled,
-          payoutsEnabled: status.payoutsEnabled,
-          createdAt: new Date(status.createdSec * 1000),
-          updatedAt: new Date(),
-        });
-      } catch (e) {
-        // Return a non-active placeholder when Stripe lookup fails so
-        // the app can still present the onboarding CTA.
-        logger.error("getAccountStatus error", e as Error);
-        const msg = (e as Error).message || "Internal error";
-        const code = msg === "Unauthorized" ? 401 : 200;
-        const payload = {
-          accountId: String((req.body && req.body.accountId) || ""),
-          isActive: false,
-          detailsSubmitted: false,
-          chargesEnabled: false,
-          payoutsEnabled: false,
-          createdAt: new Date(0),
-          updatedAt: new Date(),
-          error: msg,
-        } as const;
-        res.status(code).json(payload);
-      }
-    });
-  }
-);
-
-/* ------------------------ HTTPS: createTicketPayment ---------------------- */
-
-export const createTicketPayment = onRequest(
-  {
-    secrets: [STRIPE_SECRET_KEY, STRIPE_PUBLISHABLE_KEY],
-    region: "us-central1",
-    memory: "512MiB",
-    timeoutSeconds: 90,
-    concurrency: 10,
-    minInstances: 0,
-    invoker: "public",
-  },
-  async (req: Request, res: Response) => {
-    corsHandler(req, res, async () => {
-      try {
-        const uid = await verifyAuth(req);
-        const {
-          eventId,
-          quantity = 1,
-          purchaserId,
-        } = req.body || {};
-        if (!eventId || !purchaserId) {
-          res.status(400).json({error: "Missing fields"});
-          return;
-        }
-        if (purchaserId !== uid) {
-          res.status(403).json({error: "Forbidden"});
-          return;
-        }
-
-        const db = admin.firestore();
-        const evRef = db.collection("events").doc(eventId);
-        const evDoc = await evRef.get();
-        if (!evDoc.exists) {
-          res.status(404).json({error: "Event not found"});
-          return;
-        }
-        const ev = evDoc.data() || {};
-        if (!ev.sellingTickets || !ev.ticketPriceCents) {
-          res.status(400).json({error: "Event is not selling tickets"});
-          return;
-        }
-        // Verify host account can accept charges (cached, 60s). If not, fall back to
-        // a platform-side charge so buyers can still purchase on the website.
-        const hostId = String(ev.stripeAccountId || "").trim();
-        let useConnectDestination = false;
-        if (hostId && hostId.startsWith("acct_")) {
-          const hostStatus = await getStripeAccountStatusCached(hostId);
-          if (hostStatus && hostStatus.chargesEnabled) {
-            useConnectDestination = true;
-          }
-        }
-
-        // Inventory hard-cap check
-        const total = Number(ev.ticketQuantityTotal || 0);
-        const sold = Number(ev.ticketQuantitySold || 0);
-        const remaining = Math.max(0, total - sold);
-        if (Number(quantity) < 1) {
-          res.status(400).json({error: "Quantity must be at least 1"});
-          return;
-        }
-        if (remaining <= 0) {
-          res.status(409).json({error: "Sold out"});
-          return;
-        }
-        if (Number(quantity) > remaining) {
-          res.status(409).json({
-            error: "Not enough tickets available",
-            available: remaining,
-          });
-          return;
-        }
-
-        // If secrets are missing, return placeholders for a graceful UI
-        const sk = (process.env.STRIPE_SECRET_KEY || "").trim();
-        const pk = (process.env.STRIPE_PUBLISHABLE_KEY || "").trim();
-        if (!sk || !pk) {
-          logger.warn("Stripe secrets missing; returning placeholder config", {
-            eventId,
-            purchaserId,
-          });
-          res.json({
-            paymentIntentClientSecret: "pi_test_placeholder_secret",
-            customerEphemeralKeySecret: null,
-            customerId: null,
-            publishableKey: "pk_test_PLACEHOLDER",
-          });
-          return;
-        }
-
-        const stripe = ensureStripe();
-
-        // Ensure a minimal user profile exists so subsequent updates don't 404.
-        const userRef = db.collection("users").doc(purchaserId);
-        let userDoc = await userRef.get();
-        if (!userDoc.exists) {
-          try {
-            const urec = await admin.auth().getUser(purchaserId);
-            await userRef.set({
-              email: urec.email || "",
-              name: urec.displayName || (urec.email ? String(urec.email).split("@")[0] : "User"),
-              status: "active",
-              approved: true,
-              createdAt: admin.firestore.FieldValue.serverTimestamp(),
-              updatedAt: admin.firestore.FieldValue.serverTimestamp(),
-            }, { merge: true });
-            userDoc = await userRef.get();
-          } catch (e) {
-            // Even if auth lookup fails, proceed; we'll still be able to attach stripeCustomerId
-          }
-        }
-        const user = userDoc.data() || {};
-        let customerId = user.stripeCustomerId as string | undefined;
-
-        // Verify existing customer is valid, or create new one
-        if (customerId) {
-          try {
-            // Check if customer exists in current Stripe mode
-            await stripe.customers.retrieve(customerId);
-          } catch (err) {
-            // Customer doesn't exist (e.g., test mode ID in live mode)
-            logger.warn("Stripe customer not found, creating new", {
-              oldCustomerId: customerId,
-              purchaserId,
-              error: (err as Error).message,
-            });
-            customerId = undefined; // Force creation of new customer
-          }
-        }
-
-        if (!customerId) {
-          const customer = await stripe.customers.create({
-            email: user.email,
-            name: user.name,
-            metadata: {userId: purchaserId},
-          });
-          customerId = customer.id;
-          await userRef.set({
-            stripeCustomerId: customerId,
-            updatedAt: admin.firestore.FieldValue.serverTimestamp(),
-          }, { merge: true });
-        }
-
-        // Base price charged to the host per ticket (in cents)
-        const base = Number(ev.ticketPriceCents) * Number(quantity);
-        // Buyer-paid fee: 8% of base (rounded to nearest cent) + $0.99 per ticket
-        const percentageFee = Math.round(base * 0.08); // 8%
-        const perTicketFee = Number(quantity) * 99; // $0.99 per ticket in cents
-        const appFee = percentageFee + perTicketFee;
-        // Charge the buyer base + app fee
-        const amount = base + appFee;
-
-        // Build PI params. If using Connect dest charges, include transfer_data and application fee.
-        const params: Stripe.PaymentIntentCreateParams = {
-          amount,
-          currency: "usd",
-          customer: customerId,
-          metadata: {
-            eventId,
-            quantity: String(quantity),
-            purchaserId,
-            eventTitle: String(ev.title || ""),
-            platform_fallback: useConnectDestination ? "false" : "true",
-            hostStripeAccountId: hostId || "",
-          },
-          automatic_payment_methods: {enabled: true},
-        };
-        if (useConnectDestination) {
-          (params as any).application_fee_amount = appFee; // allowed when transfer_data present
-          (params as any).transfer_data = {destination: hostId};
-        }
-
-        const pi = await stripe.paymentIntents.create(params);
-
-        const ek = await stripe.ephemeralKeys.create(
-          {customer: customerId},
-          {apiVersion: STRIPE_API_VERSION}
-        );
-
-        res.json({
-          paymentIntentClientSecret: pi.client_secret,
-          customerEphemeralKeySecret: ek.secret,
-          customerId,
-          publishableKey: (process.env.STRIPE_PUBLISHABLE_KEY || "").trim(),
-        });
-      } catch (e) {
-        logger.error("createTicketPayment error", e as Error);
-        const msg = (e as Error).message || "Internal error";
-        const code = msg === "Unauthorized" ? 401 : 500;
-        res.status(code).json({error: msg});
-      }
-    });
-  }
-);
-
-/* --------------------------- HTTPS: getEventPublic --------------------------- */
-
-export const getEventPublic = onRequest(
-  {
-    region: "us-central1",
-    memory: "256MiB",
-    timeoutSeconds: 30,
-    concurrency: 30,
-    invoker: "public",
-  },
-  async (req: Request, res: Response) => {
-    corsHandler(req, res, async () => {
-      try {
-        const id = String((req.method === "GET" ? (req.query as any).id : (req.body as any)?.id) || "").trim();
-        if (!id) { res.status(400).json({error: "Missing id"}); return; }
-        const db = admin.firestore();
-        const snap = await db.collection("events").doc(id).get();
-        if (!snap.exists) { res.status(404).json({error: "not_found"}); return; }
-        const ev = (snap.data() || {}) as Record<string, unknown>;
-
-        // Convert Firestore Timestamp to ISO string when available
-        // eslint-disable-next-line @typescript-eslint/no-explicit-any
-        const ts: any = ev["startsAt"];
-        const startsISO = ts && typeof ts.toDate === "function" ? ts.toDate().toISOString() : null;
-
-        const total = typeof ev["ticketQuantityTotal"] === "number" ? Number(ev["ticketQuantityTotal"]) : null;
-        const sold = typeof ev["ticketQuantitySold"] === "number" ? Number(ev["ticketQuantitySold"]) : null;
-        const available = (total != null && sold != null) ? Math.max(0, total - sold) : null;
-
-        const payload = {
-          id: snap.id,
-          title: String(ev["title"] || "Event"),
-          address: String(ev["address"] || ""),
-          startsAt: startsISO,
-          sellingTickets: Boolean(ev["sellingTickets"]),
-          ticketPriceCents: typeof ev["ticketPriceCents"] === "number" ? Number(ev["ticketPriceCents"]) : null,
-          ticketQuantityTotal: total,
-          ticketQuantitySold: sold,
-          availableTickets: available,
-        } as const;
-
-        res.json(payload);
-      } catch (e) {
-        const msg = (e as Error).message || "server_error";
-        res.status(500).json({error: msg});
-      }
-    });
-  }
-);
-
-/* ---------------- HTTP: reissueTicketsForPaymentIntent ------------------ */
-
-// Admin/self-service endpoint to re-run ticket issuance if a webhook was missed.
-// POST JSON: { paymentIntentId: string }
-// Auth required; the caller must match purchaserId from PI metadata.
-export const reissueTicketsForPaymentIntent = onRequest(
-  {
-    secrets: [STRIPE_SECRET_KEY, TICKET_SIGNING_KEY],
-    region: "us-central1",
-    memory: "256MiB",
-    timeoutSeconds: 60,
-    concurrency: 10,
-    invoker: "public",
-  },
-  async (req: Request, res: Response) => {
-    corsHandler(req, res, async () => {
-      try {
-        const uid = await verifyAuth(req);
-        const body = typeof req.body === "string" ? JSON.parse(req.body) : (req.body || {});
-        const piId = String(body.paymentIntentId || body.pi || "").trim();
-        if (!piId || !piId.startsWith("pi_")) { res.status(400).json({error: "Missing or invalid paymentIntentId"}); return; }
-
-        const stripe = ensureStripe();
-        const pi = await stripe.paymentIntents.retrieve(piId);
-        const meta = (pi.metadata || {}) as Record<string, string>;
-        const purchaserId = String(meta.purchaserId || "");
-        if (!purchaserId || purchaserId !== uid) { res.status(403).json({error: "Forbidden"}); return; }
-        if (pi.status !== "succeeded") { res.status(409).json({error: "Payment not succeeded"}); return; }
-
-        await handlePaymentSuccess(pi);
-        res.json({ok: true});
-      } catch (e) {
-        logger.error("reissueTicketsForPaymentIntent error", e as Error);
-        res.status(500).json({error: (e as Error).message || "server_error"});
-      }
-    });
-  }
-);
-
-export {
-  authEmailExists,
-  onPlanToGoCreated,
-  onPlanToGoDeleted,
-  onCheckInCreated,
-  onCheckInUpdated,
-  onFriendRequestCreated,
-  onFriendRequestUpdated,
-  onEventCreated,
-  resetVenueStatsNow,
-  resetPlanCountsAt7pm,
-  resetCheckInsAt7am,
-  resetCoverAt7am,
-  resetRatingsAt7am,
-};
-
-/* ---------------------------- HTTPS: webhook ------------------------------ */
-
-export const stripeWebhook = onRequest(
-  {
-    secrets: [STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET, TICKET_SIGNING_KEY],
-    region: "us-central1",
-    memory: "256MiB",
-    timeoutSeconds: 60,
-    concurrency: 1,
-    minInstances: 0,
-    invoker: "public",
-  },
-  async (req: Request, res: Response) => {
-    try {
-      const stripe = ensureStripe();
-      const sig = req.headers["stripe-signature"] as string;
-      // Trim to avoid signature failures from accidental whitespace/newlines in Secret Manager
-      const whSecretRaw = process.env.STRIPE_WEBHOOK_SECRET || "";
-      const whSecret = whSecretRaw.trim();
-      if (whSecret !== whSecretRaw) {
-        logger.warn("STRIPE_WEBHOOK_SECRET contained surrounding whitespace; trimmed for verification");
-      }
-      if (!sig || !whSecret) {
-        res.status(400).send("Missing signature or secret");
-        return;
-      }
-
-      interface FirebaseRequest extends Request {rawBody: Buffer}
-      const fReq = req as FirebaseRequest;
-
-      const evt = stripe.webhooks.constructEvent(
-        fReq.rawBody,
-        sig,
-        whSecret
-      );
-
-      if (evt.type === "payment_intent.succeeded") {
-        await handlePaymentSuccess(
-          evt.data.object as Stripe.PaymentIntent
-        );
-      } else if (evt.type === "account.updated") {
-        await handleAccountUpdate(
-          evt.data.object as Stripe.Account
-        );
-      } else {
-        logger.info(`Unhandled event type: ${evt.type}`);
-      }
-
-      res.json({received: true});
-    } catch (e) {
-      logger.error("Webhook error", e as Error);
-      res.status(400).send(
-        `Webhook Error: ${(e as Error).message}`
-      );
-    }
-  }
-);
-
-/* ----------------------- Webhook helpers (Stripe) ------------------------ */
-
-async function handlePaymentSuccess(
-  pi: Stripe.PaymentIntent
-): Promise<void> {
-  const meta = pi.metadata || {};
-  const eventId = meta.eventId as string;
-  const requestedQty = parseInt((meta.quantity as string) || "1", 10);
-  const purchaserId = meta.purchaserId as string;
-  const db = admin.firestore();
-
-  if (!eventId || !purchaserId || !requestedQty || requestedQty <= 0) {
-    logger.error("Payment missing metadata", {pi: pi.id, meta});
-    return;
-  }
-
-  // Idempotency: skip if this PaymentIntent was already processed.
-  const existing = await db.collection("tickets")
-    .where("paymentIntentId", "==", pi.id)
-    .limit(1)
-    .get();
-  if (!existing.empty) {
-    logger.info("Skipping issuance; PI already processed", {pi: pi.id});
-    return;
-  }
-
-  const userDoc = await db.collection("users").doc(purchaserId).get();
-  const user = userDoc.data() || {};
-
-  await db.runTransaction(async (tx) => {
-    // All reads first, then writes (Firestore transaction rule)
-    const evRef = db.collection("events").doc(eventId);
-    const evSnap = await tx.get(evRef);
-    if (!evSnap.exists) {
-      throw new Error("EventNotFound");
-    }
-    const ev = evSnap.data() || {};
-    const total = Number(ev.ticketQuantityTotal || 0);
-    const sold = Number(ev.ticketQuantitySold || 0);
-    const remaining = Math.max(0, total - sold);
-    const toIssue = Math.min(remaining, requestedQty);
-
-    if (toIssue <= 0) {
-      // Sold out: nothing to issue. Host may refund manually if needed.
-      logger.warn("Sold out at webhook; no tickets issued", {
-        pi: pi.id,
-        eventId,
-        requestedQty,
-        remaining,
-      });
-      return; // no writes
-    }
-
-    // Writes begin here
-    const piRef = db.collection("paymentIntents").doc(pi.id);
-    tx.create(piRef, {
-      eventId,
-      purchaserId,
-      requestedQty,
-      createdAt: admin.firestore.FieldValue.serverTimestamp(),
-    });
-
-    for (let i = 0; i < toIssue; i++) {
-      const tRef = db.collection("tickets").doc();
-      const issuedAt = admin.firestore.FieldValue.serverTimestamp();
-      const qrPayload = signTicketToken(tRef.id, eventId, purchaserId);
-      const ticket = {
-        eventId,
-        purchaserId,
-        purchaserName: String(user.name || ""),
-        status: "active",
-        qrPayload,
-        paymentIntentId: pi.id,
-        issuedAt,
-        redeemedAt: null,
-      };
-      tx.set(tRef, ticket);
-      const userRef = db.collection("users").doc(purchaserId)
-        .collection("tickets").doc(tRef.id);
-      tx.set(userRef, ticket);
-    }
-
-    tx.update(evRef, {
-      ticketQuantitySold: admin.firestore.FieldValue.increment(toIssue),
-      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
-    });
-  });
-
-  // Post-transaction: email buyer + notify host
-  try {
-    const evDoc = await db.collection("events").doc(eventId).get();
-    const ev = (evDoc.data() || {}) as {
-      title?: string;
-      hostUserId?: string;
-      hostName?: string;
-    };
-    const eventTitle = String(ev.title || "Your event");
-    const hostUserId = String(ev.hostUserId || "");
-
-    // Fetch tickets just issued for this PI
-    // Single-field query avoids requiring a composite index in production
-    const tSnap = await db.collection("tickets")
-      .where("paymentIntentId", "==", pi.id)
-      .get();
-    // Sanity-filter to purchaser in memory (we already know purchaserId from PI metadata)
-
-    const tickets = tSnap.docs.map((d) => ({
-      id: d.id,
-      qrPayload: String((d.data() as Record<string, unknown>).qrPayload || ""),
-    })).filter((t) => t.qrPayload);
-
-    // Email buyer a confirmation with QR PNGs attached (also visible in‚Äëapp)
-    const buyerEmail = String((user as Record<string, unknown>).email || "");
-    if (buyerEmail && tickets.length) {
-      // Build QR attachments (plain, scanner‚Äëfriendly)
-      let attachments: AttachmentLike[] | undefined = undefined;
-      try {
-        const maxAttach = Math.min(tickets.length, 10); // safety cap
-        const pngs = await Promise.all(
-          tickets.slice(0, maxAttach).map(async (t, i) => {
-            const png = await renderPlainQr(t.qrPayload);
-            return {
-              content: png.toString("base64"),
-              filename: `ticket-${i + 1}.png`,
-              type: "image/png",
-              disposition: "attachment",
-              content_id: `qr${i}`,
-            } as AttachmentLike;
-          })
-        );
-        attachments = pngs;
-      } catch (e) {
-        logger.warn("QR attachment generation failed; sending email without attachments", (e as Error).message);
-      }
-      /* eslint-disable max-len, quotes */
-      const html = [
-        `<div style="font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,sans-serif;max-width:640px;margin:0 auto;background:#f7f7fb;border-radius:16px;padding:18px">`,
-        `<h2 style="margin:4px 0 12px 0;color:#111">Purchase Confirmed</h2>`,
-        `<p style="margin:0 0 10px 0;color:#444">Thanks for your purchase for <strong>${eventTitle}</strong>.</p>`,
-        `<p style="margin:0 0 10px 0;color:#444">Open the Buzzd app ‚Üí Events ‚Üí tap the QR button (top left) or the event‚Äôs ‚ÄúYour Tickets‚Äù section to show your QR code at the door.</p>`,
-        `</div>`,
-      ].join("");
-
-      const text = (
-        "Purchase confirmed for " + eventTitle + ". " +
-        "In the app: Events ‚Üí QR button (top left) " +
-        "or the event's Your Tickets to show your QR at the door."
-      );
-      try {
-        await sendEmail(
-          buyerEmail,
-          "Your " + eventTitle + " ticket purchase",
-          html,
-          text,
-          attachments
-        );
-      } catch (err) {
-        // ignore email errors
-      }
-    }
-
-    // Notify host
-    if (hostUserId) {
-      const userRec = (user as Record<string, unknown>) || {};
-      const buyerName = String(userRec.name || "Someone");
-      const count = tickets.length || requestedQty;
-      const title = "New Ticket Purchase";
-      const body = (
-        `${buyerName} bought ${count} ticket` +
-        `${count > 1 ? "s" : ""} for ${eventTitle}`
-      );
-      try {
-        await createUserNotification(
-          hostUserId,
-          "ticket_purchased",
-          title,
-          body,
-          {
-            eventId,
-            purchaserId,
-            paymentIntentId: pi.id,
-          }
-        );
-      } catch (err) {
-        // ignore notification errors
-      }
-    }
-  } catch (e) {
-    logger.error("post-issue notify/email error", e as Error);
-  }
-}
-
-async function handleAccountUpdate(
-  acct: Stripe.Account
-): Promise<void> {
-  const db = admin.firestore();
-  const snap = await db.collection("users")
-    .where("stripeAccountId", "==", acct.id)
-    .limit(1)
-    .get();
-
-  if (snap.empty) return;
-  const ref = snap.docs[0].ref;
-  await ref.update({
-    stripeAccountActive:
-      acct.details_submitted && acct.charges_enabled,
-    stripeAccountPayoutsEnabled: acct.payouts_enabled,
-    updatedAt: admin.firestore.FieldValue.serverTimestamp(),
-  });
-}
-
-// Deprecated: kept for reference.
-
-function signTicketToken(
-  ticketId: string,
-  eventId: string,
-  purchaserId: string
-): string {
-  const key = process.env.TICKET_SIGNING_KEY || "";
-  const msg = `${ticketId}|${eventId}|${purchaserId}`;
-  const sig = crypto
-    .createHmac("sha256", key)
-    .update(msg)
-    .digest("hex");
-  return `v1.${ticketId}.${sig}`;
-}
-
-export const validateTicket = onRequest(
-  {
-    secrets: [TICKET_SIGNING_KEY],
-    region: "us-central1",
-    memory: "256MiB",
-    timeoutSeconds: 60,
-    concurrency: 20,
-    invoker: "public",
-  },
-  async (req: Request, res: Response) => {
-    try {
-      const uid = await verifyAuth(req);
-      const {token, eventId} = req.body || {};
-      if (!token || !eventId) {
-        res.status(400).json({error: "Missing token or eventId", code: "MISSING_FIELDS"});
-        return;
-      }
-      const parts = String(token).split(".");
-      if (parts.length !== 3 || parts[0] !== "v1") {
-        res.status(400).json({error: "Invalid ticket", code: "BAD_TOKEN"});
-        return;
-      }
-      const [, ticketId, sig] = parts;
-      // Lookup ticket
-      const db = admin.firestore();
-      const tRef = db.collection("tickets").doc(ticketId);
-      const snap = await tRef.get();
-      if (!snap.exists) {
-        res.status(404).json({error: "Ticket not found", code: "NOT_FOUND"});
-        return;
-      }
-      const t = snap.data() || {};
-      if (t.eventId !== eventId) {
-        res.status(400).json({error: "This ticket is for a different event", code: "WRONG_EVENT"});
-        return;
-      }
-      // Authorization: only host of the event may validate
-      const ev = await db.collection("events").doc(eventId).get();
-      if (!ev.exists || ev.data()?.hostUserId !== uid) {
-        res.status(403).json({error: "Only the event host can validate tickets", code: "FORBIDDEN"});
-        return;
-      }
-      // Verify signature
-      const key = process.env.TICKET_SIGNING_KEY || "";
-      const tt = t as {purchaserId?: string; userId?: string; eventId?: string};
-      const pId = String(tt.purchaserId || tt.userId || "");
-      const payload = `${ticketId}|${tt.eventId}|${pId}`;
-      const expect = crypto
-        .createHmac("sha256", key)
-        .update(payload)
-        .digest("hex");
-      if (sig !== expect) {
-        res.status(400).json({error: "Invalid ticket", code: "BAD_SIGNATURE"});
-        return;
-      }
-      // Redeem atomically
-      await db.runTransaction(async (tx) => {
-        const doc = await tx.get(tRef);
-        if (!doc.exists) throw new Error("NotFound");
-        const curr = doc.data() || {};
-        if (curr.status !== "active") throw new Error("AlreadyUsed");
-        tx.update(tRef, {
-          status: "redeemed",
-          redeemedAt: admin.firestore.FieldValue.serverTimestamp(),
-        });
-        const uRef = db.collection("users").doc(curr.purchaserId)
-          .collection("tickets").doc(ticketId);
-        tx.update(uRef, {
-          status: "redeemed",
-          redeemedAt: admin.firestore.FieldValue.serverTimestamp(),
-        });
-      });
-      res.json({ok: true, ticketId});
-    } catch (e) {
-      const msg = (e as Error)?.message || "error";
-      if (msg === "AlreadyUsed") {
-        res.status(409).json({error: "Ticket has already been used", code: "ALREADY_REDEEMED"});
-      } else {
-        const code = msg === "NotFound" ? 404 : 400;
-        res.status(code).json({error: msg, code: msg});
-      }
-    }
-  }
-);
-
-/* ------------------------ HTTPS: getTicketQr (PNG) ----------------------- */
-
-// Returns a styled PNG QR for a ticket (auth required).
-// Query/body: ticketId OR token=v1.<ticketId>.<sig>
-export const getTicketQr = onRequest(
-  {
-    secrets: [TICKET_SIGNING_KEY],
-    region: "us-central1",
-    memory: "256MiB",
-    timeoutSeconds: 30,
-    concurrency: 30,
-    minInstances: 0,
-    invoker: "public",
-  },
-  async (req: Request, res: Response) => {
-    corsHandler(req, res, async () => {
-    try {
-      const uid = await verifyAuth(req);
-      const q = (req.method === "GET" ? req.query : req.body) as Record<
-        string, unknown
-      >;
-      let ticketId = String(q.ticketId || "");
-      const token = String(q.token || "");
-
-      if (!ticketId && token) {
-        const parts = token.split(".");
-        if (parts.length !== 3 || parts[0] !== "v1") {
-          res.status(400).json({error: "Invalid token format"});
-          return;
-        }
-        const [, tid, sig] = parts;
-        // Verify HMAC
-        const db = admin.firestore();
-        const tRef = db.collection("tickets").doc(tid);
-        const snap = await tRef.get();
-        if (!snap.exists) {
-          res.status(404).json({error: "Ticket not found"});
-          return;
-        }
-        const t = snap.data() as Record<string, unknown>;
-        const tt = t as {purchaserId?: string; userId?: string; eventId?: string};
-        const key = process.env.TICKET_SIGNING_KEY || "";
-        const pId = String(tt.purchaserId || tt.userId || "");
-        const payload = `${tid}|${tt.eventId}|${pId}`;
-        const expect = crypto
-          .createHmac("sha256", key)
-          .update(payload)
-          .digest("hex");
-        if (sig !== expect) {
-          res.status(400).json({error: "Bad signature"});
-          return;
-        }
-        ticketId = tid;
-      }
-
-      if (!ticketId) {
-        res.status(400).json({error: "Missing ticketId or token"});
-        return;
-      }
-
-      const db = admin.firestore();
-      const tRef = db.collection("tickets").doc(ticketId);
-      const snap = await tRef.get();
-      if (!snap.exists) {
-        res.status(404).json({error: "Ticket not found"});
-        return;
-      }
-      const t = snap.data() as Record<string, unknown>;
-      // Support both canonical purchaserId and legacy userId
-      const tt = t as {purchaserId?: string; userId?: string; eventId?: string};
-      const purchaserId = String(tt.purchaserId || tt.userId || "");
-      const eventId = String(tt.eventId || "");
-
-      // Authorization: purchaser or host of the event
-      const ev = await db.collection("events").doc(eventId).get();
-      const hostId = ev.exists ? String((ev.data() || {}).hostUserId || "") :
-        "";
-      if (uid !== purchaserId && uid !== hostId) {
-        res.status(403).json({error: "Forbidden"});
-        return;
-      }
-
-      const text = String(t.qrPayload || "");
-      const layer = String((q.layer || q.debug || "")).trim();
-      const style = String((q.style || "")).toLowerCase();
-      let png: Buffer;
-      try {
-        const evData = (ev.data() || {}) as Record<string, unknown>;
-        const title = String(evData["title"] || "Your Event");
-        const starts = evData["startsAt"] as FirebaseFirestore.Timestamp | undefined;
-        const when = starts ? formatEventDate(starts.toDate()) : "";
-        if (style === "plain") {
-          png = await renderPlainQr(text);
-        } else if (style === "poster") {
-          png = await renderTicketPoster(text, title, when);
-        } else if (style === "neon") {
-          png = await renderNeonTicket(text, title, when);
-        } else {
-          // Default: plain, scanner-friendly QR (no panels, no rings)
-          png = await renderPlainQr(text);
-        }
-      } catch (e) {
-        logger.warn("poster render failed, falling back", (e as Error).message);
-        png = layer ? await renderStyledQrWithLogo(text, layer) : await renderPlainQr(text);
-      }
-      res.setHeader("Content-Type", "image/png");
-      // Avoid heavy caching during development. Production can bump this.
-      res.setHeader("Cache-Control", "no-store, max-age=0");
-      res.status(200).send(png);
-    } catch (e) {
-      const msg = (e as Error).message || "Internal error";
-      res.status(500).json({error: msg});
-    }
-    });
-  }
-);
-
-/* ---------------------- HTTPS: getTicketQrSample (PNG) -------------------- */
-
-// Public, non-authenticated sample renderer to help debug image composition
-// in different runtimes. Returns a PNG. Optional query params:
-// - text: payload to encode (default: "debug-sample|<ts>")
-// - layer: one of raw|alpha|mask|maskrgba|modules|final
-export const getTicketQrSample = onRequest(
-  {
-    region: "us-central1",
-    memory: "256MiB",
-    timeoutSeconds: 30,
-    concurrency: 10,
-    invoker: "public",
-  },
-  async (req: Request, res: Response) => {
-    try {
-      const q = (req.method === "GET" ? req.query : req.body) as Record<string, unknown>;
-      const text = String(q.text || q.payload || `debug-sample|${Date.now()}`);
-      const style = String((q.style || "")).toLowerCase();
-      let png: Buffer;
-      if (style === "plain") {
-        png = await renderPlainQr(text);
-      } else if (style === "neon") {
-        png = await renderNeonTicket(text, "SAMPLE EVENT", formatEventDate(new Date()));
-      } else if (style === "poster") {
-        png = await renderTicketPoster(text, "SAMPLE EVENT", formatEventDate(new Date()));
-      } else {
-        // Default: minimal purple QR, no rings, fills container nicely
-        png = await renderPurpleQrOnly(text);
-      }
-      res.setHeader("Content-Type", "image/png");
-      res.setHeader("Cache-Control", "no-store, max-age=0");
-      res.status(200).send(png);
-    } catch (e) {
-      const msg = (e as Error).message || "Internal error";
-      res.status(500).json({error: msg});
-    }
-  }
-);
-
-/* ----------------------------- QR Rendering ------------------------------ */
-
-// Embed the Buzzd logo to avoid any network fetch.
-let cachedLogo: Buffer | null = null;
-let cachedLogoTried = false;
-const BUZZD_LOGO_BASE64 =
-  "$BASE64";
-
-async function fetchLogo(): Promise<Buffer | null> {
-  if (cachedLogoTried) return cachedLogo;
-  cachedLogoTried = true;
-  try {
-    if (BUZZD_LOGO_BASE64 && BUZZD_LOGO_BASE64.length > 0) {
-      cachedLogo = Buffer.from(BUZZD_LOGO_BASE64, "base64");
-      return cachedLogo;
-    }
-    return null;
-  } catch {
-    cachedLogo = null;
-    return null;
-  }
-}
-
-async function renderStyledQrWithLogo(payload: string, debugLayer = ""): Promise<Buffer> {
-  const qrModuleScale = 16;
-  const marginModules = 2;
-
-  // Base QR: black modules on white background for a robust mask
-  const baseQr = await QRCode.toBuffer(payload, {
-    scale: qrModuleScale,
-    margin: marginModules,
-    errorCorrectionLevel: "H",
-    color: {dark: "#000000ff", light: "#ffffffff"},
-  });
-  const meta = await sharp(baseQr).metadata();
-  const size = Number(meta.width || 960);
-
-  const gradientSvg = (`<svg width="${size}" height="${size}" xmlns="http://www.w3.org/2000/svg">
-      <defs>
-        <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
-          <stop offset="0%" stop-color="#b34cff"/>
-          <stop offset="100%" stop-color="#ff4cf2"/>
-        </linearGradient>
-        <radialGradient id="glow" cx="50%" cy="50%" r="60%">
-          <stop offset="0%" stop-color="#a855f7" stop-opacity="0.35"/>
-          <stop offset="100%" stop-color="#000000" stop-opacity="0"/>
-        </radialGradient>
-      </defs>
-      <rect width="100%" height="100%" fill="url(#g)"/>
-      <rect width="100%" height="100%" fill="url(#glow)"/>
-    </svg>`);
-  const gradient = await sharp(Buffer.from(gradientSvg))
-    .resize(size, size)
-    .png()
-    .toBuffer();
-  // Build a rounded alpha mask from the QR. We then apply this mask to the
-  // gradient using a "dest-in" composite, which is more robust across
-  // environments than joining the alpha channel directly.
-  // Derive a reliable modules mask: luminance threshold and invert
-  const luminance = await sharp(baseQr).removeAlpha().greyscale().toBuffer();
-  const modulesMaskGray = await sharp(luminance).threshold(160).negate().toBuffer();
-  // Log simple stats to help debug mask quality in prod
-  try {
-    const {data, info} = await sharp(modulesMaskGray)
-      .raw()
-      .toBuffer({resolveWithObject: true});
-    let min = 255;
-    let max = 0;
-    let sum = 0;
-    for (let i = 0; i < data.length; i++) {
-      const v = data[i];
-      if (v < min) min = v;
-      if (v > max) max = v;
-      sum += v;
-    }
-    const mean = sum / data.length;
-    logger.info("QR alpha stats", {
-      size,
-      channels: info.channels,
-      min,
-      max,
-      mean: Number(mean.toFixed(2)),
-    });
-  } catch (e) {
-    logger.warn("QR alpha stats failed", (e as Error).message);
-  }
-  // Slight blur softens the harsh square edges so the result looks less
-  // pixelated; threshold brings it back to a clean binary mask.
-  const roundedMaskGray = await sharp(modulesMaskGray)
-    .blur(1.2)
-    .threshold(160)
-    .toBuffer();
-
-  // Convert the grayscale mask into an RGBA where the mask values are the
-  // alpha channel; this avoids any ambiguity about 1-channel inputs.
-  const maskRgba = await sharp({
-    create: {width: size, height: size, channels: 3, background: {r: 0, g: 0, b: 0}},
-  })
-    .joinChannel(roundedMaskGray)
-    .png()
-    .toBuffer();
-
-  // Apply mask via dest-in (keep gradient only where mask is opaque)
-  const modulesMasked = await sharp(gradient)
-    .composite([{input: maskRgba, blend: "dest-in"}])
-    .png()
-    .toBuffer();
-
-  // Debug layers (return intermediates when requested)
-  const layer = (debugLayer || "").toLowerCase();
-  if (layer === "raw") return baseQr; // original QR (black on white)
-  if (layer === "alpha") return await sharp(modulesMaskGray).png().toBuffer();
-  if (layer === "mask") return await sharp(roundedMaskGray).png().toBuffer();
-  if (layer === "maskrgba") return maskRgba; // already PNG
-  if (layer === "modules") return modulesMasked;
-
-  const cardPadding = 64;
-  const cardRadius = 64;
-  const bgSvg = (`<svg width="${size + cardPadding * 2}" height="${size + cardPadding * 2}" xmlns="http://www.w3.org/2000/svg">
-      <defs>
-        <linearGradient id="bg" x1="0" y1="0" x2="0" y2="1">
-          <stop offset="0%" stop-color="#0c0a12"/>
-          <stop offset="100%" stop-color="#151022"/>
-        </linearGradient>
-      </defs>
-      <rect x="0" y="0" width="100%" height="100%" rx="${cardRadius}" ry="${cardRadius}" fill="url(#bg)"/>
-    </svg>`);
-  let canvas = sharp(Buffer.from(bgSvg)).png();
-  // Prefer the joined-alpha composition (modulesB). If any future env issue,
-  // swap to modulesA which uses dest-in.
-  canvas = canvas.composite([{input: modulesMasked, left: cardPadding, top: cardPadding}]);
-
-  try {
-    const logo = await fetchLogo();
-    if (logo) {
-      const badgeSize = Math.round(size * 0.22);
-      const badgeRadius = Math.round(badgeSize * 0.22);
-      const badgeBg = await sharp({
-        create: {
-          width: badgeSize,
-          height: badgeSize,
-          channels: 4,
-          background: {r: 12, g: 10, b: 18, alpha: 1},
-        },
-      })
-        .png()
-        .composite([
-          {
-            input: Buffer.from(`
-              <svg width="${badgeSize}" height="${badgeSize}" xmlns="http://www.w3.org/2000/svg">
-                <defs>
-                  <linearGradient id="g2" x1="0" y1="0" x2="1" y2="1">
-                    <stop offset="0%" stop-color="#ff4cf2"/>
-                    <stop offset="100%" stop-color="#4c6dff"/>
-                  </linearGradient>
-                </defs>
-                <rect width="100%" height="100%" rx="${badgeRadius}" ry="${badgeRadius}" fill="#0c0a12"/>
-                <rect width="100%" height="100%" rx="${badgeRadius}" ry="${badgeRadius}" fill="url(#g2)" opacity="0.08"/>
-              </svg>`),
-            left: 0,
-            top: 0,
-          },
-        ])
-        .png()
-        .toBuffer();
-
-      const logoPng = await sharp(logo).resize(Math.round(badgeSize * 0.78)).png().toBuffer();
-      const centerLeft = cardPadding + Math.round((size - badgeSize) / 2);
-      const centerTop = cardPadding + Math.round((size - badgeSize) / 2);
-      canvas = canvas.composite([
-        {input: badgeBg, left: centerLeft, top: centerTop},
-        {input: logoPng, left: centerLeft + Math.round(badgeSize * 0.11), top: centerTop + Math.round(badgeSize * 0.11)},
-      ]);
-    }
-  } catch {
-    // ignore logo fetch or compose errors
-  }
-
-  // Add circular finder eyes (three marker rings) in the corners.
-  try {
-    const modulePx = qrModuleScale;
-    const marginPx = marginModules * modulePx;
-    const rOuter = 3.5 * modulePx;
-    const rMid = 2.5 * modulePx;
-    const rInner = 1.1 * modulePx;
-    const centers = [
-      {x: marginPx + rOuter, y: marginPx + rOuter}, // top-left
-      {x: size - marginPx - rOuter, y: marginPx + rOuter}, // top-right
-      {x: marginPx + rOuter, y: size - marginPx - rOuter}, // bottom-left
-    ];
-
-    const finderSvg = [`<svg width="${size}" height="${size}" xmlns="http://www.w3.org/2000/svg">`,
-      `<defs>`,
-      `<linearGradient id="fg" x1="0" y1="0" x2="1" y2="1">`,
-      `<stop offset="0%" stop-color="#b34cff"/>`,
-      `<stop offset="100%" stop-color="#ff4cf2"/>`,
-      `</linearGradient>`,
-      `</defs>`,
-      centers.map((c) => [
-        // solid background to cover modules under finder
-        `<circle cx="${c.x}" cy="${c.y}" r="${rOuter + 1}" fill="#0c0a12" fill-opacity="0.95"/>`,
-        // outer ring
-        `<circle cx="${c.x}" cy="${c.y}" r="${rOuter}" fill="none" stroke="url(#fg)" stroke-width="${Math.max(2, modulePx * 0.9)}"/>`,
-        // mid ring (thin)
-        `<circle cx="${c.x}" cy="${c.y}" r="${rMid}" fill="none" stroke="url(#fg)" stroke-opacity="0.65" stroke-width="${Math.max(1, modulePx * 0.6)}"/>`,
-        // center dot
-        `<circle cx="${c.x}" cy="${c.y}" r="${rInner}" fill="url(#fg)"/>`,
-      ].join("")).join(""),
-      `</svg>`].join("");
-    const finder = await sharp(Buffer.from(finderSvg)).png().toBuffer();
-    canvas = canvas.composite([{input: finder, left: cardPadding, top: cardPadding}]);
-  } catch {
-    // ignore finder overlay errors
-  }
-
-  return await canvas.png().toBuffer();
-}
-
-async function renderPlainQr(payload: string): Promise<Buffer> {
-  // High-contrast, scanner-friendly PNG
-  return QRCode.toBuffer(payload, {
-    scale: 10,
-    margin: 1,
-    errorCorrectionLevel: "H",
-    color: {dark: "#000000ff", light: "#ffffffff"},
-  });
-}
-
-/* ----------------------- Lean Ticket Poster (new) ------------------------ */
-
-function formatEventDate(dt: Date): string {
-  try {
-    const fmt = new Intl.DateTimeFormat("en-US", {
-      month: "short",
-      day: "numeric",
-      hour: "numeric",
-      minute: "2-digit",
-    });
-    // Example: Sep 25, 7:00 PM ‚Üí SEP 25, 7:00 PM
-    return fmt.format(dt).toUpperCase();
-  } catch {
-    return dt.toDateString().toUpperCase();
-  }
-}
-
-async function renderTicketPoster(
-  payload: string,
-  title: string,
-  dateText: string
-): Promise<Buffer> {
-  // Card dimensions in px (portrait)
-  const cardW = 720;
-  const cardH = 1080;
-  const radius = 44;
-  const qrSize = 520;
-
-  // Build a brand gradient background (purple ‚Üí pink)
-  const bgSvg = (`<svg width="${cardW}" height="${cardH}" xmlns="http://www.w3.org/2000/svg">
-    <defs>
-      <linearGradient id="bg" x1="0" y1="0" x2="1" y2="1">
-        <stop offset="0%" stop-color="#6a0dad"/>
-        <stop offset="100%" stop-color="#8b5fbf"/>
-      </linearGradient>
-      <radialGradient id="vibe" cx="70%" cy="30%" r="60%">
-        <stop offset="0%" stop-color="#ffffff" stop-opacity="0.08"/>
-        <stop offset="100%" stop-color="#000000" stop-opacity="0"/>
-      </radialGradient>
-    </defs>
-    <rect x="0" y="0" width="100%" height="100%" rx="${radius}" ry="${radius}" fill="url(#bg)"/>
-    <rect x="0" y="0" width="100%" height="100%" rx="${radius}" ry="${radius}" fill="url(#vibe)"/>
-  </svg>`);
-
-  let canvas = sharp(Buffer.from(bgSvg)).png();
-
-  // Compose date + title via SVG overlay (centered)
-  const safeTitle = title.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
-  const textSvg = (`<svg width="${cardW}" height="${cardH}" xmlns="http://www.w3.org/2000/svg">
-    <style>
-      .date { fill: #E9D5FF; font-size: 20px; font-family: -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto; letter-spacing: 1px; }
-      .title { fill: #FFFFFF; font-size: 52px; font-weight: 800; font-family: -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto; }
-    </style>
-    <text x="50%" y="88" text-anchor="middle" class="date">${dateText}</text>
-    <text x="50%" y="160" text-anchor="middle" class="title">${safeTitle}</text>
-  </svg>`);
-  canvas = canvas.composite([{input: Buffer.from(textSvg), left: 0, top: 0}]);
-
-  // Build a clean, scanner-friendly QR (no extra rings)
-  const qr = await QRCode.toBuffer(payload, {
-    scale: 14,
-    margin: 2,
-    errorCorrectionLevel: "H",
-    color: {dark: "#000000ff", light: "#ffffffff"},
-  });
-  const qrImg = await sharp(qr).resize(qrSize, qrSize, {fit: "contain"}).png().toBuffer();
-  // Subtle frosted panel behind QR (rounded, semi-opaque)
-  const panelSvg = (`<svg width="${qrSize}" height="${qrSize}" xmlns="http://www.w3.org/2000/svg">
-    <defs>
-      <linearGradient id="panel" x1="0" y1="0" x2="1" y2="1">
-        <stop offset="0%" stop-color="#ffffff" stop-opacity="0.95"/>
-        <stop offset="100%" stop-color="#f2e8ff" stop-opacity="0.92"/>
-      </linearGradient>
-    </defs>
-    <rect x="0" y="0" width="100%" height="100%" rx="28" ry="28" fill="url(#panel)"/>
-  </svg>`);
-  const qrPanel = await sharp(Buffer.from(panelSvg)).png().toBuffer();
-
-  const qrLeft = Math.round((cardW - qrSize) / 2);
-  const qrTop = 260;
-  canvas = canvas.composite([
-    {input: qrPanel, left: qrLeft, top: qrTop},
-    {input: qrImg, left: qrLeft, top: qrTop},
-  ]);
-
-  return await canvas.png().toBuffer();
-}
-
-/* ---------------------- Minimal Purple QR (square) ---------------------- */
-
-async function renderPurpleQrOnly(payload: string, size = 960): Promise<Buffer> {
-  const qr = await QRCode.toBuffer(payload, {
-    scale: 16,
-    margin: 1,
-    errorCorrectionLevel: "H",
-    color: {dark: "#9B5DE5ff", light: "#00000000"}, // purple on transparent
-  });
-  return await sharp(qr)
-    .resize(size, size, {fit: "contain", background: {r: 0, g: 0, b: 0, alpha: 0}})
-    .png()
-    .toBuffer();
-}
-
-/* -------------------- Neon Ticket (reference-inspired) ------------------- */
-
-// A darker, neon-green themed ticket inspired by the provided reference.
-// Uses a frosted black card, neon green QR modules, and soft vignette.
-async function renderNeonTicket(
-  payload: string,
-  title: string,
-  dateText: string
-): Promise<Buffer> {
-  const cardW = 720;
-  const cardH = 1080;
-  const radius = 44;
-  const qrSize = 520;
-
-  // Deep space background (purple glow to match app)
-  const bgSvg = (`<svg width="${cardW}" height="${cardH}" xmlns="http://www.w3.org/2000/svg">
-    <defs>
-      <linearGradient id="bg" x1="0" y1="0" x2="1" y2="1">
-        <stop offset="0%" stop-color="#0b0a12"/>
-        <stop offset="100%" stop-color="#151022"/>
-      </linearGradient>
-      <radialGradient id="glow" cx="60%" cy="30%" r="65%">
-        <stop offset="0%" stop-color="#9B5DE5" stop-opacity="0.14"/>
-        <stop offset="100%" stop-color="#000000" stop-opacity="0"/>
-      </radialGradient>
-    </defs>
-    <rect x="0" y="0" width="100%" height="100%" rx="${radius}" ry="${radius}" fill="url(#bg)"/>
-    <rect x="0" y="0" width="100%" height="100%" rx="${radius}" ry="${radius}" fill="url(#glow)"/>
-  </svg>`);
-  let canvas = sharp(Buffer.from(bgSvg)).png();
-
-  // Heading
-  const safeTitle = title.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
-  const textSvg = (`<svg width="${cardW}" height="${cardH}" xmlns="http://www.w3.org/2000/svg">
-    <style>
-      .date { fill: #E9D5FF; font-size: 20px; font-family: -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto; letter-spacing: 1px; }
-      .title { fill: #FFFFFF; font-size: 48px; font-weight: 800; font-family: -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto; }
-    </style>
-    <text x="50%" y="88" text-anchor="middle" class="date">${dateText}</text>
-    <text x="50%" y="156" text-anchor="middle" class="title">${safeTitle}</text>
-  </svg>`);
-  canvas = canvas.composite([{input: Buffer.from(textSvg), left: 0, top: 0}]);
-
-  // Simple: generate QR in brand purple with transparent background
-  const qr = await QRCode.toBuffer(payload, {
-    scale: 14,
-    margin: 2,
-    errorCorrectionLevel: "H",
-    color: {dark: "#9B5DE5ff", light: "#00000000"},
-  });
-  const neonModules = await sharp(qr)
-    .resize(qrSize, qrSize, {fit: "contain", background: {r: 0, g: 0, b: 0, alpha: 0}})
-    .png()
-    .toBuffer();
-
-  // Frosted dark panel
-  const panelSvg = (`<svg width="${qrSize}" height="${qrSize}" xmlns="http://www.w3.org/2000/svg">
-    <defs>
-      <linearGradient id="panel" x1="0" y1="0" x2="1" y2="1">
-        <stop offset="0%" stop-color="#0b0f0c" stop-opacity="0.98"/>
-        <stop offset="100%" stop-color="#101015" stop-opacity="0.95"/>
-      </linearGradient>
-    </defs>
-    <rect x="0" y="0" width="100%" height="100%" rx="28" ry="28" fill="url(#panel)"/>
-  </svg>`);
-  const qrPanel = await sharp(Buffer.from(panelSvg)).png().toBuffer();
-
-  // Purple rings in three corners
-  const ring = (n: number) => Buffer.from(`
-    <svg width="${n}" height="${n}" xmlns="http://www.w3.org/2000/svg">
-      <defs>
-        <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
-          <stop offset="0%" stop-color="#9B5DE5"/>
-          <stop offset="100%" stop-color="#FF4CF2"/>
-        </linearGradient>
-      </defs>
-      <circle cx="${n/2}" cy="${n/2}" r="${n/2 - 3}" fill="#0c0a12" />
-      <circle cx="${n/2}" cy="${n/2}" r="${n/2 - 6}" fill="none" stroke="url(#g)" stroke-width="6" />
-      <circle cx="${n/2}" cy="${n/2}" r="${n/2 - 18}" fill="none" stroke="url(#g)" stroke-width="3" opacity="0.9" />
-    </svg>`);
-  const ringImg = await sharp(ring(120)).png().toBuffer();
-
-  const qrLeft = Math.round((cardW - qrSize) / 2);
-  const qrTop = 260;
-  canvas = canvas.composite([
-    {input: qrPanel, left: qrLeft, top: qrTop},
-    {input: neonModules, left: qrLeft, top: qrTop},
-    {input: ringImg, left: qrLeft + 24, top: qrTop + 24},
-    {input: ringImg, left: qrLeft + qrSize - 24 - 120, top: qrTop + 24},
-    {input: ringImg, left: qrLeft + 24, top: qrTop + qrSize - 24 - 120},
-  ]);
-
-  return await canvas.png().toBuffer();
-}
-
-/* --------------------- HTTPS: deleteEvent (host only) --------------------- */
-
-export const deleteEvent = onRequest(
-  {
-    region: "us-central1",
-    memory: "256MiB",
-    timeoutSeconds: 60,
-    concurrency: 20,
-    invoker: "public",
-  },
-  async (req: Request, res: Response) => {
-    corsHandler(req, res, async () => {
-      try {
-        const uid = await verifyAuth(req);
-        const {eventId} = req.body || {};
-        if (!eventId) {
-          res.status(400).json({error: "Missing eventId"});
-          return;
-        }
-        const db = admin.firestore();
-        const evRef = db.collection("events").doc(String(eventId));
-        const evSnap = await evRef.get();
-        if (!evSnap.exists) {
-          res.status(404).json({error: "Event not found"});
-          return;
-        }
-        const ev = evSnap.data() || {};
-        if (String(ev.hostUserId || "") !== uid) {
-          res.status(403).json({error: "Forbidden"});
-          return;
-        }
-        await evRef.delete();
-        res.json({ok: true});
-      } catch (e) {
-        const msg = (e as Error).message || "Internal error";
-        res.status(500).json({error: msg});
-      }
-    });
-  }
-);
-
-/* ------------------ HTTPS: repairMyEventsStripeAccount ------------------- */
-
-// Copies the caller's users/{uid}.stripeAccountId into any of their events
-// where event.stripeAccountId is missing or invalid (not acct_...). The
-// caller must be authenticated and have a valid connected account.
-export const repairMyEventsStripeAccount = onRequest(
-  {
-    region: "us-central1",
-    memory: "256MiB",
-    timeoutSeconds: 120,
-    concurrency: 10,
-    invoker: "public",
-  },
-  async (req: Request, res: Response) => {
-    corsHandler(req, res, async () => {
-      try {
-        const uid = await verifyAuth(req);
-        const db = admin.firestore();
-
-        const uref = db.collection("users").doc(uid);
-        const udoc = await uref.get();
-        const user = udoc.data() || {};
-        const acct = String(user.stripeAccountId || "").trim();
-        if (!acct || !acct.startsWith("acct_")) {
-          res.status(400).json({
-            error: "Your Stripe account is not connected (acct_).",
-          });
-          return;
-        }
-
-        const q = db.collection("events")
-          .where("hostUserId", "==", uid);
-        const snap = await q.get();
-        let updated = 0;
-        let checked = 0;
-        for (const doc of snap.docs) {
-          checked++;
-          const ev = doc.data() || {};
-          const curr = String(ev.stripeAccountId || "").trim();
-          const needs = !curr || !curr.startsWith("acct_");
-          if (needs) {
-            await doc.ref.update({
-              stripeAccountId: acct,
-              updatedAt: admin.firestore.FieldValue.serverTimestamp(),
-            });
-            updated++;
-          }
-        }
-        res.json({updated, checked});
-      } catch (e) {
-        logger.error("repairMyEventsStripeAccount error", e as Error);
-        const msg = (e as Error).message || "Internal error";
-        const code = msg === "Unauthorized" ? 401 : 500;
-        res.status(code).json({error: msg});
-      }
-    });
-  }
-);
-
-// Stats computation functions (moved from publicStats.ts)
-const db = admin.firestore();
-const OFFSET = 50; // private boost
-const BASELINE = 52; // minimum shown
-const META_REF = db.doc("meta/waitlist");
-const PUBLIC_REF = db.doc("public/stats");
-
-async function recomputeTx(tx: FirebaseFirestore.Transaction) {
-  const metaSnap = await tx.get(META_REF);
-  const nextRank = metaSnap.exists ? Number(
-    metaSnap.data()?.nextRank ?? 1
-  ) : 1;
-  const real = Math.max(0, nextRank - 1);
-  const display = Math.max(BASELINE, real + OFFSET);
-  tx.set(
-    PUBLIC_REF,
-    {
-      waitlistDisplay: display,
-      realCount: real,
-      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
-    },
-    {merge: true}
-  );
-}
-
-export const waitlistCreated = onDocumentCreated(
-  "waitlist/{id}",
-  async () => {
-    await db.runTransaction((tx) => recomputeTx(tx));
-  }
-);
-
-export const waitlistDeleted = onDocumentDeleted(
-  "waitlist/{id}",
-  async () => {
-    await db.runTransaction((tx) => recomputeTx(tx));
-  }
-);
-
-export const metaWaitlistUpdated = onDocumentUpdated(
-  "meta/waitlist",
-  async () => {
-    await db.runTransaction((tx) => recomputeTx(tx));
-  }
-);
-
-// Manual initializer with public access and CORS
-export const recomputePublicStats = onRequest(
-  {
-    cors: true,
-  },
-  async (req: Request, res: Response) => {
-    res.set("Access-Control-Allow-Origin", "*");
-    res.set("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
-    res.set("Access-Control-Allow-Headers", "Content-Type");
-
-    if (req.method === "OPTIONS") {
-      res.status(204).send("");
-      return;
-    }
-
-    try {
-      await db.runTransaction((tx) => recomputeTx(tx));
-      logger.info("Public stats recomputed successfully");
-      res.status(200).json({
-        success: true,
-        message: "Public stats recomputed successfully",
-      });
-    } catch (e: unknown) {
-      const err = e as Error;
-      logger.error("recomputePublicStats error:", err);
-      res.status(500).json({
-        success: false,
-        error: err?.message || "Internal server error",
-      });
-    }
-  }
-);
-
-/**
- * Creates a user-scoped notification document (no push send).
- */
-async function createUserNotification(
-  userId: string,
-  type: string,
-  title: string,
-  body: string,
-  data: Record<string, string> = {}
-) {
-  const payload = {
-    userId,
-    type,
-    title,
-    body,
-    isRead: false,
-    createdAt: admin.firestore.FieldValue.serverTimestamp(),
-  };
-  await db
-    .collection("users")
-    .doc(userId)
-    .collection("notifications")
-    .add(payload);
-}
-/* ------------------------------ URL helpers ------------------------------ */
-
-const DEFAULT_APP_BASE_URL = "https://joinbuzzd.app";
-
-function appBaseUrl(): string {
-  const raw = (process.env.APP_BASE_URL || DEFAULT_APP_BASE_URL).trim();
-  try {
-    const u = new URL(raw);
-    if (u.protocol !== "https:") throw new Error("bad protocol");
-    return u.toString();
-  } catch {
-    return DEFAULT_APP_BASE_URL;
-  }
-}
-
-function safeHttpsUrl(path: string): string {
-  const base = new URL(appBaseUrl());
-  const p = (path || "").replace(/^\//, "");
-  return new URL(p, base).toString();
-}
+export * from "./testPush";
+export * from "./testPushDebug";
+export * from "./users";
+export * from "./venueStats";
\ No newline at end of file
diff --git a/functions/src/styledTickets.ts b/functions/src/styledTickets.ts
index 4ff8126e..4852b5f7 100644
--- a/functions/src/styledTickets.ts
+++ b/functions/src/styledTickets.ts
@@ -15,7 +15,7 @@ import {mkdtempSync, writeFileSync} from "fs";
 import {tmpdir} from "os";
 import {PKPass} from "passkit-generator";
 import forge from "node-forge";
-import sgMail, {MailDataRequired} from "@sendgrid/mail";
+import { Resend } from "resend";
 import cors from "cors";
 // eslint-disable-next-line @typescript-eslint/no-var-requires
 const sharp = require("sharp");
@@ -25,7 +25,7 @@ const corsHandler = cors({origin: true});
 const STRIPE_SECRET_KEY = defineSecret("STRIPE_SECRET_KEY");
 const STRIPE_WEBHOOK_SECRET = defineSecret("STRIPE_WEBHOOK_SECRET");
 const TICKET_SIGNING_KEY = defineSecret("TICKET_SIGNING_KEY");
-const SENDGRID_KEY = defineSecret("SENDGRID_KEY");
+const RESEND_API_KEY = defineSecret("RESEND_API_KEY");
 const SENDGRID_FROM = defineSecret("SENDGRID_FROM");
 
 // Wallet secrets
@@ -173,7 +173,7 @@ function mustSecret(name: string, value: string | undefined): string {
 
 export const stripeCheckoutWebhook = onRequest(
   {
-    secrets: [STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET, TICKET_SIGNING_KEY, SENDGRID_KEY, SENDGRID_FROM],
+    secrets: [STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET, TICKET_SIGNING_KEY, RESEND_API_KEY, SENDGRID_FROM],
     region: "us-central1",
     memory: "512MiB",
     timeoutSeconds: 90,
@@ -295,12 +295,16 @@ async function createTickets(userId: string, eventId: string, quantity: number,
       content_id: `qr${i}`,
     });
 
+    const userNameRaw = String(userData.name || "");
+    const userEmail = String(userData.email || "");
+    const purchaserName = userNameRaw || (userEmail ? userEmail.split("@")[0] : "Guest");
+
     const data = {
       ticketId,
       userId,
       eventId,
       purchaserId: userId,
-      purchaserName: String(userData.name || ""),
+      purchaserName,
       status: "active",
       issuedAt: admin.firestore.FieldValue.serverTimestamp(),
       redeemedAt: null,
@@ -341,16 +345,10 @@ async function createTickets(userId: string, eventId: string, quantity: number,
   }
 }
 
-// SendGrid email helper
-let sendgridReady = false;
-function ensureSendGrid(): void {
-  if (sendgridReady) return;
-  const key = mustSecret("SENDGRID_KEY", SENDGRID_KEY.value());
-  if (!key || !key.startsWith("SG.")) {
-    throw new Error("Missing or invalid SENDGRID_KEY");
-  }
-  sgMail.setApiKey(key);
-  sendgridReady = true;
+// Resend client helper
+function ensureResend(): Resend {
+  const key = mustSecret("RESEND_API_KEY", RESEND_API_KEY.value());
+  return new Resend(key);
 }
 
 async function sendTicketEmail(
@@ -360,7 +358,7 @@ async function sendTicketEmail(
   attachments: Array<{content: string; filename: string; type: string; disposition: string; content_id: string}>
 ): Promise<void> {
   try {
-    ensureSendGrid();
+    const resend = ensureResend();
     const fromEmail = mustSecret("SENDGRID_FROM", SENDGRID_FROM.value());
 
     const ticketWord = quantity === 1 ? "ticket" : "tickets";
@@ -410,24 +408,17 @@ async function sendTicketEmail(
       `‚Äî The Buzzd Team`,
     ].join("\n");
 
-    const msg: MailDataRequired = {
+    await resend.emails.send({
+      from: `Buzzd <${fromEmail}>`,
       to,
-      from: {email: fromEmail, name: "Buzzd"},
       subject: `Your Tickets for ${eventTitle}`,
       html,
       text,
-      attachments,
-      trackingSettings: {
-        clickTracking: {enable: false, enableText: false},
-        openTracking: {enable: false},
-      },
-      mailSettings: {bypassListManagement: {enable: true}},
-    };
-
-    await sgMail.send(msg);
-    logger.info(`Ticket email sent to ${to} for ${eventTitle}`);
+      attachments: attachments.map(a => ({ filename: a.filename, content: a.content })),
+    });
+    logger.info(`Ticket email sent via Resend to ${to} for ${eventTitle}`);
   } catch (err) {
-    logger.error("SendGrid send error:", err as Error);
+    logger.error("Resend send error:", err as Error);
   }
 }
 
@@ -464,7 +455,15 @@ export const verifyTicketV2 = onRequest(
           res.status(401).json({ok: false, reason: "unauthorized"});
           return;
         }
+        // Require verified + approved user
+        const emailVerified = Boolean((decoded as unknown as { email_verified?: unknown }).email_verified);
+        if (!emailVerified) { res.status(403).json({ok: false, reason: "unverified"}); return; }
         const dbAuth = getFirestore();
+        const udoc = await dbAuth.collection("users").doc(uid).get();
+        if (!udoc.exists || (udoc.data() as Record<string, unknown> | undefined)?.approved !== true) {
+          res.status(403).json({ok: false, reason: "not_approved"});
+          return;
+        }
         const evSnap = await dbAuth.collection("events").doc(String(e)).get();
         if (!evSnap.exists || String((evSnap.data() || {}).hostUserId || "") !== uid) {
           res.status(403).json({ok: false, reason: "forbidden"});
@@ -644,7 +643,8 @@ export const getTicketPass = onRequest(
       const decoded = await admin.auth().verifyIdToken(token);
       const uid = String(decoded.uid || "");
       if (!uid) { res.status(401).json({error: "Unauthorized"}); return; }
-
+      // Allow anonymous/unverified buyers; authorization will still be enforced against
+      // the purchaser or host when checking the ticket and event below.
       const db = getFirestore();
       const tSnap = await db.collection("tickets").doc(ticketId).get();
       if (!tSnap.exists) { res.status(404).json({error: "Ticket not found"}); return; }
diff --git a/functions/src/venueStats.ts b/functions/src/venueStats.ts
index b6139593..c394a1e2 100644
--- a/functions/src/venueStats.ts
+++ b/functions/src/venueStats.ts
@@ -140,12 +140,12 @@ async function recomputeVenueRating(venueId: string): Promise<void> {
     .filter((n) => !Number.isNaN(n) && n > 0);
   const baseline = 2.5;
   const sum = ratings.reduce((a, b) => a + b, 0) + baseline;
-  const count = ratings.length + 1;
-  const avgRaw = sum / Math.max(1, count);
+  const denom = ratings.length + 1; // include baseline in average denominator
+  const avgRaw = sum / Math.max(1, denom);
   const avg = Math.round(avgRaw * 10) / 10; // 1 decimal place
   await db.collection("venues").doc(venueId).set({
     averageRating: avg,
-    totalRatings: count,
+    totalRatings: ratings.length, // store actual user rating count
     lastUpdated: admin.firestore.FieldValue.serverTimestamp(),
   }, {merge: true});
 }
